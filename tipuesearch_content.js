var tipuesearch = {"pages":[{"title":"Transforming Non-Normal Distribution to Normal Distribution","text":"In the field of statistics, the assumption of normality is important because many statistical techniques perform calculations assuming that the data is normally distributed. The techniques that assume Gaussian or Gaussian-like distribution are listed below: Techniques That Assume Normality Hypothesis testing through t-test and z-test Analysis of variance (ANOVA) Sequential Gaussian simulation in spatial analysis Control limits in control chart Unfortunately, many real-life data are not normal. Permeability distribution of rock samples is lognormal. Time required to repair a malfunctioning component follows exponential distribution, and reliability analysis for machine performance with respect to time follows Weibull distribution. What should you do if your data fails a normality test, or is not Gaussian-like? You have three options: Use it as it is or fit non-normal distribution Try non-parametric method Transform the data into normal distribution 1. Use it as it is or fit non-normal distribution Altough your data is known to follow normal distribution, it is possible that your data does not look normal when plotted, because there are too few samples. For example, test scores of college students follow a normal distribution. If you know for certain that your data is normally distributed by nature, then according to the Central Limit Theorem, your data will eventually become normal when you obtain a greater number of sample data. This means that you can still use the famous standard deviation method to assign letter grades to students ( figure 1 ), even if your students' test scores do not look normally distributed. If you increase the number of students that takes your exam, the test score distribution will become more normal according to the Central Limit Theorem. Figure 1: assigning letter grades with standard deviation On the other hand, if you have plenty enough samples to represent the true population, you can fit different types of distributions to better describe your data. Different methods exist for different distributions and maybe you will be able to achieve your goal without using techniques that strictly require Gaussian distribution. The code snippet below fits three different distributions on the sample data: lognormal, normal, and Weibull distributions. Through a visual inspection, it can be observed that the sample data is the best represented by a lognormal distribution . Once we know that the sample data follows lognormal distribution, we can move forward by employing techniques that assume lognormal distribution. In [3]: import numpy as np import matplotlib.pyplot as plt from scipy import stats % matplotlib notebook In [4]: # sample data generation np . random . seed ( 42 ) data = sorted ( stats . lognorm . rvs ( s = 0.5 , loc = 1 , scale = 1000 , size = 1000 )) # fit lognormal distribution shape , loc , scale = stats . lognorm . fit ( data , loc = 0 ) pdf_lognorm = stats . lognorm . pdf ( data , shape , loc , scale ) # fit normal distribution mean , std = stats . norm . fit ( data , loc = 0 ) pdf_norm = stats . norm . pdf ( data , mean , std ) # fit weibull distribution shape , loc , scale = stats . weibull_min . fit ( data , loc = 0 ) pdf_weibull_min = stats . weibull_min . pdf ( data , shape , loc , scale ) In [5]: # visualize fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( data , bins = 'auto' , density = True ) ax . plot ( data , pdf_lognorm , label = 'lognorm' ) ax . plot ( data , pdf_norm , label = 'normal' ) ax . plot ( data , pdf_weibull_min , label = 'Weibull_Min' ) ax . set_xlabel ( 'X values' ) ax . set_ylabel ( 'probability' ) ax . legend (); Notes Visual inspection is one option to assess the performance of the fitted distributions. The other option is to use hypothesis testing with Q-Q plots to numerically assess the performance of the fitted distribution. For example, if you want to numerically assess how well your data matches Gaussian distribution, you can test your hypothesis through D'Agostino-Pearson normality test, Anderson-Darling Test, or Shapiro-Wilk Test. In this post, normality test through scipy.stats.normaltest() will be covered. 2. Try non-parametric method There are pros and cons for using non-parametric methods. The biggest pros is that it does not assume anything about the distribution. They are distribution-free . You do not need to know distribution shape, mean, standard devation, skewness, kurtosis, etc... All you need is just a set of sample data that is representative of a population. The fact that it does not assume anything about the distribution has another implication when you have small number of data - there's no need for Central Limit Theorem to be applied. Recall that the Central Limit Theorem states that the data will become more and more Gaussian-distributed as the number of samples increases. Techniques that assume normality of a distribution expect the sample data to follow Central Limit Theorem. Non-parametric methods improves the performance of statistical calculation when there are too few number of samples that the Central Limit Theorem can't be applied. However, it is important that those few samples are reasonably representative of the true population. If they are not, your result will be biased. Non-parametric methods are geared toward hypothesis testing rather than estimation. Disadvantages of non-parametric methods include lack of power compared to more traditional approaches that require prior knowledge of a distribution. If you knew the distribution of your data with 100% certainty, there is no reason to use a non-parametric method. Doing so would be a waste of perfectly good prior knowledge. Another disadvantage is that many non-parametric methods are computation intensive. For example, Boostrapping is a non-parametric alternative that requires numerical iterations to calculate confidence interval of statistics. On the other hand, if the assumption of normality holds valid for your data, you can directly compute the confidence interval by using a simple equation. Notes Parametric methods are the type of methods that assume a certain shape of a distribution. For example, the following equation is used to calculate the confidence interval of a mean of a distribution: CI of mean = sample mean $\\pm$ $($distribution score $\\times$ Standard Error $)$ The variable in the equation, distribution score , depends on the type of the distribution. If you do not know the distribution shape of your data, it is very difficult to obtain the value of the distribution score. On the other hand, non-parametric methods do not assume anything about a distribution. A non-parametric alternative to calculate confidencer interval of mean is to use Bootstrapping . The following table lists non-parametric alternatives to techniques that assume normality of a distribution: Techniques That Assume Normality Non-Parametric Alternatives Confidence Interval with z-test Bootstrapping T-test Mann-Whitney test; Mood's median test; Kruskal-Wallis test ANOVA Mood's median test; Kruskal-Willis test Paired t-test One-sample sign test F-test; Bartlett's test Levene's test Individuals control chart Run Chart 3. Transform the data into normal distribution The data is actually normally distributed, but it might need transformation to reveal its normality. For example, lognormal distribution becomes normal distribution after taking a log on it. The two plots below are plotted using the same data, just visualized in different x-axis scale. Observe how lognormal distribution looks normal when log is taken on the x-axis. In [6]: import numpy as np import matplotlib.pyplot as plt from scipy import stats % matplotlib notebook In [7]: # sample data generation np . random . seed ( 42 ) data = sorted ( stats . lognorm . rvs ( s = 0.5 , loc = 1 , scale = 1000 , size = 1000 )) # fit lognormal distribution shape , loc , scale = stats . lognorm . fit ( data , loc = 0 ) pdf_lognorm = stats . lognorm . pdf ( data , shape , loc , scale ) In [9]: # visualize fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) ax1 . hist ( data , bins = 'auto' , density = True ) ax1 . plot ( data , pdf_lognorm ) ax1 . set_ylabel ( 'probability' ) ax1 . set_title ( 'Linear Scale' ) ax2 . hist ( data , bins = 'auto' , density = True ) ax2 . plot ( data , pdf_lognorm ) ax2 . set_xscale ( 'log' ) ax2 . set_title ( 'Log Scale' ); Similar transformations can be done on the sample data to convert non-normal to normal distribution. Lognormal transformation is used convert rock permeability distributions to normal distribution, and square root transformation is used to analyze biological population growth, such as bacterial colonies per petri dish. These types of transformations - rescaling the distribution by taking exponents or log - are called Power Transformations. Box-Cox transformation is the most popular technique within the family of power transformations. Box-Cox Transformation: Theory Box-Cox Transformation is a type of power transformation to convert non-normal data to normal data by raising the distribution to a power of lambda ($\\lambda$). The algorithm can automatically decide the lambda ($\\lambda$) parameter that best transforms the distribution into normal distribution. Box-Cox transformation is a statistical technique known to have remedial effects on highly skewed data. Essentially it's just raising the distribution to a power of lambda ($\\lambda$) to transform non-normal distribution into normal distribution. The lambda ($\\lambda$) parameter for Box-Cox has a range of -5 < $\\lambda$ < 5 . If the lambda ($\\lambda$) parameter is determined to be 2, then the distribution will be raised to a power of 2 — $Y&#94;2$. The exception to this rule is when the lambda ($\\lambda$) parameter is 0 - log will be taken to the distribution — log($Y$). The below table shows how Box-Cox transformation raises the power of a distribution to different lambda ($\\lambda$) values: Lambda ($\\lambda$) Transformed Distribution ($Y&#94;{'}$) -2 $Y&#94;{'} = \\frac{1}{Y&#94;2}$ -1 $Y&#94;{'} = \\frac{1}{Y&#94;1}$ -0.5 $Y&#94;{'} = \\frac{1}{sqrt(Y)}$ 0 $Y&#94;{'} = log(Y)$ 0.5 $Y&#94;{1} = sqrt(Y)$ 1 $Y&#94;{'} = Y$ 2 $Y&#94;{'} = Y&#94;2$ Although in the table lambda ($\\lambda$) values of only -2 < $\\lambda$ < 2 were displayed, the actual algorithm has a range of -5 < $\\lambda$ < 5 . Also note that using a lambda ($\\lambda$) value of 1 does not do anything to the distribution. If the Box-Cox algorithm spits out $\\lambda = 1$, it probably means that your data is Gaussian-like or Gaussian enough to an extent that there is no need for transformation. All data to be positive and greater than 0 (Y > 0) Box-Cox transformation does not work if data is smaller than 0. This can easily be fixed by adding a constant ($C$) that will make all your data greater than zero. The transformation equation is then: $Y&#94;{'} = (Y + C)&#94;{\\lambda}$ Python Code Implementation The code implementation for Box-Cox transformation is very simple with the help of scipy.stats.boxcox() . from scipy import stats xt, lmbda = stats.boxcox(x) xt is the transformed data, and lmbda is the lambda ($\\lambda$) parameter. More detailed usage & analysis of Box-Cox will be covered in the next section. Box-Cox Transformation: Phone Call Duration - Gamma Distribution The distribution for phone call duration follows Erlang distribution, a member of a family of Gamma distribution. When the shape parameter of Gamma distribution has an integer value, the distribution is the Erlang disribution. Since power transformation is known to work well with Gamma distribution, we can try Box-Cox transformation to turn non-normal data into normal data. The below code snippet demonstrates how a typical Gamma distribution looks like when plotted: In [10]: from scipy import stats import matplotlib.pyplot as plt import numpy as np % matplotlib notebook In [11]: # random variable generation for gamma distribution def generate_gamma_dist ( shape ): dist_gamma = sorted ( stats . gamma . rvs ( shape , loc = 0 , scale = 1000 , size = 5000 )) shape , loc , scale = stats . gamma . fit ( dist_gamma , loc = 0 ) pdf_gamma = stats . gamma . pdf ( dist_gamma , shape , loc , scale ) return dist_gamma , pdf_gamma In [12]: # visualize fig , ax = plt . subplots ( figsize = ( 8 , 4 )) for i in range ( 1 , 5 ): x , y = generate_gamma_dist ( i ) ax . plot ( x , y , label = 'shape parameter = %s ' % i ) ax . set_xlabel ( 'X values' ) ax . set_ylabel ( 'probability' ) ax . set_ylim ( 0 , 0.0004 ) ax . set_xlim ( 0 , 10000 ) ax . set_title ( 'Gamma (Erlang) Distribution' ) ax . legend (); 1. Data Preparation 1.1. Sample Data Description We will use phone calls data from Enigma Public . Enigma Public is a website that processes & hosts various public data and allows people to obtain them through file downloads or API access. The sample data originally comes from the National Response Center (NRC). They receive phone calls from anyone witnessing an oil spill, chemical release or maritime security incident and record that data. For your convenience, I already downloaded the sample data and hosted it on this website. You can access the sample data directly by importing the file through requests . In [13]: import requests import io import pandas as pd In [14]: base_url = 'https://aegis4048.github.io/downloads/notebooks/sample_data/' filename = '08c32c03-9d88-42a9-b8a1-f493a644b919_NRCEventReporting-Calls-2010.csv' data = requests . get ( base_url + filename ) . content df = pd . read_csv ( io . StringIO ( data . decode ( 'utf-8' ))) df . head () Out[14]: seqnos date_time_received date_time_complete calltype responsible_company responsible_org_type responsible_city responsible_state responsible_zip source serialid 0 946479 2010-07-03T21:11:31+00:00 2010-07-03T21:19:57+00:00 INC NaN UNKNOWN NaN XX NaN TELEPHONE 15900 1 946480 2010-07-03T20:59:29+00:00 2010-07-03T21:16:22+00:00 INC CHEVRON PRIVATE ENTERPRISE NaN HI NaN WEB REPORT 15901 2 946481 2010-07-03T21:42:43+00:00 2010-07-03T21:53:07+00:00 INC BP PRIVATE ENTERPRISE NaN LA NaN TELEPHONE 15902 3 946482 2010-07-03T22:22:41+00:00 2010-07-03T22:34:07+00:00 INC CHEVRON PRIVATE ENTERPRISE SAN LUIS OBISPO CA 93401 TELEPHONE 15903 4 946483 2010-07-03T22:46:13+00:00 2010-07-03T22:50:24+00:00 INC NaN UNKNOWN NaN XX NaN TELEPHONE 15904 1.2. Sample Data Processing Since we are interested in the time ellapsed for each phone call, the primary columns of our interest are date_time_received and date_time_complete . However, the raw data is not in a numerical format that can be directly plotted on histogram; we will need to parse & process the time data. I chose .iloc[11000: 12000, :] because it would take too long time to process all ~30,000 rows of the original data. The data is then sorted by the timestamp column. Process DateTime In [15]: import datetime In [16]: def process_time ( row ): call_received = datetime . datetime . strptime ( row [ 'date_time_received' ] . split ( '+' )[ 0 ], '%Y-%m- %d T%H:%M:%S' ) call_ended = datetime . datetime . strptime ( row [ 'date_time_complete' ] . split ( '+' )[ 0 ], '%Y-%m- %d T%H:%M:%S' ) time_ellapsed = call_ended - call_received row [ 'Parsed Call Received' ] = str ( call_received ) row [ 'Parsed Call Ended' ] = str ( call_ended ) row [ 'Time Ellapsed' ] = str ( time_ellapsed ) row [ 'Time Ellapsed (minutes)' ] = round ( time_ellapsed . total_seconds () / 60 , 1 ) return row In [17]: # df was defined above parsed_df = df . iloc [ 11000 : 12000 , :] . apply ( process_time , axis = 1 ) . iloc [:, - 4 :] parsed_df [ 'Parsed Call Received' ] = pd . to_datetime ( parsed_df [ 'Parsed Call Received' ], format = '%Y-%m- %d %H:%M:%S' ) parsed_df [ 'Parsed Call Ended' ] = pd . to_datetime ( parsed_df [ 'Parsed Call Ended' ], format = '%Y-%m- %d %H:%M:%S' ) parsed_df = parsed_df . sort_values ( by = 'Parsed Call Received' ) parsed_df . head () Out[17]: Parsed Call Received Parsed Call Ended Time Ellapsed Time Ellapsed (minutes) 11000 2010-05-21 19:32:09 2010-05-21 19:43:35 0:11:26 11.4 11001 2010-05-21 19:54:40 2010-05-21 19:58:40 0:04:00 4.0 11002 2010-05-21 20:03:14 2010-05-21 20:09:11 0:05:57 6.0 11003 2010-05-21 20:04:26 2010-05-21 20:07:39 0:03:13 3.2 11004 2010-05-21 20:18:38 2010-05-21 20:27:45 0:09:07 9.1 Drop Duplicate Rows The original data does not record the time to a precision of microseconds ( 2010-07-03T21:11:31+00:00 ). Due to the imprecision of the recorded data, there will be rows with duplicate date_time_received and date_time_complete . The data itself is not duplicate, but the data in datetime column is duplicate. Leaving them as they are and plotting them might mess up your plots. Observe the change in the row number of the data frame. It's the indication that there are rows with the same date_time_received values. In [18]: parsed_df . shape Out[18]: (1000, 4) In [19]: new_parsed_df = parsed_df . drop_duplicates ( subset = [ 'Parsed Call Received' ], keep = False ) new_parsed_df . shape Out[19]: (998, 4) 2. Transformatoin 2.1. Sample Data Histogram It can be observed that the phone call duration data does not follow normal distribution. In [39]: time_duration_orig = new_parsed_df [ 'Time Ellapsed (minutes)' ] . values In [40]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( time_duration_orig , bins = 'auto' , density = True ) ax . set_xlabel ( 'Call Duration (minutes)' ) ax . set_ylabel ( 'probability' ) ax . set_title ( 'Non-normal Distribution of Phone Call Duration' ); 2.2. Box-Cox Transformation The Python code implementation for Box-Cox is actually very simple. The below one-line code is it for transformation. More information about the Box-Cox function can be found in the scipy documentaion . In [41]: time_duration_trans , lmbda = stats . boxcox ( time_duration_orig ) How does Box-Cox determine the best transformation parameter to obtain a distribution that is close to normal? It calculates correlation coefficient for different lambda ($\\lambda$) values, and finds the one that maximizes the correlation coefficient. In our case, we find that the best lambda parameter is $\\lambda = 0.322$ In [42]: print ( 'Best lambda parameter = %s ' % round ( lmbda , 3 )) fig , ax = plt . subplots ( figsize = ( 8 , 4 )) prob = stats . boxcox_normplot ( time_duration_orig , - 20 , 20 , plot = ax ) ax . axvline ( lmbda , color = 'r' ); Best lambda parameter = -0.322 2.3. Visual Inspection by Fitting Gaussian Distribution One can visually inspect how good the transformation was by fitting a Gaussian distribution function. In [43]: # fit Gaussian distribution time_duration_trans . sort () mean , std = stats . norm . fit ( time_duration_trans , loc = 0 ) pdf_norm = stats . norm . pdf ( time_duration_trans , mean , std ) In [44]: # visual inspection fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( time_duration_trans , bins = 'auto' , density = True ) ax . plot ( time_duration_trans , pdf_norm , label = 'Fitted normal distribution' ) ax . set_xlabel ( 'Call Duration (minutes)' ) ax . set_ylabel ( 'Transformed Probability' ) ax . set_title ( 'Box-Cox Transformed Distribution of Phone Call Duration' ) ax . legend (); Based on the transformed historgram and the respective fitted normal distribuion, it seems that our Box-Cox transformation with $\\lambda = -0.322$ worked well. 2.4. Visual Inspection with Q-Q Plots Visual inspection can be done in a different way with Q-Q plots. The red straight line is the fitted theoretical Gaussian distribution function. If the scatter plot is closer to the red straight line, it means that the data is very close to Gaussian distribution. Deviation from the red line indicates that the data is most likely not Gaussian. Recall that time_duration_orig is the original sample data, and time_duration_trans is the Box-Cox transformed data. In [26]: fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) prob = stats . probplot ( time_duration_orig , dist = stats . norm , plot = ax1 ) prob = stats . probplot ( time_duration_trans , dist = stats . norm , plot = ax2 ) ax1 . set_title ( 'Original Data' ) ax1 . set_ylabel ( 'Call Duration (minutes)' ) ax2 . set_title ( 'Transforamed Data, λ = %s ' % - 0.322 ); ax2 . set_ylabel ( '' ); No significant deviation is observed in Q-Q plots for the transformed data. The transformed data seems to follow Gaussian distribution well. 2.5. Normality Test with Hypothesis Testing Sometimes one might prefer not to evaluate the normality of the transformed data with visual inspection. It is possible to run formal hypothesis testing and check normality in terms of statistical values with scipy.stats.normaltest . It is based on D'Agostino and Pearson's test that combines skew and kurtosis to produce an omnibus test of normality. scipy.stats.normaltest() returns a 2-tuple of the chi-squared statistic, and the associated p-value. Given the null hypothesis that x came from a normal distribution, if the p-value is very small, we reject the null hypothesis. It means that it is unlikely that the data came from a normal distribution. In [45]: k2 , p = stats . normaltest ( time_duration_trans ) print ( ' \\n Chi-squared statistic = %.3f , p = %.3f ' % ( k2 , p )) alpha = 0.05 if p > alpha : print ( ' \\n The transformed data Gaussian (fails to reject the null hypothesis)' ) else : print ( ' \\n The transformed data does not look Gaussian (reject the null hypothesis)' ) Chi-squared statistic = 2.453, p = 0.293 The transformed data Gaussian (fails to reject the null hypothesis) The traditional alpha value of 5% was assumed ($\\alpha = 0.05$). Based on the result of the hypothesis testing, it seems that the transformed data does not significantly deviate from a theoretical Gaussian distribution. 3. Back Transformation - Control Chart Analysis One might wonder why we ever want to transform data into something different. What's the point of running analysis on transformed data that significantly deviates from the original data? Let's say that you have a sample data for human's life expectancy, which ranges between 0 and 100. Let's say that the distribution is not Gaussian, so you raised it to a power of 2 to convert it to Gaussian, making the transformed range to be between 0 to 10000. You calculate the mean of the transformed data and find out that the mean is 4,900 years. It is unreasonble to think that average life span of humans is 4,900 years. $$ transformed \\space average \\space life \\space span = 4,900 \\space years $$ One must note that the whole point of data transformation is not to transform the data itself, but to use techniques that require a certain form of a distribution and acquire correct statistical values of your interest. This is where Back Transformation comes into play. You raised your sample data to a power of 2, and obtained the mean value of 4,900 years. Since you raised it to a power of 2, you will back transform it by lowering its power by 2. $$ original \\space average \\space life \\space span = \\sqrt{transformed \\space average \\space life \\space span} = \\sqrt{4,900 \\space years} = 70 \\space years $$ The concept of back transformation will be illustrated with control chart analysis. 3.1. Control Chart Basics If you don't have a good understanding of what control chart is, I recommend you to read this article . It is well written with clean, illustrative visualizations. The upper and lower control limits (UCL and LCL) in control charts are defined as values that are three standard deviations from a mean ($\\mu \\space \\pm \\space 3 \\sigma$). The control limits can be plotted on control chart with the following code snippet (note that new_parsed_df and time_duration_orig were defined above): In [29]: y = new_parsed_df [ 'Parsed Call Received' ] . values In [30]: mean = np . mean ( time_duration_orig ) std = np . std ( time_duration_orig ) upper_limit = mean + 3 * std lower_limit = mean - 3 * std In [31]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_orig ) ax . axhline ( mean , color = 'C1' ) ax . axhline ( upper_limit , color = 'r' ) ax . axhline ( lower_limit , color = 'r' ); ax . text ( y [ - 200 ], upper_limit + 3 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], lower_limit + 3 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean + 3 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Original' ); A few interesting observations could be drawn from the control chart visualization. Intervals with low call duration are coming from phone calls made at late night. The peaks seem to happen quite regularly. This makes sense considering how some phone calls take much longer than the others due to special circumstances No phone call duration is smaller than 0 3.2. Why Is Transformation Necessary? The upper control limit plotted on the above visualization defines any phone calls that take longer than 26 minutes to be an outlier. But, are they really outliers? Some phone calls might take longer than 26 minutes due to some extreme circumstances. Moreover, those \"outliers\" seem to be happening too often to be considred outliers. This is happening because the calculation of control limits through plus/minus three standard deviation ($\\pm \\space 3 \\sigma$) assumes that the data is normally distributed. The standard deviation method fails because the assumption of normality is not valid for the phone call duration distribution. Box-Cox transformation is necessary. In [32]: time_duration_trans , lmbda = stats . boxcox ( time_duration_orig ) In [33]: mean_trans = np . mean ( time_duration_trans ) std_trans = np . std ( time_duration_trans ) upper_limit_trans = mean_trans + 3 * std_trans lower_limit_trans = mean_trans - 3 * std_trans In [34]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_trans ) ax . axhline ( mean_trans , color = 'C1' ) ax . axhline ( upper_limit_trans , color = 'r' ) ax . axhline ( lower_limit_trans , color = 'r' ); ax . text ( y [ - 200 ], upper_limit_trans - 0.15 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], lower_limit_trans + 0.15 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean_trans + 0.1 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Transformed' ); A quick glance at the control chart of the transformed data tells us that the most of the phone calls were actually within the upper and lower control limit boundaries. $\\pm \\space 3 \\sigma$ standard deviation method is now working because the assumption of normality is satisfied. 3.3. Back Transforming Control Limits It is difficult for non-statisticians to understand that we are drawing conclusions from the transformed data. We need to back transform the calculated upper and lower control limits by taking the inverse of the lambda ($\\lambda$) parameter we applied for Box-Cox transformation. scipy.special.inv_boxcox will do the job. In [35]: from scipy.special import inv_boxcox In [36]: back_trans_upper_limits = inv_boxcox ( upper_limit_trans , lmbda ) back_trans_lower_limits = inv_boxcox ( lower_limit_trans , lmbda ) mean = np . mean ( time_duration_orig ) In [37]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_orig ) ax . axhline ( mean , color = 'C1' ) ax . axhline ( back_trans_upper_limits , color = 'r' ) ax . axhline ( back_trans_lower_limits , color = 'r' ); ax . text ( y [ - 200 ], back_trans_upper_limits + 3 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], back_trans_lower_limits + 3 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean + 3 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Back Transformed' ); After back-transforming the Box-Cox transformed data, we can now draw a conclusion that all of the phone calls, except for one, made to the National Response Center between 2010-05-22 to 2010-06-01 were within the control limits.","tags":"Statistics","url":"https://aegis4048.github.io/transforming-non-normal-distribution-to-normal-distribution","loc":"https://aegis4048.github.io/transforming-non-normal-distribution-to-normal-distribution"},{"title":"Spatial Simulation 1: Basics of Variograms","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Variogram , and Variogram Excel numerical demo on his Github repo to help yourself better understand the statistical theories and concepts. Let's say that you are a spatial data analyst of a gold mining company, and want to know the distribution of gold percentage over 100m x 100m mining area. To understand the characteritics of the rock formations, you take 100 random rock samples from the mining area, but obviously these 100 data points are not enough to estimate gold percentage over every single spatial locations in the area. So you analyze the available data (100 rock samples from random locations) and simulate full 2D-surface plot for gold percentage over the mining area. This 2D surface simulation from sparse spatial data is a sequential process that involved a series of geostatistical techniques. Steps: Plot experimental variogram Fit variogram model Apply kriging Apply simulation on top of Kriging Run simulation multiple times and perform additioanl data analyses as needed In this post, the concepts, theory, and methodology of plotting a variogram will be covered. Experimental Variogram: Theory Variogram is a measure of dissimilarity over a distance. It shows how two data points are correlated from a spatial perspective, and provides useful insights when trying to estimate the value of an unknown location using collected sample data from other locations. Tobler's first law of geography states that \"everything is related to everything else, but near things are more related than distant things.\" Variogram shows the correlation between two spatial data points over distances. For example, terrains 1 km apart from each other are more likely to be similar than terrains 100 km apart from each other. Oil wells 500 ft apart from each other are more likely to show similar reservoir characteristics than oil wells 5000 ft apart from each other. Variogram is a function of variance over distance. It has the following equation and plot: $$\\gamma(h) = \\frac{1}{2N(h)}\\sum_{\\alpha =1}&#94;{N(h)}\\left ( z(u_{\\alpha })-z(u_{\\alpha} + h) \\right)&#94;2$$ Variables Explained $\\gamma(h)$ = a measure of dissimilarity vs distance. It is a spatial variance between two data points separated by the distance, $h$. $N(h)$ = number of all data point pairs separated by the distance, $h$. $h$ = lag distance. Separation between two data points. $u_{\\alpha }$ = data point on 2D or 3D space at the location, $\\alpha$. $u_{a} + h$ = data point separated from $u_{\\alpha }$ by the distance, $h$. $z(u_{\\alpha })$ = numerical value of data point, $u_{\\alpha }$ $z(u_{\\alpha} + h)$ = numerical value of data point, $u_{\\alpha} + h$ $\\sigma&#94;2$ = sill. Variance at lag distance, $h$, in which spatial data pairs lose correlation. Observation 1: $z(u_{\\alpha })$ - $z(u_{\\alpha} + h)$ There are two data points on the image: $z(u_{\\alpha })$ and $z(u_{\\alpha } + h)$. These two points are separated by the lag distance, $h$. The equation for variogram observes the difference between these two data points: $$z(u_{\\alpha })-z(u_{\\alpha} + h)$$ Observation 2: $N(h)$ $N(h)$ accounts for all data point pairs that are separated by lag distance $h$. Although only horizontal separation is shown in the image, separation between two data points can be horizontal, vertical, or diagonal. Variogram will calculate the difference between all pairs of data points, $z(u_{\\alpha })-z(u_{\\alpha} + h)$, that are separated lag distance, $h$. $$\\sum_{\\alpha =1}&#94;{N(h)}\\left ( z(u_{\\alpha })-z(u_{\\alpha} + h) \\right)&#94;2$$ Observation 3: $\\gamma (h)$ $\\gamma (h)$ denotes for variability of spatial data points at a lag distance, $h$. Recall that variogram accounts for all pairs separated by distance, $h$. It may seem very simple, but one little dot on a variogram plot is actually obtained after iterating for all pairs separated by $h$. $\\underline{ h = 1m }$ $\\underline{ h = 2m }$ $\\underline{ h = 3m }$ Observe how there were less data pairs connected by red lines for $h = 3m$. As the $h$ increases, there will be fewer number of pairs that are separated by $h$ due to spatial limitation. Observation 4: Sill ($\\sigma&#94;2$) Sill ($\\sigma&#94;2$) is the variance in which spatial data pairs lose correlation. As the distance between two data points increases, it will be less likely that those two data points are related to one another. You may assume that the oil wells separated by 100 ft exibit similar geologic characteristics, but you can't assume the same for a well in Texas and a well in California. Variogram works the similar way. Notes Spatial variance may never reach the sill if there is a trend. Ex: Area trend between well variability Observation 5: Range ($a$) Range is a distance in which the spatial variability reaches the sill ($\\sigma&#94;2$). Let's say that you are an exploration engineer for drilling a new oil well. You have drilled wells A, B, C, D that are each 100ft, 200ft, 300ft, and 400ft apart from the zone you want to drill a next new well, and want to know if you can use the data from the previously drilled wells. The geostatisticians in your team report that the geologic formation in the region has a range of 350 ft. This means that the rocks in the region lose geologic correlation with one another if they are more than 350 ft apart — you can't use data from well D because it is 400 ft apart. Observation 6: Nugget Effect ($c_{0}$) The nugget effect refers to the nonzero intercept of the variogram and is an overall estimate of error caused by measurement inaccuracy and environmental variability occurring at fine enough scales to be unresolved by the sampling interval. At distance $h = 0$, we would expect the spatial variance between pairs will be zero, but some variables seem to change in an abrupt manner in very short distance. The nugget effect is like the random noise. It's just the small scale variability that you can't estimate with your large scale variability model. However, if there is no expectation of high degree of discontinuity at distances shorter than the minimum data spacing, experts tend to ignore nugget effect ub geologic engineering. Summary In variogram, low variance ($\\gamma$) represents stronger correlation among data pairs. Spatial data pairs lose correlation with one another when variance ($\\gamma$) at lag distance ($h$) reaches the sill ($\\sigma&#94;2$). If there are variance poitns that exceeds the sill, it indicates the presence of trend, and needs to be detrended before variogram modeling. More information about trend will be discussed later. Experimental Variogram: Search Template Parameters Calculating variogram is challenging because real-life data are not as clean as the 2-D grid sample images shown above. Real-life data are often sparse data that are irregularly spaced. The sparse data you will get in real-life will have very few, or even no data point pairs that are EXACTLY $h$ distance apart from each other. Furthermore, the data points will not always be orthogonal or pararell to each other — there will be diagonalities. regular Spacing irregular Spacing So how do we get pairs separated by lag distance, $h$? We need to consider distance, tolerance, azimuth direction, azimuth tolerance, dip direction, dip tolerance, bandwith in horizontal plane, and bandwidth in vertical plane — through a set of guidelines called Variogram Search Template . variogram Search Template Choice of Azimuth (Directionality) ellipsoidal growth in orthogonal directions, 3D Natural process does not lead to omnidirectionality. Typically there is a direction of major continuity, such as statigraphic surface, and a direction minimum continuity such as perpendicular layers. The choice of azimuth is carefully decided after combining knowledge of geologists and geologic understanding of the region from previously sampled data. There are three orthogonal directions — horizontal major, horizontal minor, and vertical. The \"vertical\" directional is assumed to be the direction orthogonal to the horizontal plane; the vertical direction doesn't have to correspond to the Z-axis. The three mutually orthogonal directions grow in ellipsoidal shape, with the horizontal major axis constituting the longer radius the ellipse. Azimuth decides the direction of horizontal major axis. In typical geometry, an angle ($\\theta$) is measured from the positive X-axis, but in variogram, azimuth is measured from the positive Y-axis. Notes According to an article written by Jared Deutsch , in the absence of strong geologic evidence, a neutral isotropic model can be constructed to assist in determining a principle direction (in later code implementation, isotropy is established by setting azi_tol=90 . You are allowing for $\\pm$90 degrees of azimuth tolerance). Using ordinary kriging, a neutral model would be constructed with an isotropic, long range, high nugget effect variogram. You will check if you can observe any directionality in this neutral model, and combine it with other geologic knowledge to assist in determinng the principle direction. Choice of Azimuth Tolerance Azimuth tolerance should be chosen such that maximum number of pairs are found in the search template and exclude unreasonable associations. A common choice of azimuth tolerance is 22.5°. However, it can be changed to make a decision about whether to increase precision, or stability. Reducing angle tolerance will give precise variogram ( figure 1 ), and increasing angle tolerance will give stable variogram ( figure 2 ). figure 1: smaller azimuth tol -> precise figure 2: bigger azimuth tol -> stable Choice of Lag Distance A variogram should span less than the maximum length of the field. For example, if the field A has a dimension of 100km x 100km, the maximum lag distance ($h$) of the calculated variogram should be less than 50 km. Calculating longer lags results in pairing samples from the edges of the field with each other. Due to spatial limitation of the field (recall that field A is only 100km long), there will be fewer pairs that are 80, 90, 100km apart than pairs that are 5, 10, 20km apart from each other. These variogram points will be much less informed than shorter distance pairs, with fewer pairs supporting the calculation. Observe how the figure 4 shows misleading information about the region. The figure tells us that the correlation becomes stronger for pairs separated by $h > 50$ as their distance increases. This is inconsistent with natural process — we expect the spatial correlation among pairs to decrease as they are further apart from each other. figure 3: sample Data figure 4: total lag = field length figure 5: total lag = field length / 2 Increasing the number of lag distance will result in fewer lag bins, which means that there will be fewer points on the calculated variogram ( figure 6 ). There will be a trade-off between stability and precision, and an engineer must carefully choose the parameters that is the best representative of the geology of the region. figure 6: stable, but imprecise figure 7: precise, but unstable Choice of Lag Tolerance Lag tolerance is usually half of the lag distance ( figure 8 ). Choosing lag tolerance smaller than 1/2 lag distance will result in missing out data pairs that are not within the lag tolerance ( figure 9 ). Choosing lag tolerance bigger than 1/2 lag distance will result in overlapping of data pairs ( figure 10 ). figure 8: lag tol. = 1/2 lag dist. figure 9: lag tol. < 1/2 lag dist. figure 10: lag tol. > 1/2 lag dist. Although the lag tolerance is usually half of the lag distance, in cases of erratic variograms, we may choose to overlap calculations by setting lag tolerance that is greater than half of the lag distance to increase stability in a variogram. Overlapping calculations has an effect of smoothing out and reducing noise in the calculated variogram ( figure 12 ). Smoothing out the calculated variogram maybe helpful in fitting a variogram model later. However, be careful not to smooth out too much, as it will result in imprecise variogram model that is not representative of the regional geology. A decision between stability and precision must be made. figure 11: noisy figure 12: smooth Choice of Bandwidth Just like azimuth tolerance, bandwidth should be chosen such that maximum number of pairs are found in the search template and exclude unreasonable associations. According to Jared Deutsch , bandwidths are infrequently used as they seldom improve the stability of the calculaed variogram. Instead, a carefully chosen set of angle tolerances (azimuth and dip) are applied. Experimental Variogram: Python Implementation In [ ]: In [ ]:","tags":"Geostatistics","url":"https://aegis4048.github.io/spatial-simulation-1-basics-of-variograms","loc":"https://aegis4048.github.io/spatial-simulation-1-basics-of-variograms"},{"title":"Parse PDF Files While Retaining Structure with Tabula-py","text":"If you've ever tried to do anything with data provided to you in PDFs, you know how painful it is — it's hard to copy-and-paste rows of data out of PDF files. It's especially hard if you want to retain the formats of the data in PDF file while extracting text. Most of the open source PDF parsers available are good at extracting text. But when it comes to retaining the the file's structure, eh, not really. Try tabula-py to extract data into a CSV or Excel spreadsheet using a simple, easy-to-use interface. One look is worth a thousand words. Take a look at the demo screenshot. Installations This installation tutorial assumes that you are using Windows. However, according to the offical tabula-py documentation , it was confirmed that tabula-py works on macOS and Ubuntu. 1. Download Java Tabula-py is a wrapper for tabula-java, which translates Python commands to Java commands. As the name \"tabula-java\" suggests, it requires Java. You can download Java here . 2. Set environment PATH variable (Windows) One thing that I don't like about Windows is that it's difficult to use a new program I downloaded in a console environment like Python or CMD window. But oh well, if you are a Windows user, you have to go through this extra step to allow Python to use Java. If you are a macOS or Ubuntu user, you probably don't need this step. Find where Java is installed, and go to Control Panel > System and Security > System > Advanced system settings > Advanced > Environment Variables... to set environment PATH variable for Java. Make sure you have Java\\jdk1.8.0_201\\bin and Java\\jre1.8.0_201\\bin in the environment path variable. Then, type java -version on CMD window. If you successfully installed Java and configured the environment variable, you should see something like this: java -version java version \"1.8.0_201\" Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) If you don't see something like this, it means that you didn't properly configure environment PATH variable for Java. 3. Re-start Your Command Prompt Any program invoked from the command prompt will be given the environment variables that was at the time the command prompt was invoked. If you launched your Python console or Jupyter Notebook before you updated your environment PATH variable, you need to re-start again. Otherwise the change in the environment variable will not be reflected. If you are experiencing FileNotFoundError or 'java' is not recognized as an internal or external command, operable program or batch file inside Jupyter or Python console, it's the issue of environment variable. Either you set it wrong, or your command prompt is not reflecting the change you made in the environment variable. To check if the change in the environment variable was reflected, run the following code in Jupyter or Python console: import os s = os.environ[\"PATH\"].split(';') for item in s: print(item) Something like these must be in the output if everything is working fine: C:\\Program Files\\Java\\jdk1.8.0_201\\bin C:\\Program Files\\Java\\jre1.8.0_201\\bin 4. Install Tabula-py This is the last step: pip install tabula-py More detailed instructions are provided in the github repo of tabula-py Tabula Web Application Tabula supports web application to parse PDF files. You do not need this to use tabula-py, but from my personal experience I strongly recommend you to use this tool because it really helps you debugging issues when using tabula-py. For example, I was tring to parse 100s of PDF files at once, and for some reason tabula-py would return an NoneType object instead of pd.DataFrame object (by default, tabula-py extracts tables in dataframe) for one PDF file. There was nothing wrong with my codes, and yet it would just not parse the file. So I tried opening it on the tabula web-app, and realized that it was actually a scanned PDF file and that tabula is unable to parse scanned PDFs. Long story short, if it can be parsed with tabula web-app, you can replicate it with tabula-py. If tabula web-app can't, you should probably look for a different tool. Installations If you already configured the environment PATH variable for Java, all you need to do is downloading the .zip file here and running tabula.exe . That's it. Tabula has really nice web UI that allows you to parse tables from PDFs by just clicking buttons. Note The web-app will automatically open in your browser with 127.0.0.1:8080 local host. If port 8080 is already being used by another process, you will need to shut it down. But normally you don't have to worry about this. Screenshots This is what you will see when you launch tabula.exe . Browse... the PDF file you want to parse, and import . You can either use Autodetect Tables or drag your mouse to choose the area of your interest. If the PDF file has a complicated structure, it is usually better to manually choose the area of your interest. Also, note the option Repeat to All Pages . Selecting this option will apply the area you chose for all pages. Here's the output. More explanation about Lattice and Stream options will be discussed in detail later. Template JSON Files Tabula web-app accepts the user's drag & click as input and translates it into Java arguments that are actually used behind the scenes to parse PDF files. The translated Java arguments are accessible to users in a JSON format. Select the area you want to parse, and click Save Selections as Template . Then, Download the translated Java arguments in a text JSON file. These arguments are useful when coding arguments for tabula.read_pdf() later. template.json { \"page\": 2, \"extraction_method\": \"guess\", \"x1\": 24.785995330810547, \"x2\": 589.3559953308105, \"y1\": 390.5325, \"y2\": 695.0025, \"width\": 564.57, \"height\": 304.47 } Running Tabula-py Tabula-py enables you to extract tables from PDFs into DataFrame and JSON. It can also extract tables from PDFs and save files as CSV, TSV or JSON. Some basic code examples are as follows: import tabula # Read pdf into DataFrame df = tabula.read_pdf(\"test.pdf\", options) # Read remote pdf into DataFrame df2 = tabula.read_pdf(\"https://github.com/tabulapdf/tabula-java/raw/master/src/test/resources/technology/tabula/arabic.pdf\") # convert PDF into CSV tabula.convert_into(\"test.pdf\", \"output.csv\", output_format=\"csv\") # convert all PDFs in a directory tabula.convert_into_by_batch(\"input_directory\", output_format='csv') Area Selection You can select portions of PDFs you want to analyze by setting area (top,left,bottom,right) option in tabula.read_pdf() . This is equivalent to dragging your mouse and setting the area of your interest in tabula web-app as it was mentioned above. Default is the entire page. Also note that you can choose the page, or pages you want to parse with pages option. The sample PDF file can be downloaded from here . In [1]: import tabula import pandas as pd In [37]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df Out[37]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014\\r06:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 12/13/2014\\r09:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 12/13/2014\\r11:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 12/13/2014\\r14:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 12/13/2014\\r16:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 12/13/2014\\r17:30 12/13/2014\\r18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 12/13/2014\\r18:00 12/13/2014\\r18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 12/13/2014\\r18:30 12/13/2014\\r23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 12/13/2014\\r23:30 12/14/2014\\r01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 12/14/2014\\r01:30 12/14/2014\\r03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 12/14/2014\\r03:30 12/14/2014\\r04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 12/14/2014\\r04:30 12/14/2014\\r06:00 1.5 SURF-CMT CEMENT SURFACE\\rCASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Alternatively, you can set area with percentage scale by setting relative_area=True . For this specific PDF file, the below area=(50, 5, 92, 100), relative_area=True option is equivalent to area=(406, 24, 695, 589) above. In [38]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 50 , 5 , 92 , 100 ), relative_area = True ) df Out[38]: Start Date End Date Dur (hr) Activity Activity Detail Operation Com 0 2/13/2014\\r6:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 2/13/2014\\r9:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 2/13/2014\\r1:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 2/13/2014\\r4:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 2/13/2014\\r6:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 2/13/2014\\r7:30 12/13/2014\\r18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 2/13/2014\\r8:00 12/13/2014\\r18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 2/13/2014\\r8:30 12/13/2014\\r23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 2/13/2014\\r3:30 12/14/2014\\r01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 2/14/2014\\r1:30 12/14/2014\\r03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 2/14/2014\\r3:30 12/14/2014\\r04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 2/14/2014\\r4:30 12/14/2014\\r06:00 1.5 SURF-CMT CEMENT SURFACE\\rCASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Notes on Escape Characters When used as lattice mode, tabula replaces abnormally large spacing between texts and newline within a cell with \\r . This can be fixed with a simple regex manipulation. In [41]: clean_df = df . replace ( ' \\r ' , ' ' , regex = True ) clean_df Out[41]: Start Date End Date Dur (hr) Activity Activity Detail Operation Com 0 2/13/2014 6:00 12/13/2014 09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 2/13/2014 9:00 12/13/2014 11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 2/13/2014 1:00 12/13/2014 14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 2/13/2014 4:00 12/13/2014 16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 2/13/2014 6:00 12/13/2014 17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 2/13/2014 7:30 12/13/2014 18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 2/13/2014 8:00 12/13/2014 18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 2/13/2014 8:30 12/13/2014 23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 2/13/2014 3:30 12/14/2014 01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 2/14/2014 1:30 12/14/2014 03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 2/14/2014 3:30 12/14/2014 04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 2/14/2014 4:30 12/14/2014 06:00 1.5 SURF-CMT CEMENT SURFACE CASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Lattice Mode vs Stream Mode Tabula supports two primary modes of table extraction — Lattice mode and Stream mode. Lattice Mode lattice=True forces PDFs to be extracted using lattice-mode extraction. It recognizes each cells based on ruling lines, or borders of each cell. Stream Mode stream=True forces PDFs to be extracted using stream-mode extraction. This mode is used when there are no ruling lines to differentiate one cell from the other. Instead, it uses spacings among each cells to recognize each cell. PDF File 1 : Lattice mode recommended PDF file 2 : Stream mode recommended How would it look like if PDF File 1 and PDF file 2 are each extracted in both stream mode and lattice mode? In [51]: # PDF File 1: lattice mode file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head () Out[51]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014\\r06:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 12/13/2014\\r09:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 12/13/2014\\r11:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 12/13/2014\\r14:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 12/13/2014\\r16:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... In [57]: # PDF File 1: stream mode file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , stream = True , guess = False , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head ( 11 ) Out[57]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014 12/13/2014 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 06:00 09:00 NaN NaN NaN NaN SPP 2300, motor diff 650, 800 GPM, torque 18k. 2 NaN NaN NaN NaN NaN NaN (T.D. Surface @ 09:00 12-13-14) 3 12/13/2014 12/13/2014 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 4 09:00 11:00 NaN NaN NaN NaN NaN 5 12/13/2014 12/13/2014 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 6 11:00 14:00 NaN NaN NaN NaN Hole taking correct fill 7 12/13/2014 12/13/2014 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 8 14:00 16:00 NaN NaN NaN NaN ext. 9 12/13/2014 12/13/2014 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 10 16:00 17:30 NaN NaN NaN NaN csg. In [62]: # PDF File 2: lattice mode file = 'pdf_parsing/stream-railroad-pages-1-4.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 1 , area = ( 209 , 12.5 , 387.3 , 386 )) df Out[62]: WELL INFORMATION In [64]: # PDF File 2: stream mode file = 'pdf_parsing/stream-railroad-pages-1-4.pdf' df = tabula . read_pdf ( file , stream = True , guess = False , pages = 1 , area = ( 209 , 12.5 , 387.3 , 386 )) df Out[64]: Unnamed: 0 WELL INFORMATION 0 API No.: 42-003-46352 County: A 1 Well No.:22H RRC Distri 2 Lease Name: UNIVERSITY \"7-43\" Field Name 3 RRC Lease No.: 40532 Field No.: 4 Location: Section: 35, Block: 7, Survey: UN... NaN 5 Latitude: Longitude: 6 This well is located 17.2 miles in a SE 7 direction from ANDREWS, NaN 8 which is the nearest town in the county. NaN Observe how lattice mode extraction for PDF file 2 was able to extract only \"WELL INFORMATION\" string. This is not an error. Recall that lattice mode identifies cells by ruling lines. Notes About guess option According to the offical documentation , guess is known to make a conflict between stream option. If you feel something strange with your result, try setting guess=False . For example, for PDF File 1 , if stream mode is used without setting guess=False , it would look like this: In [66]: # PDF File 1: stream mode, guess=True file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , stream = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head ( 11 ) Out[66]: Report #:3 Daily Operation:12/13/2014 06:00 - 12/14/2014 06:00 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5 Unnamed: 6 0 Job Category NaN Primary Job Type NaN NaN AFE Number NaN 1 ORIG DRILLING NaN ODR NaN NaN 033402 NaN 2 Days From Spud (days) Days on Location (days) End Depth (ftKB) End Depth (TVD) (ftKB) Dens Last Mud (lb/gal) Rig NaN NaN 3 1 3 1,859.0 1,858.5 8.60 H & P, 637 NaN NaN 4 Operations Summary NaN NaN NaN NaN NaN NaN 5 Drld. Surface f/1600' to 1859' T.D. @ 09:00... NaN NaN NaN NaN NaN NaN 6 S/M, R/U csg running equip & Run 45 jts. of... NaN NaN NaN NaN NaN NaN 7 Surface Float shoe @ 1,857.5' NaN NaN NaN NaN NaN Surface 8 Float collar @ 1,817.9' NaN NaN NaN NaN NaN NaN 9 Remarks NaN NaN NaN NaN NaN NaN 10 Rig (H&P 637), Well (University 7-43 # 22H) NaN NaN NaN NaN NaN NaN Pandas Option Pandas arguments can be passed into tabula.read_pdf() as a dictionary object. In [74]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 ), pandas_options = { 'header' : None }) df . head () Out[74]: 0 1 2 3 4 5 6 0 Start Date End Date (hr) Activity Activity Detail Operation Com 1 12/13/2014\\r06:00 12/13/2014\\r09:00 3 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 2 12/13/2014\\r09:00 12/13/2014\\r11:00 2 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 3 12/13/2014\\r11:00 12/13/2014\\r14:00 3 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 4 12/13/2014\\r14:00 12/13/2014\\r16:00 2 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... More Documentation Further instructions about tabula-py can be found on its official github repo .","tags":"Data Mining","url":"https://aegis4048.github.io/parse-pdf-files-while-retaining-structure-with-tabula-py","loc":"https://aegis4048.github.io/parse-pdf-files-while-retaining-structure-with-tabula-py"},{"title":"Creating a Jupyter Notebook-Powered Data Science Blog with Pelican","text":"What powers this blog, Pythonic Excursions? - Pelican. - Me Pelican is a static site genertor, written in Python. It is a Python library used to auto-generate HTML elements that are used to run websites. Pelican-powered blogs are light and easy to host with no scaling concerns. It pre-generates HTML files and responds with the existing files during a typical HTTP request-response cycle. So, why should you use Pelican? It's GREAT for Blogging You can write your content directly with the editor of your choice in reStructuredText or Markdown formats. Select a favorite theme of your choice from a collection of Pelican-themes , and write articles. The CSS and Javascript contained in the theme will handle the rest and output your article nice and clean. One look is worth a thousand words. Take a look at this markdown file that is used to render this article through Github Pages by Jake VanderPlas . His blog is made with Pelican, after modifying some codes in Octopress theme (you can also write your articles in other formats, such as Jupyter Notebook, which powers this blog). Minimal Learning Curves Going through the official documenations, user-made tutorials, or YouTube videos can be painful. Using Pelican will minimize wasting your time dealing with the learning curves. One thing that makes it very easy to learn & modify is that there already are lots blogs that run on Pelican, and their source codes are open to public. Pythonic Excursions -- source code , Aegis-Jupyter Theme by Me onCrash = 'reboot();' -- source code , Elegant Theme by Talha Mansoor Pythonic Perambulations -- source code , Adapted Octopress Theme by Jake VanderPlas ... and many more If you don't want to learn Pelican from scratch, you can download these open source repos and start from there. You will only need to learn how to tweak some settings to meet your needs. Completely Static Output Is Easy To Host Anywhere The output of Pelican is all HTML. You don't have to worry about configuring a complicated database and optimizing connections. Let's take a look at how Pelican works. Most Pelican blogs have the following directory tree. blog content articles article_1.md article_2.md article_3.md figures images ... output category images figures index.html archives.html article_1.html article_2.html article_3.html plugins themes custom_theme static templates Makefile pelicanconf.py publishconf.py output directory is the folder where Pelican stores the auto-generated HTML files, and those existing files are returned to the user who sent an HTTP request to view your website. The other directories are tools and templates used to generate the HTML files in the output folder. You do not need to configure a SQL database, or execute any codes on the server. All outputs are completely static. Can Pelican Be Used In Dynamic Websites Too? Yes, it can. Although Pelican is a static site generator, that does not mean that you can't have dynamic backend features on your website. You can pre-generate the output HTML files with Pelican, and just wrap it around with the backend framework of your choice. Let's say that you are developing a web-app with Django, and you want part of your website to be a static blog. You have a Pelican-generated output HTML file called article_1.html . In Django, you can render your Pelican-generated HTML file using a basic Class-Based-View like this: views.py from django.views.generic import TemplateView class PelicanView(TemplateView): template_name = 'article_1.html' urls.py from django.urls import re_path from your_awesome_app import views app_name = 'your_awesome_app' urlpatterns = [ re_path('&#94;$', views.PelicanView.as_view(), name='pelican'), ] And that's all it takes to integrate Pelican with Django. Part of your website can be static pages where it doesn't need to execute any code on a server, but the other part of your website can be dynamic pages where you can send queries to your server. Of course, the methodology to combine Pelican with dynamic backend will differ for each backend framework of your choice, but you get the idea. Here is the point: Pelican is a static site generator, but that does not mean that Pelican can't be used in dynamic websites. And Pelican is GREAT for blogging. Introducing Aegis-Jupyter Theme Aegis-Jupyter theme is a custom Pelican theme I made to easily host & maintain a Jupyter Notebook powered data science blog. I borrowed some CSS design of the articles from Jake VanderPlas , and improved the rendering of Jupyter Notebook files by adding custom CSS & JS codes. Every articles you see in archives page is rendered using Jupyter Notebook .ipynb files, even this very article you are reading right now! There are several reason's you why you might wanna consider using Aegis-Jupyter theme. Jupyter-Notebook-Based Articles First and foremost, your articles are be rendered by Jupyter Notebook. The question of \"Why would you want to use Aegis-Jupyter theme?\" is synonymous to \"Why would you want to use Jupyter Notebook?\" - it allows you to create and share documents that contain live code, equations, visualizations and narrative text. You don't have to go through the hassel of writing Python input codes in HTML, save the output visualizations in jpg or png files, and then render it on a browser using an image tag like this: &ltimg src=\"your_awesome_visualization.png\"> No, don't do this. This is bad. You don't want to be keep doing this for every single output of your code block. This is too much work. Simply write codes in Jupyter, save it, and render your article. Aegis-Jupyter theme was built for that purpose. Mobile Device Friendly The theme renders very nicely on all resolutions, screenwidth, and mobile devices. Try viewing this website on your phone. If you are on PC, try stretching & collapsing the browser size and see how it responsively re-aligns itself. Google Analytics Support If you own any kind of website, not just a data science blog, at some point in your life you would be wondering about the behaviors of the viewers. How many people visit my website every week? How many of them are unique visitors? From what region do I get the most number of visitors? On average, how many minutes do people stay on my website? Which post was the most popular? From what social media platform do I get the most number of visitors from? These kinds of questions can be answered by leveraging the power of Google Analytics, FOR FREE . All you need to do is to create a Google Analytics account, get a tracking ID, and put that on publishconf.py file. For example, if your Google Analytics tracking ID is UA-1XXXXXXXX-1 , then you set GOOGLE_ANALYTICS variable liks this: publishconf.py GOOGLE_ANALYTICS = \"UA-1XXXXXXXX-1\" That's it. Aegis-Jupyter theme will take care of the rest. More detailed tutorials on how to create Google Analytics account and tracking ID will come later. Easy to Manage Your Articles Meta properties of your article can easily be managed my changing attributes in markdown files. The below markdown is the actual .md file that renders this article . non-parametric-confidence-interval-with-bootstrap.md Title: Non-Parametric Confidence Interval with Bootstrap Tags: non-parametric, confidence-interval, bootstrap(stats), statistics Date: 2019-01-04 09:00 Slug: non-parametric-confidence-interval-with-bootstrap Subtitle: Keywords: Featured_Image: images/featured_images/bootstrap.png Social_Media_Description: Bootstrapping can calculate uncertainty in any confidence interval of any kind of distribution. It's great because it is distribution-free. Summary: {% notebook downloads/notebooks/Non-ParametricConfidenceIntervalswithBootstrap.ipynb cells[1:2] %} {% notebook downloads/notebooks/Non-ParametricConfidenceIntervalswithBootstrap.ipynb cells[:] %} The below screenshot is the preview of the article on the landing page of this blog. Observe how each attribute in the markdown file is used to render the output preview page. You can declare additional attributes as much as you want. Share Your Posts on Social Media Aegis-Jupyter theme leverages the power of Open Graph Meta Tags and renders the preview of your website nicely when shared on social media. You can set a preview image by declaring Featured_Image and set preview descriptions by declaring Social_Media_Description for each article in its respective markdown files. If you do not specify Featured_Image attribute in the markdown file, a default featured image will show up when shared on social media. Default featured image can be set up in pelicanconf.py file. This is what I have for my blog: pelicanconf.py FEATURED_IMAGE = SITEURL + '/theme/img/logo_icon_background.png' Search Box Most static websites do not support search box functionality out of the box. However, Pelican supports Tipue Search , a jQuery site search plugin. Talha Mansoor made a pelican plugin that allows Pelican to leverage the power of Tipue Search, and Aegis-Jupyter integrated it to work with articles written in Jupyter Notebook. Take a look at it with your own eyes by scrolling up and actually using the search box in this blog! Disqus Comment Box Being able to communicate with the audiences is a quintessential component of a blog. Create an account in Disqus and get your Disqus Website Name here . Then, declare DISQUS_SITENAME variable in publishconf.py . That's all it takes to have a comment box feature for your blog. Aegis-Jupyter will handle the rest. And, of course, IT'S FREE publishconf.py DISQUS_SITENAME = \"pythonic-excursions\" In [ ]:","tags":"WebDev","url":"https://aegis4048.github.io/creating-a-jupyternotebook-powered-data-science-blog-with-pelican","loc":"https://aegis4048.github.io/creating-a-jupyternotebook-powered-data-science-blog-with-pelican"},{"title":"Non-Parametric Confidence Interval with Bootstrap","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Bootstrap , and Boostrap Excel numerical demo on his Github repo to help yourself better understand the statistical theories and concepts. Bootstrap is a non-parametric statistical technique to resample from known samples to estimate uncertainty in summary statistics. When there are small, limited number of samples, it gives a more accurate forecast model than directly obtaining a forecast model from the limited sample pool (assuming that the sample set of data is reasonable representation of the population). It is non-parametric because it does not require any prior knowledge of the distribution (shape, mean, standard devation, etc..). Advantages of Bootstrap One great thing about Bootstrapping is that it is distribution-free . You do not need to know distribution shape, mean, standard devation, skewness, kurtosis, etc... All you need is just a set of sample data that is representative of a population. The fact that Bootstrapping does not depend on a type of distribution leads to another great advantage - It can calculate uncertainty in any confidence interval of any kind of distribution . For example, the analytical solution to calculate a confidence interval in any statistics of a distribution is as follows: CI of mean = stats of interest $\\pm$ $($distribution score $\\times$ Standard Error $)$ There are three problems with analytically solving for confidence interval of a statistic. First, the variable in the equation, distribution score , depends on the type of the distribution. If you do not know the distribution shape of your population, it is very difficult to calculate the confidence interval of a statistic. Second, not all statistics have a formula to calculate its Standard Error . For example, there exists an equation to calculate the standard error of a mean: Standard Error = $\\sigma_{sample} \\ \\mathbin{/} \\ \\sqrt{N}$ But there is no equation to calculate the standard error of a median. If you want to obtain confidence intervals for other statistics (ex: skewness, kurtosis, IQR, etc...), it will be very difficult to do so, simply because there are no equations for them. Third, some statistics have analytical solutions for its standard error calculation, but it is so convoluted that Bootstrapping is simpler. A classic example is obtaining a CI for the correlation coefficient given a sample from a bivariate normal distribution. Bootstrapping calculates confidence intervals for summary statistics numerically, not analytically , and this is why it can calculate ANY summary stats for ANY distribution. Methodology One goal of inferential statistics is to determine the value of a parameter of an entire population. It is typically too expensive or even impossible to measure this directly. So we use statistical sampling. We sample a population, measure a statistic of this sample, and then use this statistic to say something about the corresponding parameter of the population. Bootstrapping is a type of resampling method to save time and money taking measurements. From a sample pool of size N, it picks a random value N times with replacement , and create M number of new Bootstrapped-sample pools. The term with replacement here means that you put back the sample you drew to the original sample pool after adding it to a new Bootstrapped-sample pool. Think of it this way: you randomly choose a file from a folder in your PC, and you copy and paste the randomly-chosen file into a new folder. You do not cut and paste the file, but you copy and paste the file into a new folder. You will have M number of folders (M is an arbitrary number of your choice), each containing N number of files. Bootstrapping resamples the original sample pool to generate multiple smaller population of the true population. Each Bootstrap simulation is done by selecting a random value from the sample pool. For example, lets assume that you have the following sample pool of integers: Sample Integers = [12, 433, 533, 14, 65, 42, 64] From the sample pool of size N=7, you choose a random value N=7 times, and create a new sample pool of size N=7. In Bootstrap, each newly created sample pool is called a realization . You generate many of these realizations, and use them to calculate uncertainties in summary stats. Realization 1 = [12, 533, 533, 533, 12, 14, 42] Realization 2 = [65, 14, 14, 65, 433, 64, 14] Realization 3 = [433, 64, 533, 14, 14, 64, 12] Realization 4 = [14, 65, 65, 433, 533, 42, 12] Notice the duplicate data in the realizations (Ex: 533, 533, 533). Duplicates in realizations exist because each data in realization is randomly chosen from the original sample pool with replacement . Warning! It is extremly important that the N size for each Bootstrap realization matches the N size of the original sample pool. We use Bootstrap to numerically estimate the confidence interval (CI). It's an alternative tool to analytically solve for CI. Observing how CI is analytically calculated may help one to understand why the value of N is important. Let's take the CI of a mean for example. Recall that the CI of a mean represents how far a sample mean can deviate from the true population mean. In case of a Gaussian, or Gaussian-like distribution (ex: student-t), the equation to analytically solve for confidence interval of a mean is as follows: CI of mean = sample mean $\\pm$ $($z-score $\\times$ Standard Error $)$ Standard Error = $\\sigma_{sample} \\ \\mathbin{/} \\ \\sqrt{N}$ where $N$ is the number of measured samples. If you increase the number of samples, the standard error of a mean decreases. This logically makes sense, because the more samples you have, the more accurate the estimation of the true population mean becomes. The size of each Bootstrap realization, N, works the similar way, except that the random sample in each realization is not from the true population, but from a measured sample pool. Increasing the N-value will falsely make you to calculate smaller confidence interval. It can be observed that the CI obtained by using a wrong N-value for Bootstrap generates narrower CI. As a result, the CI of the sample mean does not cover the true population mean, returning a misleading estimation. In summary, Bootstrapping is used for three reasons: Bootstrap can obtain confidence interval in any statistics. Bootstrap does not assume anything about a distribution. Bootstrap helps when there are too few number of samples. Imports In [2]: import pandas as pd import numpy as np import scipy.stats import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec % matplotlib notebook 1.A. Confidence Intervals in Summary Stats: US Male Height - Gaussian Distribution Bootstrap simulation can be run to obtain confidence intervals in various population parameters: mean, stdev, variance, min, or max. In this example, we will work with the height distribution of the US Male population, which tends to be Gaussian. However, the fact that the distribution Gaussian is totally unrelated to Bootstrap simulation, because it does not assume anything about the distribution. Bootstrapping can give us confidence intervals in any summary statistics like the following: By 95% chance, the following statistics will fall within the range of: Mean : 75.2 ~ 86.2, with 80.0 being the average Standard Deviation : 2.3 ~ 3.4 with 2.9 being the average Min : 54.3 ~ 57.2, with 55.2 being the average Max : 77.8 ~ 82.4, with 79.8 being the average Skew : -0.053 ~ 0.323, with 0.023 being the average 1.A.0. Bootstrap Scripts Bootstrap Simulator In [3]: def bootstrap_simulation ( sample_data , num_realizations ): n = sample_data . shape [ 0 ] boot = [] for i in range ( num_realizations ): real = np . random . choice ( sample_data . values . flatten (), size = n ) boot . append ( real ) columns = [ 'Real ' + str ( i + 1 ) for i in range ( num_realizations )] return pd . DataFrame ( boot , index = columns ) . T Summary Statistics Calculator In [4]: def calc_sum_stats ( boot_df ): sum_stats = boot_df . describe () . T [[ 'mean' , 'std' , 'min' , 'max' ]] sum_stats [ 'median' ] = boot_df . median () sum_stats [ 'skew' ] = boot_df . skew () sum_stats [ 'kurtosis' ] = boot_df . kurtosis () sum_stats [ 'IQR' ] = boot_df . quantile ( 0.75 ) - boot_df . quantile ( 0.25 ) return sum_stats . T Visualization Script In [5]: def visualize_distribution ( dataframe , ax_ ): dataframe = dataframe . apply ( lambda x : x . sort_values () . values ) for col , label in zip ( dataframe , dataframe . columns ): fit = scipy . stats . norm . pdf ( dataframe [ col ], np . mean ( dataframe [ col ]), np . std ( dataframe [ col ])) ax_ . plot ( dataframe [ col ], fit ) ax_ . set_ylabel ( 'Probability' ) Generate Confidence Intervals In [6]: def calc_bounds ( conf_level ): assert ( conf_level < 1 ), \"Confidence level must be smaller than 1\" margin = ( 1 - conf_level ) / 2 upper = conf_level + margin lower = margin return margin , upper , lower def calc_confidence_interval ( df_sum_stats , conf_level ): margin , upper , lower = calc_bounds ( conf_level ) conf_int_df = df_sum_stats . T . describe ( percentiles = [ lower , 0.5 , upper ]) . iloc [ 4 : 7 , :] . T conf_int_df . columns = [ 'P' + str ( round ( lower * 100 , 1 )), 'P50' , 'P' + str ( round ( upper * 100 , 1 ))] return conf_int_df def print_confidence_interval ( conf_df , conf_level ): print ( 'By {}% c hance, the following statistics will fall within the range of: \\n ' . format ( round ( conf_level * 100 , 1 ))) margin , upper , lower = calc_bounds ( conf_level ) upper_str = 'P' + str ( round ( upper * 100 , 1 )) lower_str = 'P' + str ( round ( lower * 100 , 1 )) for stat in conf_df . T . columns : lower_bound = round ( conf_df [ lower_str ] . T [ stat ], 1 ) upper_bound = round ( conf_df [ upper_str ] . T [ stat ], 1 ) mean = round ( conf_df [ 'P50' ] . T [ stat ], 1 ) print ( \" {0:<10} : {1:>10} ~ {2:>10} , AVG = {3:>5} \" . format ( stat , lower_bound , upper_bound , mean )) 1.A.1 Sample Data Description 100 samples of US male height data is provided in my Github Repo - sample_data/US_Male_Height.csv . Summary statistics of the sample data can be calculated. Your goal is to calculate the confidence intervals for the summary stats. In [7]: # height data height_data = pd . read_csv ( 'sample_data/US_Male_Height.csv' ) height_data . index = [ 'Male ' + str ( i + 1 ) for i in range ( height_data . shape [ 0 ])] height_data . round ( 1 ) . T Out[7]: Male 1 Male 2 Male 3 Male 4 Male 5 Male 6 Male 7 Male 8 Male 9 Male 10 ... Male 91 Male 92 Male 93 Male 94 Male 95 Male 96 Male 97 Male 98 Male 99 Male 100 Height (in) 70.8 72.8 72.5 67.3 72.7 73.6 65.0 67.1 70.8 70.6 ... 71.7 66.4 72.9 74.5 73.5 70.5 73.1 63.6 68.7 73.0 1 rows × 100 columns In [8]: height_summary_stats = calc_sum_stats ( height_data ) height_summary_stats Out[8]: Height (in) mean 69.881971 std 3.169548 min 63.143732 max 77.762886 median 69.894434 skew -0.059779 kurtosis -0.700743 IQR 5.154145 Visualization In [9]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Height (inches)' ); fig . suptitle ( 'Original Sample Data Distribution: Gaussian Distribution' ) visualize_distribution ( height_data , ax ); Based on the distribution plot of the original sample data, we can observe that the distribution indeed looks Gaussian. However, the fact that it looks like Gaussian does not matter at all when Bootstrapping, because Bootstrapping does not assume anything about the distribution. 1.A.2 Resampling From the Sample Data Each Bootstrap resampling (realization) can be done in one-line with numpy.random.choice() . Each realization is an array of size N, where N is the length of the original sample data. There are M number of realizations, where M is an arbitrary number of your choice. Results In [10]: M = 100 # number of realizations - arbitrary bootstrap_data = bootstrap_simulation ( height_data , M ) bootstrap_data . round ( 1 ) . head ( 10 ) Out[10]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 0 72.7 67.9 65.0 69.2 70.4 64.9 70.3 66.3 67.6 72.2 ... 74.1 66.3 73.0 68.5 65.3 72.5 72.7 69.2 66.4 72.3 1 68.4 70.5 65.3 64.5 71.8 69.2 70.5 71.6 65.3 67.9 ... 72.5 68.6 66.1 71.7 67.3 74.1 67.9 71.3 72.9 65.0 2 71.3 74.1 72.8 72.9 68.3 67.9 73.1 65.0 73.6 72.8 ... 69.5 72.5 72.5 73.3 69.2 74.1 73.0 65.5 67.9 63.1 3 72.5 73.0 71.4 68.5 73.3 70.5 70.5 70.6 68.5 69.0 ... 64.5 69.2 66.0 69.5 72.5 70.3 67.9 68.3 73.6 73.5 4 67.2 73.5 73.6 67.2 64.5 72.9 72.8 66.4 69.2 66.8 ... 66.3 73.6 71.3 73.1 71.6 72.2 64.9 69.0 71.7 70.2 5 69.1 66.0 65.5 69.1 71.7 70.6 66.0 73.0 72.2 69.9 ... 73.0 66.3 69.0 67.9 69.4 69.9 69.5 68.7 72.4 67.3 6 72.2 68.5 72.9 63.1 73.6 73.1 70.8 75.5 69.9 70.6 ... 68.4 65.0 68.5 68.8 67.2 72.2 65.5 70.6 72.2 66.8 7 73.1 72.5 69.0 72.5 71.6 68.7 73.5 66.2 71.6 74.4 ... 73.6 68.5 72.2 73.1 72.3 72.1 66.8 77.8 72.8 69.5 8 67.3 69.5 74.5 66.8 69.1 65.0 69.9 70.6 65.0 73.1 ... 67.1 72.8 70.5 70.8 73.6 72.5 71.8 67.9 67.2 70.6 9 66.3 72.9 65.5 72.5 72.4 70.6 73.1 69.5 67.2 68.7 ... 71.6 69.2 65.0 71.3 71.4 69.1 73.3 70.2 66.1 67.6 10 rows × 100 columns In [11]: boot_sum_stats = calc_sum_stats ( bootstrap_data ) boot_sum_stats . round ( 1 ) Out[11]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 mean 69.4 70.0 69.9 70.1 70.0 69.5 70.2 70.2 69.7 70.5 ... 69.7 69.9 69.7 69.9 70.1 70.0 70.0 69.5 70.1 69.4 std 3.1 3.1 3.2 3.3 3.3 3.1 3.1 3.2 2.9 3.0 ... 3.1 3.3 2.8 3.0 3.2 2.8 3.2 3.2 3.2 3.3 min 63.1 63.6 64.1 63.1 63.1 63.1 63.1 63.1 63.6 63.1 ... 63.1 63.1 63.1 63.6 63.6 64.5 64.1 63.1 63.1 63.1 max 75.5 77.8 76.1 77.8 76.1 76.1 76.1 77.8 77.8 77.8 ... 75.5 77.8 77.8 75.5 77.8 76.1 77.8 77.8 77.8 76.1 median 69.1 70.3 70.5 70.4 70.9 69.2 70.5 70.6 69.5 70.7 ... 69.9 69.5 69.5 69.9 69.9 69.9 70.4 69.2 70.6 69.1 skew -0.1 -0.0 -0.2 -0.0 -0.4 -0.0 -0.3 -0.3 0.2 -0.2 ... -0.4 -0.0 -0.0 -0.3 -0.1 0.1 0.2 -0.1 -0.2 -0.0 kurtosis -1.1 -0.8 -1.1 -0.4 -0.9 -0.7 -0.9 -0.6 -0.4 -0.5 ... -0.9 -0.7 -0.3 -0.9 -0.8 -0.9 -0.6 -0.7 -0.8 -1.0 IQR 5.4 5.2 5.9 4.2 5.2 4.9 5.5 5.0 4.9 4.2 ... 5.2 5.4 4.9 4.7 4.8 4.4 5.1 4.8 5.3 5.7 8 rows × 100 columns Visualize In [13]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Height (inches)' ); fig . suptitle ( 'Distribution of Bootstrap-Simulated Data: Gaussian' ) visualize_distribution ( bootstrap_data , ax ); Each line in the plot represents one Bootstrap realization. There are 100 realizations, each having 100 random samples. 1.A.3 Uncertainty Models in Summary Statistics with Blox Plots In [16]: f = plt . figure () plt . suptitle ( 'Uncertainty Models for Various Statistics: US Male Height - Gaussian' ) gs = gridspec . GridSpec ( 2 , 4 ) ax1 = plt . subplot ( gs [ 0 , 0 : 4 ]) ax2 = plt . subplot ( gs [ 1 , 0 ]) ax3 = plt . subplot ( gs [ 1 , 1 ]) ax4 = plt . subplot ( gs [ 1 , 2 ]) ax5 = plt . subplot ( gs [ 1 , 3 ]) boot_sum_stats . T [[ 'mean' , 'min' , 'max' , 'median' ]] . boxplot ( ax = ax1 ) boot_sum_stats . T [[ 'std' ]] . boxplot ( ax = ax2 ) boot_sum_stats . T [[ 'IQR' ]] . boxplot ( ax = ax3 ) boot_sum_stats . T [[ 'skew' ]] . boxplot ( ax = ax4 ) boot_sum_stats . T [[ 'kurtosis' ]] . boxplot ( ax = ax5 ) ax5 . set_ylim ([ - 3 , 3 ]); 1.A.4 Confidence Interval in Summary Statistics Confidence intervals of summary statistics usually have a confidence level of 90%, 95%, or 99%. In this case, we will choose 95% confidence level . In [17]: confidence_level = 0.95 conf_int = calc_confidence_interval ( boot_sum_stats , confidence_level ) conf_int . round ( 1 ) Out[17]: P2.5 P50 P97.5 mean 69.4 69.9 70.5 std 2.8 3.2 3.4 min 63.1 63.1 64.5 max 75.4 77.8 77.8 median 69.1 70.0 71.1 skew -0.5 -0.1 0.3 kurtosis -1.1 -0.7 -0.1 IQR 4.0 4.9 5.8 In [18]: print_confidence_interval ( conf_int , confidence_level ) By 95.0% chance, the following statistics will fall within the range of: mean : 69.4 ~ 70.5 , AVG = 69.9 std : 2.8 ~ 3.4 , AVG = 3.2 min : 63.1 ~ 64.5 , AVG = 63.1 max : 75.4 ~ 77.8 , AVG = 77.8 median : 69.1 ~ 71.1 , AVG = 70.0 skew : -0.5 ~ 0.3 , AVG = -0.1 kurtosis : -1.1 ~ -0.1 , AVG = -0.7 IQR : 4.0 ~ 5.8 , AVG = 4.9 1.B. Confidence Intervals in Summary Stats: Rock Permeability - Lognormal Distribution It was previously stated that Bootstrapping does not assume anything about the distribution. Is that really true? The previous example of the US Male Height distribution was a Gaussian distribution. But what if the distribution of our interest is not Gaussian? In this example, rock pearmeability, which has a lognormal distribution , will be used to show that Bootstrap does not depend on the type of the distribution. 1.B.0. Bootstrap Scripts The sample scripts used for US Male Height example will be used for Bootstrap simulation. Same scripts can be used for both Gaussian and lognormal distribution because Bootstrapping does not assume anything about the distribution. 1.B.1. Sample Data Description 105 samples of permeability data is provided in Github Repo - sample_data/PoroPermSampleData.xlsx . Permeability data is taken at many times at different depth of a wellbore. Summary statistics of the sample data can be calculated. Your goal is to calculate the confidence intervals for the summary stats. In [19]: # permeability data perm_depth_data = pd . read_excel ( 'sample_data/PoroPermSampleData.xlsx' , sheet_name = 'Sheet1' )[[ 'Depth' , 'Permeability (mD)' ]] perm_data = perm_depth_data [ 'Permeability (mD)' ] . to_frame () # visualize fig = plt . figure () ax = plt . axes () ax . plot ( perm_depth_data [ 'Permeability (mD)' ], perm_depth_data [ 'Depth' ]); ax . invert_yaxis () ax . set_title ( 'Permeability Along A Wellbore' ) ax . set_xlabel ( 'Permeability (mD)' ) ax . set_ylabel ( 'Depth (ft)' ); In [20]: perm_summary_stats = calc_sum_stats ( perm_data ) perm_summary_stats Out[20]: Permeability (mD) mean 161.008972 std 80.900128 min 43.534147 max 573.461883 median 144.329837 skew 1.625086 kurtosis 5.498080 IQR 102.580432 Visualization In [21]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Permeability (mD)' ) fig . suptitle ( 'Original Sample Data Distribution: Lognormal Distribution' ) visualize_distribution ( perm_data , ax ); Based on the distribution of the original sample data, we can observe that the distribution looks lognormal. The uncertainty in summary statistics can be calculated using Bootstrap the same way it was done for the US Male Height (Gaussian) distribution, because Bootstrap does not depend on the shape of the distribution. Warning! Outlier removal on rock permeability cannot be done directly, as this is a lognormal distribution. Recall that the typical outlier removal method assumes the distribution to be Gaussian. If you want to detect outliers for non-Gaussian distributions, you have to first transform the distribution into Gaussian. 1.B.2 Resampling From the Sample Data Each Bootstrap resampling (realization) can be done in one-line with numpy.random.choice() . Each realization is an array of size N, where N is the length of the original sample data. There are M number of realizations, where M is an arbitrary number of your choice. Results In [22]: M = 100 # number of realizations - arbitrary boot_perm_data = bootstrap_simulation ( perm_data , M ) boot_perm_data . round ( 1 ) . head ( 10 ) Out[22]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 0 61.9 258.6 138.8 61.9 285.3 156.1 179.7 125.9 58.8 89.6 ... 151.0 227.4 59.1 573.5 258.6 56.3 240.6 89.6 132.7 182.6 1 170.5 61.0 143.7 214.1 264.2 244.1 144.7 160.5 83.9 258.6 ... 58.8 279.8 244.1 92.1 213.7 160.5 240.6 146.0 141.8 138.8 2 143.7 86.8 117.6 92.7 83.9 104.0 187.9 138.8 162.3 132.1 ... 258.4 380.1 89.6 89.6 123.3 77.5 102.7 193.1 133.2 234.5 3 166.9 151.0 240.6 265.5 183.1 65.6 59.1 305.1 103.5 131.6 ... 214.9 128.9 210.8 108.6 193.1 125.9 77.5 151.5 112.3 58.8 4 161.0 146.0 89.6 84.9 129.1 43.5 170.5 97.7 190.9 197.8 ... 56.3 85.0 53.4 79.4 58.8 92.7 102.7 190.9 126.3 161.0 5 104.0 132.1 129.1 144.4 184.8 263.5 151.0 170.5 162.9 311.6 ... 61.0 156.1 170.5 264.2 244.1 85.0 112.3 117.6 224.4 265.5 6 305.1 77.5 213.7 84.9 240.6 58.8 224.4 234.5 128.9 193.1 ... 66.9 138.8 240.6 66.9 166.9 84.7 305.1 80.4 53.4 264.2 7 286.8 171.4 92.1 84.9 116.9 245.7 141.8 135.8 206.6 116.9 ... 162.3 244.1 187.9 151.0 84.9 85.0 573.5 170.5 83.3 117.6 8 142.7 187.9 131.6 117.6 244.1 214.1 182.6 134.7 132.7 132.7 ... 123.3 104.0 65.6 86.8 84.9 193.1 56.3 136.9 156.1 311.6 9 58.8 132.1 380.1 136.9 65.6 244.1 134.7 77.8 321.1 79.4 ... 128.9 83.9 182.6 132.0 117.6 234.5 227.4 187.9 80.4 138.8 10 rows × 100 columns In [23]: boot_perm_sum_stats = calc_sum_stats ( boot_perm_data ) boot_perm_sum_stats . round ( 1 ) Out[23]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 mean 159.5 152.6 146.9 155.7 160.3 161.7 161.5 164.4 146.6 162.7 ... 143.9 150.0 166.7 155.6 155.2 151.5 164.7 171.3 143.8 148.1 std 80.0 64.1 72.6 77.2 72.1 98.0 88.0 90.7 65.3 73.3 ... 78.4 68.0 64.7 78.0 68.8 74.8 106.0 96.3 63.1 62.0 min 56.3 43.5 43.5 43.5 53.4 43.5 43.5 43.5 43.5 43.5 ... 43.5 43.5 53.4 43.5 43.5 53.4 53.4 43.5 43.5 43.5 max 573.5 305.1 380.1 573.5 380.1 573.5 573.5 573.5 321.1 321.1 ... 573.5 380.1 380.1 573.5 380.1 321.1 573.5 573.5 380.1 380.1 median 143.7 138.8 132.1 144.4 138.8 143.7 142.7 138.8 136.9 145.6 ... 132.0 133.2 151.0 141.8 138.8 133.2 133.2 144.7 132.7 138.8 skew 1.8 0.6 1.1 1.7 0.7 1.6 2.2 2.0 0.6 0.4 ... 2.1 0.8 0.6 1.8 0.7 0.6 1.9 2.2 0.9 0.8 kurtosis 6.1 -0.5 1.0 6.9 -0.3 4.3 7.7 6.4 -0.2 -0.9 ... 8.1 0.5 0.3 6.7 0.2 -0.7 4.6 7.0 1.0 1.1 IQR 79.3 80.8 92.7 113.0 102.4 129.2 102.4 86.7 95.2 114.0 ... 77.3 98.2 78.7 102.6 86.7 112.7 132.3 79.2 82.1 80.8 8 rows × 100 columns Visualize In [29]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) fig . suptitle ( 'Distribution of Bootstrap-Simulated Data: Lognormal' ) ax . set_xlabel ( 'Permeability (mD)' ) visualize_distribution ( boot_perm_data , ax ); 1.B.3 Uncertainty Models in Summary Statistics with Blox Plots In [25]: f = plt . figure () plt . suptitle ( 'Uncertainty Models for Various Statistics: Rock Permeability - Lognormal' ) gs = gridspec . GridSpec ( 2 , 4 ) ax1 = plt . subplot ( gs [ 0 , 0 : 4 ]) ax2 = plt . subplot ( gs [ 1 , 0 ]) ax3 = plt . subplot ( gs [ 1 , 1 ]) ax4 = plt . subplot ( gs [ 1 , 2 ]) ax5 = plt . subplot ( gs [ 1 , 3 ]) boot_perm_sum_stats . T [[ 'mean' , 'min' , 'max' , 'median' ]] . boxplot ( ax = ax1 ) boot_perm_sum_stats . T [[ 'std' ]] . boxplot ( ax = ax2 ) boot_perm_sum_stats . T [[ 'IQR' ]] . boxplot ( ax = ax3 ) boot_perm_sum_stats . T [[ 'skew' ]] . boxplot ( ax = ax4 ) boot_perm_sum_stats . T [[ 'kurtosis' ]] . boxplot ( ax = ax5 ) ax4 . set_ylim ([ - 3 , 3 ]) ax5 . set_ylim ([ - 10 , 10 ]); Observe the positive skewness in the boxplot summary statistics. This is consistent with the left-justified lognormal distribution of the permeability plot. 1.B.4 Confidence Interval in Summary Statistics Confidence intervals of summary statistics usually have a confidence level of 90%, 95%, or 99%. In this case, we will choose 90% confidence level . In [26]: confidence_level = 0.9 conf_int_perm = calc_confidence_interval ( boot_perm_sum_stats , confidence_level ) conf_int_perm . round ( 1 ) Out[26]: P5.0 P50 P95.0 mean 146.1 160.0 171.3 std 64.4 77.4 96.4 min 43.5 43.5 54.3 max 321.1 573.5 573.5 median 132.7 144.3 156.1 skew 0.4 1.4 2.2 kurtosis -0.6 4.0 8.6 IQR 78.4 98.1 120.9 In [27]: print_confidence_interval ( conf_int_perm , confidence_level ) By 90.0% chance, the following statistics will fall within the range of: mean : 146.1 ~ 171.3 , AVG = 160.0 std : 64.4 ~ 96.4 , AVG = 77.4 min : 43.5 ~ 54.3 , AVG = 43.5 max : 321.1 ~ 573.5 , AVG = 573.5 median : 132.7 ~ 156.1 , AVG = 144.3 skew : 0.4 ~ 2.2 , AVG = 1.4 kurtosis : -0.6 ~ 8.6 , AVG = 4.0 IQR : 78.4 ~ 120.9 , AVG = 98.1","tags":"Statistics","url":"https://aegis4048.github.io/non-parametric-confidence-interval-with-bootstrap","loc":"https://aegis4048.github.io/non-parametric-confidence-interval-with-bootstrap"},{"title":"Uncertainty Modeling with Monte-Carlo Simulation","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Monte-Carlo Simulation to help yourself better understand the statistical theories and concepts. Monte Carlo Simulation is a random sampling method to model uncertainty of a population estimation. When given only population parameters (mean, standard deviation, degrees of freedom, etc..), but not the sample data itself, it generates random samples based on the distribution parameters to create a sample pool that is representative of the true population. Uncertainty models can be created from the newly generated sample pool. Based on historical data, expertise in the field, or past experience, you might know the typical values of population mean, standard deviation and degrees of freedom. While these parameters are useful for developing a model, they do not tell you the uncertainties in a population. In a financial market, you might know the distribution of possible values through the mean and standard deviation of returns. By using a range of possible values, instead of a single guess, you can create a more realistic picture of what might happen in the future. Let's assume that your consultant recommended you a certain investment program that has a mean return rate of 10% and a standard deviation of 1% However, You do not have an access to the actual sample data that is used to obtain the mean, and standard deviation . You made 100 investments through this program, but your 100 investments had an average rate of return of 3%. Did the consultant lie to you, or is it one of the possible corner cases that you can have if you are unlucky? What is the P10, P50, P90 value of this investment program? What are the the most plausible range of rate of return? Does your 3% rate of return fall within that range ? In order to answer these questions, you need sample data that is representative of the population. Monte-Carlo simulation takes population parameters as arguments, and generates series of random samples to investigate a range of possible outcomes . Methodology Monte-Carlo simulation is one of the random sampling method that generates a new set of random samples from statistic parameters of a population. It assumes a certain distribution shape, and population parameters as input and returns a random sample based on the distribution shape and parameters. The most simple examples are as follows: Excel Gaussian: NORM.INV(RAND(), mean, stdev) Lognormal: LOGNORM.INV(RAND(), mean, stdev) Chi-Square: CHISQ.INV(RAND(), degree_freedom) F-distribution: F_INV(RAND(), degree_freedom_numerator, degree_freedom_denominator) Python Gaussian: np.random.normal(mean, stdev) Lognormal: np.random.lognormal(mean, stdev) Chi-Square: np.random.chisquare(degree_freedom) F-distribution: np.random.f(degree_freedom_numerator, degree_freedom_denominator) These examples are the most simple cases of generating random samples vis Monte-Carlo simulation. Random samples can be generated as many times as desired. Based on the N-number of random samples generated, you can draw a CDF or boxplot to model uncertainty in prediction. Warning! In order to use Monte-Carlo simulation, you must know the distribution shape (normal, lognormal, chi-square, etc..) and distribution parameters (mean, standard deviation, degrees of freedom, etc..) of the data. If you do not have enough samples to draw an uncertainty model, or do not know the distribution shape and parameters, Bootstrap simulation may address your issue. Random samples of interest can can be created via an applied form of Monte-Carlo simulation. For example, the Casino Dice Roll Example simulates a game 1,000 times for a single player, and calculates a player's final fund at the end. The final fund of a single player is one random Monte-Carlo sample. The process is repeated 100 times to account for 100 players' final fund, and now we have 100 random Monte-Carlo samples. Total Thickness of Two Formations Example generates two sets of Monte-Carlo formation samples N times (where N is arbitrary number of your choice) to account for Formation A, and Formation B. The two sets of Monte-Carlo formation data are then added together to obtain Monte-Carlo data for total thickness. 1. Casino Dice Roll Example How do casinos earn money? The answer is simple - the longer you play, the bigger the chance of you losing money. Let's assume an imaginary dice roll game between a casino house and a player. The rules are simple. Dice Roll Game Rules There is an imaginary dice that rolls between 1 to 100. If a player rolls between 1 to 51, the house wins. If a player rolls between 52 to 100, the player wins. A player can bet as many times as he wants. With the above rules, the house has 2% higher chance of winning over a player . As a financial analyst of the house, upper management wants you to create a Dice Roll game profit forecast model. Question : If a certain game is configured so that the house has 2% higher chance of winning over a player , what is the expected profit forecast model for the game? Monte-Carlo simulation can be used to simulate the possible outcomes of dice roll game, and generate a forecast model. 1.0 Game Simulator Scripts Imports In [2]: import random import scipy import matplotlib.pyplot as plt import pandas as pd import numpy as np % matplotlib notebook Dice Roll Simulation In [3]: def rolldice (): dice = random . randint ( 1 , 100 ) if dice <= 51 : # Player loses return False elif dice > 51 & dice <= 100 : # Player wins return True Single Game Simulation In [4]: def play ( total_funds , wager_amount , total_plays , final_fund ): play_num = [] # x-axis of the plot funds = [] # y-axis of the plot play = 1 while play <= total_plays : if rolldice (): # Player wins total_funds = total_funds + wager_amount # updates current total funds play_num . append ( play ) funds . append ( total_funds ) else : # Player loses total_funds = total_funds - wager_amount play_num . append ( play ) funds . append ( total_funds ) play = play + 1 final_fund . append ( funds [ - 1 ]) # final_fund contains the ending fund of all players return final_fund , play_num , funds Results Visualization In [5]: def simulate_visualize ( init_money , bet , num_bet , num_players = 1 ): # simulates and generates a plot f , ax = plt . subplots () count = 1 ending_fund_all_players = [] while count <= num_players : ending_fund_all_players , num_play , funds_record = play ( init_money , bet , num_bet , ending_fund_all_players ) ax . plot ( num_play , funds_record ) count += 1 ax . set_title ( str ( num_players ) + ' Player(s): ' + 'Change in Total Fund with Each Game' ) ax . set_ylabel ( 'Player \\' s Fund ($)' ) ax . set_xlabel ( 'Number of Bets' ) return ending_fund_all_players In [6]: def simulate ( init_money , bet , num_bet , num_players = 1 ): # simulates, but does not plot count = 1 ending_fund_all_players = [] while count <= num_players : ending_fund_all_players , num_play , funds_record = play ( init_money , bet , num_bet , ending_fund_all_players ) count += 1 return ending_fund_all_players 1.1 Monte-Carlo Simulation: 1 Player Let's say than an imaginary player, 'Eric', visits the house and wants to play the Dice Roll Game. A Monte-Carlo simulation can be run to simulate the result of Eric's game. The simulation will be run with the following conditions: Eric starts with \\$10,000 Eric bets \\$100 each time Eric plays the game 1,000 times In [148]: simulate_visualize ( init_money = 10000 , bet = 100 , num_bet = 1000 , num_players = 1 ) plt . axhline ( 10000 , color = \"red\" , linewidth = 3 ) plt . text ( 780 , 10200 , 'Starting Money $10,000' , color = 'red' ); Eric started with 10,000 dollars. To your surprise, Eric actually ended up earning money from the house by 2,500 dollars after 1,000 games . According to the configuration of the game, the house has 2% higher chance of winning over Eric. Therefore, with such a high number of games, like a thousand, the house was supposed to earn money from the player. But it was not the case here. Was the configuration of the game wrong, or was Eric just really lucky? 1.1 Monte-Carlo Simulation: 100 Players Eric earned $2,500 dollars after running 1,000 games. However, if hundred other players play the Dice Roll game for thousand times each, would the result be different? From the house's perspective, what is the expected profit from the Dice Roll game? To get more accurate estimation of the expected profit, multiple Monte-Carlo simulation will be run. In this case, hundred. The simulation will be run with the following conditions: Hundred players each start with \\$10,000 Hundred players bet \\$100 each time Hundred players play the game 1,000 times In [7]: simulate_visualize ( init_money = 10000 , bet = 100 , num_bet = 1000 , num_players = 100 ) plt . axhline ( 10000 , color = \"white\" , linewidth = 3 ) plt . text ( 100 , 10400 , 'Starting Money $10,000' , color = 'white' , weight = 'bold' ); As it can be shown on the plots, Eric's earning 2,500 dollars after 1,000 games was a plausible outcome. There was even a player who eanred ended up with 16,500 dollars, which means that he earned 6,500 dollars ! However, this does not mean that the house will earn negative profit. The plot clearly indicates overall trend in the house earning money over the players as the number of bets increases. 1.3 Uncertainty Modeling The previous simulation results represent the outcome of 100 players each playing 1,000 games . One hundred Monte-Carlo simulations were run, and now we have one hundred samples of 1,000 game simulations data. To obtain more accurate uncertainty model for the Dice Roll game, further simulations will be run for 1,000 players each playing 100, 1,000, 10,000, and 100,000 games . In [6]: df = pd . DataFrame () for num_games in [ 100 , 1000 , 5000 , 10000 ]: result = simulate ( init_money = 10000 , bet = 100 , num_bet = num_games , num_players = 1000 ) col_name = str ( num_games ) + ' Games ($)' df [ col_name ] = result In [7]: df . index . name = 'Player Number' df . head ( 10 ) Out[7]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) Player Number 0 8400 7000 5800 -15600 1 8600 8000 16000 -34800 2 9600 7600 -400 5000 3 9400 10400 -6600 -11200 4 9400 10600 -400 0 5 8600 7200 -200 -19600 6 10800 7800 5600 -14000 7 9800 12400 -4000 -6200 8 10600 7600 24600 -9400 9 7400 7400 1800 -19200 In [10]: ax = df . boxplot ( grid = False ) ax . set_title ( 'Uncertainty Model for Dice Roll Game Profit: 1000 Players' ) ax . set_ylabel ( 'Player \\' s Fund ($)' ) ax . axhline ( 10000 , color = \"red\" , linewidth = 3 ); ax . text ( 3.5 , 11500 , 'Starting Money $10,000' , color = 'red' ); The generated box plot is the forecast model for the Dice Roll game profit generation. It tells you the most likely range of profit expected for N number of games played for each player. Based on the box plot uncertainty model, you can confirm that the longer you play, the bigger chance of you losing money. Although some lucky players may double, or even triple their money at the casino, far bigger population of the players will end up losing money to the casino. Recall that the Dice Roll game was configured so that the Casino has 2% higher chance of winning the game over a player. Summary: A player starts with 10,000 dollars and bets 100 dollar for each game. If a player plays 100 games, he will most likely end up between 12,500 to 6800 dollars If a player plays 1000 games, he will most likely end up between 15,800 to $-$360 dollars If a player plays 5,000 games, he will most likely end up between 19,200 to $-$18,900 dollars If a player plays 10,000 games, he will most likely end up between 15,200 to $-$36,000 dollars 1.4 Outlier Removal and Mean of the Prediction The uncertainty model generated by Monte-Carlo simulations gives you a range of possible outcome. But what if you want a single value of the outcome? One simple way to address this question is to just calculate the average of the simulated data. Means of simulated data BEFORE outlier removal In [192]: raw_mean = pd . DataFrame ( df . describe () . T [ 'mean' ]) . T raw_mean . rename ( index = { 'mean' : 'original mean' }, inplace = True ) raw_mean Out[192]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) original mean 9812.4 7930.8 214.0 -9865.2 But as it can be observed in the boxplot, the simulated data contains outliers (circled points). One might want to remove these outliers before calculating the average of the data to improve accuracy. The traditional IQR outlier detection method can be implemented. IQR = P75 - P25 Lower Fence = P25 - 1.5 $\\times$ IQR Upper Fence = P75 + 1.5 $\\times$ IQR In [1]: def get_outlier_params ( orig_data ): iqr_params = orig_data . describe () . T [[ '25%' , '75%' ]] iqr_params [ 'IQR' ] = iqr_params [ '75%' ] - iqr_params [ '25%' ] iqr_params [ 'Lower Fence' ] = iqr_params [ '25%' ] - 1.5 * iqr_params [ 'IQR' ] iqr_params [ 'Upper Fence' ] = iqr_params [ '75%' ] + 1.5 * iqr_params [ 'IQR' ] return iqr_params In [194]: iqr_params = get_outlier_params ( df ) iqr_params Out[194]: 25% 75% IQR Lower Fence Upper Fence 100 Games ($) 9200.0 10600.0 1400.0 7100.0 12700.0 1000 Games ($) 6000.0 10200.0 4200.0 -300.0 16500.0 5000 Games ($) -4450.0 5200.0 9650.0 -18925.0 19675.0 10000 Games ($) -16600.0 -3150.0 13450.0 -36775.0 17025.0 Means of simulated data AFTER outlier removal In [195]: def remove_outliers ( outlier_params , data ): outlier_removed_df = pd . DataFrame () for column in data . columns : outlier_removed_df [ column ] = data [ column ] . apply ( lambda x : x if x > outlier_params [ 'Lower Fence' ][ column ] else np . nan ) outlier_removed_df [ column ] = data [ column ] . apply ( lambda x : x if x < outlier_params [ 'Upper Fence' ][ column ] else np . nan ) return outlier_removed_df In [196]: new_df = remove_outliers ( iqr_params , df ) new_mean = pd . DataFrame ( new_df . describe () . round ( 1 ) . T [ 'mean' ]) . T new_mean . rename ( index = { 'mean' : 'outlier-removed mean' }, inplace = True ) pd . concat ([ raw_mean , new_mean ]) Out[196]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) original mean 9812.4 7930.8 214.0 -9865.2 outlier-removed mean 9800.2 7892.8 172.7 -9950.1 Based on the simulated mean of each players Dice Roll game result, it can be observed that a player will lose ~20,000 dollars if he plays the 10,000 games , betting 100 dollars each game. 2. Oil Field Example: Total Thickness of Two Formations Your company is about to drill into two formations: formation A and formation B . From the previous experiences within the asset, you know the the distribution of each formation's thickness (which is rarely the case...). In order to develop production / facility plans, you need to draw an uncertainty model for the total thickness of formation A + formation B . 2.0.1 Assumptions Before Monte-Carlo simulation is run to develop the uncertainty model, a few assumptions will be made. The formation thickness in the asset has Gaussian distribution Formation A has a mean value of 10 ft, and standard deviation of 2 ft. Formation B has a mean value of 24 ft, and standard deviation of 4 ft. The mean and standard deviation were calculated from large enough samples, and their values are reliable. We are not given any sample data set. We are only given mean and standard deviations. In [18]: assumptions = pd . DataFrame ( data = [[ 10 , 24 ],[ 2 , 4 ]], columns = [ 'Formation A (ft)' , 'Formation B (ft)' ], index = [ 'mean' , 'stdev' ]) assumptions Out[18]: Formation A (ft) Formation B (ft) mean 10 24 stdev 2 4 Recall that Monte-Carlo simulation requires the distribution shape and distribution parameters of the population. If we know the distribution shape, but do not have large enough samples to estimate reasonable values for the mean and the standard deviation of the population, Monte-Carlo simulation for Gaussian distribution may return inaccurate results. This can't really be helped since we just don't have enough samples. Furthurmore, if we have reasonably large enough samples, but do not know the distribution shape, Monte-Carlo simulation cannot be run . Recall that when generating random samples, it assumes a certain form of a distribution. (Ex: numpy.random.normal() , numpy.random.lognormal() , numpy.random.chiquare() ). Notes If Monte-Carlo simulation cannot be run because the distribution shape is unknown, non-parametric Bootstrap simulation can be used to generate random samples. 2.0.2 Why Use Monte-Carlo Simulation? One might ask why Monte-Carlo simulation is needed for this task. Why can't we just add the provided means of the two formations and use it for our thickness model? Total Thickness = Form. A Mean Thickness + Form. B Mean Thickness Total Thickness = 10 ft + 24 ft = 34 ft However, this simple forecast model does not give any information about the uncertainty in the total thickness of the formation. That is, we only know the overall mean thickness, but nothing about the possible range of thickness of the formations. Ideally we want to formulate something like the following: The total formation thickness will fall within the range of 27 ~ 41 ft by 80% chance, with 34 ft being the mean of the distribution. When we are given only the estimated mean and standard deviation of the population, uncertainty model cannot be formulated without some kind of random sampling method. Monte-Carlo simulation can be used to generate a pool of random samples. 2.1 Monte-Carlo Simulation for Gaussian Distribution Steps Using the provided mean and standard deviation, generate a random Gaussian distribution of Formation A and B thickness. Recall that we assumed the thickness distribution to be Gaussian. Generate random thickness values N times. Add the randomly generated thickness values for Formation A and B. Generate visualizations (CDF, boxplot, etc...) The distribution is Gaussian, and therefore np.random.normal() will be used to generate random normal distribution of formation thickness. If the distribution was assumed to be non-Gaussian, other function will be used to create random samples. For more information, check the numpy documentation of random sampling for various distributions . In [19]: mean_A = assumptions [ 'Formation A (ft)' ][ 'mean' ] mean_B = assumptions [ 'Formation B (ft)' ][ 'mean' ] std_A = assumptions [ 'Formation A (ft)' ][ 'stdev' ] std_B = assumptions [ 'Formation B (ft)' ][ 'stdev' ] iteration = 1000 monte_A = np . random . normal ( mean_A , std_A , iteration ) monte_B = np . random . normal ( mean_B , std_B , iteration ) total_thic = monte_A + monte_B df_thic = pd . DataFrame ([ monte_A , monte_B , total_thic ], index = [ 'Formation A (ft)' , 'Formation B (ft)' , 'Total Thickness (ft)' ]) . T df_thic . index . name = 'Iteration' df_thic . round ( 1 ) . head ( 10 ) Out[19]: Formation A (ft) Formation B (ft) Total Thickness (ft) Iteration 0 7.3 29.4 36.6 1 9.4 28.7 38.1 2 7.7 18.5 26.1 3 11.0 33.1 44.1 4 8.1 21.8 29.9 5 10.0 23.2 33.2 6 10.2 26.5 36.7 7 10.8 25.5 36.3 8 10.8 22.7 33.4 9 10.1 23.1 33.3 Visualizations Cumulative probablity function (CDF) and boxplot can be used to visualize the simulation result. In [33]: def visualize_distribution ( dataframe , ax_ ): dataframe = dataframe . apply ( lambda x : x . sort_values () . values ) for col , label in zip ( dataframe , dataframe . columns ): fit = scipy . stats . norm . pdf ( dataframe [ col ], np . mean ( dataframe [ col ]), np . std ( dataframe [ col ])) ax_ . plot ( dataframe [ col ], fit ) ax_ . set_ylabel ( 'Probability' ) In [34]: fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) fig . suptitle ( 'Uncertainty Models for Total Formation Thickness' ) visualize_distribution ( df_thic [ 'Total Thickness (ft)' ] . to_frame (), ax1 ) ax1 . set_title ( 'Probability Distribution Function' ) ax1 . set_ylabel ( 'Probability' ) ax1 . set_xlabel ( 'Total Thickness (ft)' ) ax2 . boxplot ( df_thic [ 'Total Thickness (ft)' ]) ax2 . set_title ( 'Boxplot' ) ax2 . set_ylabel ( 'Total Thickness (ft)' ); ax2 . set_xticklabels ([]); Business Decision on P10, P50, and P90 Statistics Many of the business decisions are made on P10, P50, and P90 values. When reporting your statistical analysis to the management, you want to provide them the most likely range of outcome. In [36]: pd . DataFrame ( df_thic [ 'Total Thickness (ft)' ] . describe ( percentiles = [ 0.1 , 0.9 ])) . T . iloc [:, 4 : 7 ] . round ( 1 ) Out[36]: 10% 50% 90% Total Thickness (ft) 28.6 34.2 39.9 Based on the obtained P10, P50, and P90 values, the following forcast can be constructed: The total formation thickness will fall within the range of 28.6 ~ 39.9 ft by 80% chance, with 34.2 ft being the mean of the distribution.","tags":"Statistics","url":"https://aegis4048.github.io/uncertainty-modeling-with-monte-carlo-simulation","loc":"https://aegis4048.github.io/uncertainty-modeling-with-monte-carlo-simulation"}]};