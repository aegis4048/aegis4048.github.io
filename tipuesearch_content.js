var tipuesearch = {"pages":[{"title":"Comprehensive Confidence Intervals for Python Developers","text":"Confidence interval is uncertainty in summary statistic represented as a range. In the other words, it is a range of values we are fairly sure our true value lies in. For example: I am 95% confident that the population mean falls between 8.76 and 15.88 $\\rightarrow$ (12.32 $\\pm$ 3.56) Confidence interval tells you how confident you can be that the results from a poll or survey reflect what you would expect to find if it were possible to survey the entire population. It is difficult to obtain measurement data of an entire data set ( population ) due to limited resource & time. Your best shot is to survey a small fraction ( samples ) of the entire data set, and pray that your sample data represents the population reasonably well. Sample data may not be a good representation of a population by numerous factors (Ex: bias), and as a result, uncertainty is always introduced in any estimations derived from sample data. Due to the uncertainty involved with sample data, any statistical estimation needs to be delivered in a range, not in a point estimate . How well a sample statistic estimates an underlying population parameter is always an issue ( Population vs. Samples ). A confidence interval addresses this issue by providing a range of values, which is likely to contain the population parameter of interest within the range of uncertainty. Contents 1 Understanding confidence interval with analogy Example 1: Uncertainty in rock porosity Example 2: Purity of methamphetamine (crystal) in Breaking Bad Example 3: Uncertainty in oil production forecast 2 Key takeaways 3 Population vs Samples Notes: Population variance $\\sigma&#94;2$ vs. Sample variance $s&#94;2$ Pythonic Tip: Difference between Numpy variance and Pandas variance 4 Confidence interval of normal distribution 4.1 Confidence interval of mean Notes: Distribution of various statistics Notes: z-score vs t-score Pythonic Tip: Computing confidence interval of mean with SciPy 4.2 Confidence interval of difference in mean Notes: Comparing means of more than two samples with ANOVA 4.2.1 Independent (unpaired) samples, equal variance - Student's t-interval Pythonic Tip: Computing student's t-interval 4.2.2 Independent (unpaired) samples, unequal variance - Welch's t-interval Pythonic Tip: Computing Welch's t-interval 4.2.3 Dependent (paired) samples - Paired t-interval Pythonic Tip: Computing paired t-interval Notes: Deciding which t-test to use 4.3 Confidence interval of variance Notes: Chi-square $\\chi&#94;2$ distribution Notes: One-tail vs two-tail Pythonic Tip: Computing confidence interval of variance with SciPy 4.4 Confidence interval of other statistics: Bootstrap Notes: Monte-Carlo method Pythonic Tip: Bootstrapping in Python 5 Confidence interval of non-normal distribution 5.1 Problems of non-normal distributions and central tendency Notes: Cauchy distribution 5.2 Robustness of confidence intervals to non-normality Notes: Be cautious with hypothesis testing for normality Pythonic Tip: Q-Q plots with SciPy 5.3 Transform to normal distribution: Box-Cox Pythonic Tip: Box-Cox transform with SciPy and Scikit-Learn 5.4 Non-parametric alternative: Bootstrap 1. Understanding confidence interval with analogy If you've taken a science class with lab reports in your highschool or college, you probably had to include measurement error in your lab reports. For example, if you were asked to measure the length of a paper clip with a ruler, you have to include $\\pm0.5 \\,\\text{cm}$ or $\\pm0.05\\,\\text{cm}$ (depending on the spacing of tick marks) to account for the measurement error that shows the precision of your measuring tool. Based on figure (1) , the paper clip seems to be about 2.7 cm long, but we don't know for sure because the tickmarks in the ruler is not precise enough to measure decimal length. However, I can tell with 100% confidence that the paper clip has a length between 2 ~ 3 cm, because the clip is between the 2 cm and 3 cm tickmarks. You record the length of the paper clip in a range , instead of a point estimate , to account for the uncertainty introduced by the limitation of the measuring tool. Figure 1: Measurement error in ruler Similar idea can be applied to a confidence interval of mean . You want to obtain a mean of a whole data set ( population ), but you can measure values of only a small fraction ( samples ) of the whole data set. This boils down to the traditional issue of Population vs Samples , due to the cost of obtaining measurement data of a large data set. Uncertainty is introduced in your samples, because you don't know if your samples are 100% representative of the population, free of bias. Therefore, you deliver your conclusion in a range, not in a point estimate, to account for the uncertainty. Example 1: Uncertainty in rock porosity (Borrowed from Dr. Michael Pyrcz's Geostatistics class) A reservoir engineer in the oil & gas industry wants to know the rock porosity of a formation to estimate the total oil reserve 9,500 ft underground. Due to the high cost of obtaining rock core samples from the deep formations, he could acquire only 12 rock core samples. Since the uncertainty of a point estimation scales inversely with a sample size, his estimation is subject to non-negligible uncertainty. He obtains 14.5% average rock porosity with 4.3% standard deviation. Executives in the company wants to know the worst-case scenario (P10) and the best-case scenario (P90) to make business decisions. You can convey your estimation of average porosity with uncertainty by constructing the confidence interval of mean . Assuming that you have a reason to believe that the rock porosity follows normal distribution, you can construct its 80% confidence interval, with the procedure described below : In [133]: stats . t . interval ( 1 - 0.2 , 12 - 1 , loc = 14.5 , scale = 4.3 / np . sqrt ( 12 )) Out[133]: (12.807569748569543, 16.19243025143046) The above range of uncertainty was acquired from the 12 rock core samples. In the worst-case scenario, the rock formation at 9,500 ft underground has 12.8% porosity. In the best-case scenario, the oil reservoir has 16.2% porosity. The same procedures can be applied for the core samples collected at different depths, which give us the confidence interval plot of rock porosities shown in figure (2) . Figure 2: Confidence interval of core samples porosities along depths Source Code For Figure (2) import numpy as np from scipy import stats import matplotlib.pyplot as plt np.random.seed(39) depth = [i * 10 + 8000 for i in range(100)] l = len(depth) avg_por = [] p10_por = [] p90_por = [] for i, item in enumerate(depth): # You collect 12 rock core samples for each depth # Assume that sample porosity follows a normal distribution sample_size = 12 por_samples = np.random.normal(loc=0.15 - i/2000, scale=0.022, size=sample_size) avg_por.append(np.mean(por_samples)) # 80% confidence interval of mean p10, p90 = stats.t.interval(1 - 0.2, sample_size - 1, loc=np.mean(por_samples), scale=stats.sem(por_samples)) p10_por.append(p10) p90_por.append(p90) # plotting plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(1, 2, figsize=(8, 4)) ax[0].plot(avg_por[:l//2], depth[:l//2], 'k', label='P50', alpha=0.8) ax[0].plot(p10_por[:l//2], depth[:l//2], 'grey', linewidth=0.7, label='P10', linestyle='--') ax[0].plot(p90_por[:l//2], depth[:l//2], 'grey', linewidth=0.7, label='P90') ax[0].set_xlim(0.08, 0.17) ax[0].set_ylabel('Depth (ft)', fontsize=15) ax[0].set_xlabel('Porosity', fontsize=15) ax[0].fill_betweenx(depth[:l//2], p10_por[:l//2], p90_por[:l//2], facecolor='lightgrey', alpha=0.3) ax[0].invert_yaxis() ax[1].plot(avg_por[l//2:], depth[l//2:], 'k', label='P50', alpha=0.8) ax[1].plot(p10_por[l//2:], depth[l//2:], 'grey', linewidth=0.7, label='P10', linestyle='--') ax[1].plot(p90_por[l//2:], depth[l//2:], 'grey', linewidth=0.7, label='P90') ax[1].set_xlim(0.08, 0.17) ax[1].set_xlabel('Porosity', fontsize=15) ax[1].legend(loc='best', fontsize=14, framealpha=1, frameon=True) ax[1].fill_betweenx(depth[l//2:], p10_por[l//2:], p90_por[l//2:], facecolor='lightgrey', alpha=0.3) ax[1].invert_yaxis() Example 2: Purity of methamphetamine (crystal) in Breaking Bad 21 batches of crystal cooked by Mr. White shows 99.1% average purity with 3% standard deviation. 18 batches of crystal cooked by Mr. Pinkman shows 96.2% average purity with 4% standard deviation. Does Mr. White always cook better crystal than Mr. Pinkman, or is it possible for Mr. Pinkman to beat Mr. White in purity of cooked crystals, by luck? We can construct 95% confidence interval assuming normal distribution, with the procedure described below : In [78]: # Mr. White's stats . t . interval ( 1 - 0.05 , 21 - 1 , loc = 99.1 , scale = 3 / np . sqrt ( 21 )) Out[78]: (97.73441637228476, 100.46558362771523) In [79]: # Mr. Pinkman's stats . t . interval ( 1 - 0.05 , 18 - 1 , loc = 96.2 , scale = 4 / np . sqrt ( 18 )) Out[79]: (94.21084679714819, 98.18915320285181) There's a small overlap between the confidence intervals of Mr. White's and Mr. Pinkman's. Although it is true that Mr. White is a better cooker, Mr. Pinkman can cook a purer batch of crystals by a small chance, if he has the luck. Comparing the means of two sample data sets is closely related to constructing confidence interval of difference in mean . Figure 3: Overlap in the 95% confidence interval of two samples Source Code For Figure (3) import matplotlib.pyplot as plt from scipy import stats import numpy as np conf_pinkman = stats.t.interval(1 - 0.05, 18 - 1, loc=96.2, scale= 4 / np.sqrt(18)) conf_white = stats.t.interval(1 - 0.05, 21 - 1, loc=99.1, scale= 3 / np.sqrt(21)) plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(figsize=(5, 2)) ax.errorbar(99.1, 1, xerr=(conf_white[1] - conf_white[0]) / 2, fmt='o', markersize=8, capsize=5, label='Mr. White\\'s', color='grey') ax.errorbar(96.2, 0, xerr=(conf_pinkman[1] - conf_pinkman[0]) / 2, fmt='o', markersize=8, capsize=5, label='Mr. Pinkman\\'s', color='k') ax.set_ylim(-0.6, 1.6) ax.fill_betweenx([1, 0], conf_white[0], conf_pinkman[1], facecolor='lightgrey', alpha=0.3) ax.legend(loc='best', fontsize=11, framealpha=1, frameon=True) ax.set_xlabel('Purity (%)', fontsize=12) ax.yaxis.set_major_formatter(plt.NullFormatter()) fig.tight_layout(); Example 3: Uncertainty in oil production forecast A production engineer in the oil & gas industry wants to know the worst-case scenario (P10) and the best-case scenario (P90) of hydrocarbon production forecast. In petroleum engineering, we use a technique called Decline Curve Analysis (DCA) to project future hydrocarbon production. It is important to quantify the uncertanties of your DCA model, as the uncertainty in oil production can be as large as millions of dollars worth; executives in a company make business decisions based on P10 and P90 values. There are mainly three models for DCA: exponential, hyperbolic, and harmonic. For demonstration purpose, hyperbolic model will be used here. Hyperbolic decline curve can be defined as: $$ q = \\frac{q_i}{(1+bD_it)&#94;{1/b}}$$ It is a non-linear regression problem with three parameters to optimize: $Di$, $q_i$, and $b$. The independent variable is time $t$. We can construct the confidence interval of regression model to get P10 and P90 values. Since the analytical solution for the confidence interval of non-linear model is complicated, and the data is not normally distributed , we use non-parametric numerical alternative, bootstrap , to obtain the following uncertainty forecast model: Figure 4: Uncertainty in decline curve analysis forecast Source Code For Figure (4) import numpy as np import pandas as pd import matplotlib.pyplot as plt from scipy.optimize import curve_fit ##################################### Prepare Data ######################################### file = 'https://aegis4048.github.io/downloads/notebooks/sample_data/decline_curve.xlsx' df = pd.read_excel(file, sheet_name='sheet_1') df = df[df['Oil Prod. (bopd)'] > 200] # remove bad data points t = df['Time'][1:].values[: -40] y = df['Oil Prod. (bopd)'][1:].values[:-40] x = np.array([i for i in range(len(t))]) #################################### Define function ####################################### def hyperbolic(x, qi, b, Di): return qi / (1 + b * Di * x) ** (1 / b) ################################# Bootstrap regression ##################################### np.random.seed(42) y_boot_reg = [] for i in range(1000): # Bootstrapping boot_index = np.random.choice(range(0, len(y)), len(y)) x_boot = x[boot_index] y_boot = y[boot_index] # Curve fit data popt, pcov = curve_fit(hyperbolic, x_boot, y_boot, maxfev=100000, p0=[max(y), 0.1, 0.1]) # Define predicted region pred_x = [i for i in range(x[-1], x[-1] + 20)][1:] x_new = np.append(x, np.array([pred_x])) # Predict y_boot_reg = y_boot_reg + [hyperbolic(x_new, *popt)] y_boot_reg = np.array(y_boot_reg) p10 = np.percentile(y_boot_reg, 10, axis=0) p50 = np.percentile(y_boot_reg, 50, axis=0) p90 = np.percentile(y_boot_reg, 90, axis=0) # Basic curve fit popt, pcov = curve_fit(hyperbolic, x, y, maxfev=100000, p0=[max(y), 0.1, 0.1]) ###################################### Plotting ########################################## fig, ax = plt.subplots(figsize=(8, 4)) for reg_sample in y_boot_reg: ax.plot(x_new, reg_sample, color='grey', alpha=0.3) ax.plot(x, y, '--o', color='k', alpha=1) ax.plot(x_new, p10, ':',color='#1f77b4', alpha=1, label='P10') ax.plot(x_new, hyperbolic(x_new, *popt), color='r', label='P50') ax.plot(x_new, p90, '-.',color='#1f77b4', alpha=1, label='P90') ax.set_yscale('log') ax.set_ylim(80, 30000) ax.set_xlim(-2, 57) ax.set_xlabel('Months', fontsize=15) ax.set_ylabel('Oil Production (bopd)', fontsize=15) ax.set_title('Uncertainty in decline curve analysis with Bootstrap', fontsize=18) ax.grid(True, linestyle='--', color='#acacac') ax.axvspan(-2, x[-1], facecolor='#efefef', alpha=0.5) ax.axvspan(x[-1], 57, facecolor='lightgrey', alpha=0.5) ax.text(0.38, 0.1, 'Fitted region', fontsize=15, transform=ax.transAxes, color='k') ax.text(0.7, 0.1, 'Predicted region', fontsize=15, transform=ax.transAxes, color='k') ax.text(0.27, 0.91, 'aegis4048.github.io', fontsize=13, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) ax.legend() fig.tight_layout() 2. Key takeaways 1. Confidence interval quantifies uncertainty of statistical estimation Confidence interval qunatifies the uncertainty related to a statistical estimation to mitigate the issue of Population vs. Samples . It is always expressed in a range like — $\\text{C.I.}: \\quad \\bar{x} \\pm 3.43$ or $-51.4 < \\bar{x} < -43.2$ 2. Confidence interval is the basis of parametric hypothesis tests Confidence interval is the basis of parametric hypothesis tests. For example, t-test computes its p-value using the confidence interval of difference in mean . When samples follow a normal distribution, and therefore their centeral tendency can be described by their means, t-test can be used to conclude if two distributions are significantly different from each other. 3. Formula for confidence interval varies with statistics For confidence interval of mean $$ \\text{C.I.}_{\\text{mean}}: \\quad \\mu \\pm (t_{\\frac{\\alpha}{2},df} \\times \\frac{s}{\\sqrt{n}})$$ For confidence interval of difference in mean $$ \\text{C.I.}_{\\Delta \\text{mean}}: \\quad (\\mu_{1}- \\mu_{2}) \\pm (t_{1-\\frac{\\alpha}{2},df} \\times \\sqrt{\\frac{s_1&#94;2}{n_1}+\\frac{s_2&#94;2}{n_2}})$$ For confidence interval of proportion $$ \\text{C.I.}_{\\text{proportion}}: \\quad \\hat{p} \\pm (t_{\\frac{\\alpha}{2},df} \\times \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} )$$ For confidence interval of variance $$ \\text{C.I.}_{\\text{variance}}: \\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{\\frac{\\alpha}{2}}} \\leq \\sigma&#94;2 \\leq \\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{1-\\frac{\\alpha}{2}}}$$ For confidence interval of standard deviation $$ \\text{C.I.}_{\\text{standard deviation}}: \\sqrt{\\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{\\frac{\\alpha}{2}}}} \\leq \\sigma \\leq \\sqrt{\\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{1-\\frac{\\alpha}{2}}}}$$ Different analytical solutions exist for different statistics. However, confidence interval for many other statistics cannot be analytically solved, simply because there are no formulas for them. If the statistic of your interest does not have an analytical solution for its confidence interval, or you simply don't know it, numerical methods like boostrapping can be a good alternative (and its powerful). 4. Parametric methods suffer loss in accuracy under non-normality The equations listed above are not valid if sample data set is not normally distributed . In case of non-normally distributed data, its confidence interval can be obatined with non-parametric methods like boostrapping , or instead use credible interval, which is a Baysian equivalent of confidence interval. Or you can transform your data into normal distribution using Box-Cox transformation . Make sure that you understand robustness of parametric vs. non-parametric methods for non-normal distributions, which is discussed in detail below . 5. 95% C.I. does not mean 95% of the sample data lie within the interval. It means that there's 95% chance that the estimated statistic falls within the interval. 95% confidence interval relates to the reliability of the estimation procedure. Ex: How reliable is your estimation of population variance? 6. Always use t-score instead of z-score When constructing confidence interval of mean, or running t-test, always use t-score instead of z-score. This is because t-distribution accounts for bigger uncertainty in samples than normal distribution when sample size is samll, but converges to normal distribution when sample size is bigger than 30. The concept is described in detail below . 7. Bigger sample size gives narrower confidence intervals Intuitively, this is because the more samples we have, the less uncertainty we have with our statistical estimation. Mathematically, this is because the the confidence interval is inversely related to the sample size $n$, as shown in eq (1) . 8. Means are not always equivalent to central tendency When samples are not normally distributed, their means are not a good measure of their centeral tendencies . For example, if you are comparing the means of two non-normal data sets with t-test to conclude if they came from the same population, your approach is wrong. The more viable alternative would be to use non-parametric alternatives that uses median, or other statistics that capture the central tendency of non-normal distributions. 3. Population vs. samples Confidence interval describes the amount of uncertainty associated with a sample estimate of a population parameter. One needs to have a good understanding of the difference between samples and population to understand the necessity of delivering statistical estimations in a range, a.k.a. confidence interval. Figure 5: Population vs samples Population : data set that contains all members of a specified group. Ex: ALL people living in the US. Samples : data set that contains a part, or a subset, of a population Ex: SOME people living in the US. Let's say that you are conducting a phone-call survey to investigate the society's perception of The Affordable Care Act (\"Obamacare\"). Since you can't call all 327.2 million people ( population ) in the US, you call about 1,000 people ( samples ). Your poll showed that 59% of the registered voters support Obamacare. This does not agree with the actual survey conducted in 2018; 53% favorable, 42% unfavorable ( source ). What could be the source of error? Since (formal) president Obama is a member of the Democratic Party, the voters' response can be affected by their political preference. How could you tell that the 1,000 people you called happened to be mostly Democrats, who's more likely to support Obama's policy, because they share similar political view? The samples you collected could have been biased , but you don't that know for sure. Of course, the voters' response could be affected by many other factors like race, age, place of residence, or financial status. The idea is that, there will always be uncertainty involved with your estimation, because you don't have an access to the entire population. Confidence interval is a technique that quantifies the uncertainty when estimating a population parameter from samples. Notes: Population variance $\\sigma&#94;2$ vs. Sample variance $s&#94;2$ Distinction between population parameter and sample parameter is important. In statistics, it is a common practice to denote population variance as $\\sigma&#94;2$, and sample variance as $s&#94;2$. The distinction is important because different equations are used for each. For population: $$ \\text{variance} = \\sigma&#94;2 = \\frac{\\sum(x - \\bar{x})&#94;2}{n} $$ For samples: $$ \\text{variance} = s&#94;2 = \\frac{\\sum(x - \\bar{x})&#94;2}{n-1} $$ The divisor $n-1$ is a correction factor for bias. Note that the correction has a larger proportional effect when $n$ is small than when $n$ is large, which is what we want because the more samples we have, the better the estimation. This idea is well explained on this StackExchange thread . Pythonic Tip: Difference between Numpy variance and Pandas variance Different libraries make different assumption about an input array. The default value of ddof is different for Pandas and Numpy, resulting in different variance. ddof represent degrees of freedom, and setting ddof=True or ddof=1 tells the variance function to calculate sample variance by accounting for the bias factor $n-1$ (recall that in Python, True==1 .) Remember that there is a distinction between Population variance ($\\sigma&#94;2$) vs. Sample variance ($s&#94;2$). If you are confused which library is computing which variance (sample or population), just remember this: whatever library you are using, use ddof=True or ddof=1 to compute sample variance, and use ddof=False or ddof=0 to compute population variance. In [1]: import numpy as np import pandas as pd arr = pd . DataFrame ([ 5 , 3 , 1 , 6 ]) In [7]: # numpy, population arr . values . var () Out[7]: 3.6875 In [8]: # numpy, sample arr . values . var ( ddof = 1 ) Out[8]: 4.916666666666667 In [10]: # pandas, population arr . var ( ddof = 0 ) Out[10]: 0 3.6875 dtype: float64 In [99]: # pandas, sample arr . var () Out[99]: 0 4.916667 dtype: float64 4. Confidence interval of normal distribution Computing confidence interval of a statistic depends on two factors: type of statistic, and type of sample distribution. As explained above , different formulas exist for different type of statistics (Ex: mean, std, variance), and different methods (Ex: boostrapping , credible interval, Box-Cox transformation ) are used for non-normal data set. We will cover confidence interval of mean, difference in mean and variance. 4.1. Confidence interval of mean Confidence interval of mean is used to estimate the population mean from sample data and quantify the related uncertainty. Consider the following figure: Figure 6: Distribution of population and C.I. of mean In figure (6) , assume that the population is normally distributed. Since we don't have an access to the entire population, we have to guess the population mean (unknown) to the best of our ability using sample data set. We do this by computing the sample mean and constructing its 95% confidence interval . Note that the popular choices of confidence level are: 90%, 95%, and 99% Assuming normality of population, its sample means are also normally distributed. Let's say that you have a population, and you draw small fractions of it $N$ times. Then, the computed means of $N$ sample sets $\\boldsymbol{\\mu}=(\\mu_1, \\mu_2,..., \\mu_{N-1}, \\mu_N)$ is normally distributed as shown in figure (7) . Their confidence intervals are represented as the black horizontal arrows:. Figure 7: Distribution of sample mean and its C.I. You can see that the confidence interval of $\\mu_5$ does NOT include the green vertical dashed line , 12.31. Let's assume that 12.31 is the true population mean (we never know if this is the actual population mean or not, but let's assume). If we get $\\mu_5$ and its confidence interval as our estimation of the population mean, then our estimation is wrong. There is a 5% chance of this happening, because we set our confidence level as 95%. Note that the width of the confidence intervals (black horizontal arrows) depend on the sample size, as shown in eq (1) The grey area of figure (6) is essentially equivalent to the grey area of figure (7) . $\\mu_1$ = 12.32 is the sample mean, and $\\pm$ 3.56 is the uncertainty related to the sample mean with 95% confidence. The uncertainty is a product of distribution score and standard error of mean. Distribution score essentially tells how many standard error are the limits (8.76 and 15.88) away from the center (12.32). Choosing larger confidence level results in larger confidence interval. This increases the grey area in figure (6) and figure (7) . We convey 95% confidence interval of mean like this: I am 95% confident that the population mean falls between 8.76 and 15.88. If I sample data 20 times, 19 times the sample mean will fall between 8.76 ~ 15.88, but expect that I will be wrong 1 time. Notes: Distribution of various statistics Different statistics exhibit different distributions. Normality of samples does not guarantee normality of its statistics. When the samples are normally distributed, their means are normally distributed, but their variances are chi-square $\\chi&#94;2$ distributed. More discussion about the distribution of variance and $\\chi&#94;2$ distribution is covered below . Note that these assumptions are invalid when samples are non-normal. Source Code For The Figure from scipy import stats import matplotlib.pyplot as plt import numpy as np df_values = [1, 2, 6, 9] linestyles = ['-', '--', ':', '-.'] normal_params = [(10, 1), (11, 1), (10, 2), (10, 3)] x = np.linspace(-1, 20, 1000) plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(1, 2, figsize=(13.3, 5)) fig.tight_layout() plt.subplots_adjust(left=0.09, right=0.96, bottom=0.12, top=0.93) for df, norm_p, ls in zip(df_values, normal_params, linestyles): ax[1].plot(x, stats.chi2.pdf(x, df, loc=0, scale=1), ls=ls, c='black', label=r'Degrees of freedom$=%i$' % df) ax[0].plot(x, stats.norm.pdf(x, loc=norm_p[0], scale=norm_p[1]), ls=ls, c='black', label='Mean = %d, ' % norm_p[0] + 'Std = %s' % norm_p[1]) ax[0].set_xlim(4, 16) ax[0].set_ylim(-0.025, 0.525) ax[0].set_xlabel('$x$', fontsize=20) ax[0].set_ylabel(r'Probability', fontsize=20) ax[0].set_title(r'Distribution of means: normal distribution', fontsize=20) ax[0].legend(loc='upper left', fontsize=16, framealpha=1, frameon=True) ax[1].set_xlim(0, 10) ax[1].set_ylim(-0.025, 0.525) ax[1].set_xlabel('$\\chi&#94;2$', fontsize=20) ax[1].set_title(r'Distribution of variances: $\\chi&#94;2$ distribution', fontsize=20) ax[1].legend(loc='best', fontsize=16, framealpha=1, frameon=True) If sample data is normal or normal-like distributed, we almost always assume t-distribution to compute confidence interval, as explained below . Then, the confidence interval of mean has the following analytical solution: $$ \\text{C.I.}_{\\text{mean}}: \\quad \\mu \\pm (t_{1-\\frac{\\alpha}{2},df} \\times \\frac{s}{\\sqrt{n}}) \\tag{1}$$ where $\\mu$ : sample mean $\\alpha$ : significance level $n$ : number of samples $df$ : degrees of freedom. In this example, df = $n$ - 1 $s$ : sample standard deviation $t$ : t-score. depends on $\\alpha$ and $df$ Recall that when computing $s$, correction factor ($n-1$) is applied to account for sample bias, as explained above . Pay close attention to the standard error $\\frac{s}{\\sqrt{(n)}}$. As the sample size $n$ increases, the standard error decreases, reducing the range of confidence interval. This is intuitive in a sense that, the more samples we have, the less uncertainty we have with our statistical estimation. The length of the black horizontal arrows in figure (7) depends on the sample size. The larger the sample size, the narrower the width of arrows, and vice versa. Notes: z-score vs t-score You've probably seen mixed use of z-score and t-score for confidence interval during your studies. Long story short, it is safe and almost always better to use t-score than z-score. Z-score ($z_{\\frac{\\alpha}{2}}$) is used for normal distribution, and t-score ($t_{\\frac{\\alpha}{2},df}$) is used for t-distribution. You use z-score if you know the population variance $\\sigma&#94;2$. If not, you use t-score. Since the population variance $\\sigma&#94;2$ is almost never known, you almost always use t-score for confidence interval. After all, the purpose of using confidence interval is to mitigate the issue of Population vs. Samples when estimating population parameter ($\\sigma&#94;2$) from samples. If you know the population parameters, you probably don't need confidence interval in the first place. A natural question is, \"how is it safe to use t-score instead of z-score? Shouldn't I be using z-score since I know that the population is normally distributed, from previous knowledge?\" It is safe to do so because t-distribution converges to normal distribution according to the Centeral Limit Theorem. Recall that t-distribution behaves more and more like a normal distribution as the sample size increases. Google \"95% confidence z-score\" and you will see $z$ = 1.96 at 95% confidence level. On the other hand, t-score approaches 1.96 as its degrees of freedom increases: $\\lim_{df \\to \\infty}t$ = 1.96. For 95% confidence level, $t$ = 2.228 when $n$ - 1 = 10 and $t$ = 2.086 when $n$ - 1 = 20. This is why it is safe to always replace z-score with t-score when computing confidence interval. Pythonic Tip: Computing confidence interval of mean with SciPy We can compute confidence interval of mean directly from using eq (1) . Recall to pass ddof=1 to make sure to compute sample standard deviation $s$, not population standard deviation $\\sigma$, as explained above . We will draw random samples from normal distribution using np.random.normal(). Note that loc is for population mean, and scale is for population standard deviation, and size is for number of samples to draw. In [128]: from scipy import stats import numpy as np np . random . seed ( 42 ) arr = np . random . normal ( loc = 74 , scale = 4.3 , size = 20 ) alpha = 0.05 # significance level = 5% df = len ( arr ) - 1 # degress of freedom = 20 t = stats . t . ppf ( 1 - alpha / 2 , df ) # two-tailed 95% confidence t-score = 2.086 s = np . std ( arr , ddof = 1 ) # sample standard deviation = 2.502 n = len ( arr ) lower = np . mean ( arr ) - ( t * s / np . sqrt ( n )) upper = np . mean ( arr ) + ( t * s / np . sqrt ( n )) In [129]: ( lower , upper ) Out[129]: (71.33139551903422, 75.19543685256606) Or we can compute with scipy.stats.t.interval(). Note that you don't divide alpha by 2, because the function does that for you. Also note that the standard error of mean $\\frac{s}{\\sqrt{n}}$ can be computed with scipy.stats.sem() In [130]: stats . t . interval ( 1 - alpha , len ( arr ) - 1 , loc = np . mean ( arr ), scale = stats . sem ( arr )) Out[130]: (71.33139551903422, 75.19543685256606) Note the default value of loc=0 and scale=1 . This will assume sample mean $\\mu$ to be 0, and standard error $\\frac{s}{\\sqrt{n}}$ to be 1, which assumes standard normal distribution of mean = 0 and standard deviation = 1. This is NOT what we want. In [8]: stats . t . interval ( 1 - alpha , len ( arr ) - 1 ) Out[8]: (-2.093024054408263, 2.093024054408263) 4.2. Confidence interval of difference in mean Confidence interval of difference in mean is not very useful by itself. But it is important to understand how it works, because it forms the basis of one of the most widely used hypothesis test: t-test . Often we are interested in knowing if two distributions are significantly different. In the other words, we want to know if two sample data sets came from the same population by comparing central tendency of populations . A standard approach is to check if the sample means are different. However, this is a misleading approach in a sense that the means of samples are almost always different, even if the difference is microscopic. More useful would be to estimate the difference in a range to account for uncertainty, and compute probability that it is big enough to be of practical importance. T-test checks if the difference is \"close enough\" to zero by computing the confidence interval of difference in means. T-test hypothesis $$ H_0: \\mu_1 - \\mu_2 = 0 \\tag{2}$$ $$ H_1: \\mu_1 - \\mu_2 \\neq 0 \\tag{3}$$ where $\\mu$ : sample mean $H_0$ : null hypothesis — sample means are the same \"enough\" $H_1$ : alternate hypothesis — sample means are \"significantly\" different Note that the above hypothesis tests whether the mean of one group is significantly DIFFERENT from the mean of the other group; we are using two-tailed test. This does not check if the mean of one group is significantly GREATER than the mean of the other group, which uses one-tailed test. Notes: Comparing means of more than two samples with ANOVA Analysis of variance (ANOVA) checks if the means of two or more samples are significantly different from each other. Using t-test is not reliable in cases where there are more than 2 samples. If we conduct multiple t-tests for comparing more than two samples, it will have a compounded effect on the error rate of the result. ANOVA has the following hypothesis: $$ \\begin{align} H_0: &\\mu_1 = \\mu_2 = \\, \\cdots \\, =\\mu_L \\\\[5pt] H_1: &\\mu_a \\neq \\mu_b \\end{align} $$ where $L$ is the number of groups, and $\\mu_a$ and $\\mu_b$ belong to any two sample means of any groups. This article illustrates the concept of ANOVA very well. Figure 8: Distributions of samples In figure (8) , $\\mu$ represents the sample mean. If two sample data sets are from the same population, the distribution of means will be similar \"enough\". If not, they will be \"significantly\" different. It can be visually inspected by the area of overlap. The larger the overlap, the bigger the chance of the two distributions originating from the same population. The more robust way to compare sample means would be to construct the confidence interval of difference in means. If the two samples came from the same population, they should have the similar \"enough\" means. Their difference should be close to zero and satisfy (or fail to reject) the null hypothesis $H_0: \\mu_1 - \\mu_2 = 0$ within a range of uncertainty. Consider the following figure: Figure 9: Distribution of difference in means In figure (9) , the calculated difference in sample means is $\\mu_1 - \\mu_2 = 1.00$ . We deliver the uncertainty related to our estimation of difference in sample means by constructing its 95% confidence interval $[$-1.31 ~ 3.31$]$ . Since the null hypothesis $H_0: \\mu_1 - \\mu_2 = 0$ is within the 95% confidence interval ( grey shaded area ), we accept the null hypothesis; we conclude that the samples have the same means within the uncertainty. However, if the null hypothesis is not within the confidence interval and falls in the 2.5% outliers zone, we reject the null hypothesis and accept the alternate hypothesis $H_1: \\mu_1 - \\mu_2 \\neq 0$ . In the other words, we conclude that the sample means are significantly different. Three variations of confidence interval of difference in means There are three variations of t-test, and therefore there are three variations of confidence interval of difference in means. The difference & application of the three variations are really well-explained in Wikipedia (one of the few that are actually easy to understand, with minimum jargons.) Independent (unpaired) samples, equal variance - Student's t-interval Independent (unpaired) samples, unequal variance - Welch's t-interval Dependent (paired) samples Recall that all t-tests assume normality of data. However, they are pretty robust to non-normality as long as the deviation from normality isn't large. Visualize your distributions to test this. Robustness of t-test to non-normality is discussed in detail below . 4.2.1. Independent (unpaired) samples, equal variance - student's t-interval When you have a reason to believe that samples have nearly equal variances, you can use student's t-test to check if difference in means are significantly different. Note that student's t-test works pretty well even with unequal variances as long as sample sample sizes are equal or nearly equal, and sample sizes are not tiny. However, it is recommended to always use Welch's t-test by assuming unequal variances, as explained below . Use student's t-test if you are ABSOLUTELY sure that the population variances are nearly equal. Confidence interval of difference in mean assuming equal variance (student's t-interval) can be calculated as follows: $$ \\text{C.I.}_{\\Delta \\text{mean}}: \\quad (\\mu_{1}- \\mu_{2}) \\pm (t_{1-\\frac{\\alpha}{2},df} \\times s_p\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}})\\,, \\quad s_p = \\sqrt{\\frac{(n_1-1)s_{1}&#94;2 + (n_2-1)s_{2}&#94;2}{n_1+n_2-2}} \\tag{4}$$ where $\\mu$ : sample mean $\\alpha$ : significance level $n$ : number of samples $df$ : degrees of freedom $s_p$ : pooled standard deviation $s$ : sample standard deviation $t$ : t-score. depends on $\\alpha$ and degrees of freedom $n-1$ The formula for the pooled standard deviation $s_p$ looks a bit overwhelming, but its just an weighted average standard deviation of two samples, with bias correction factor $n_i-1$ for each sample. Recall that student's t-test assumes equal variances of two samples. You calculate what is assumed to be the common variance (=pooled variance, $s_p&#94;2$) by computing the weighted average from each sample's variance. In eq (4) , $t$-score depends on significance level $\\alpha$ and degrees of freedom $df$. In student's t-test, which assumes equal variance: $$ df = n_1 + n_2 -2 \\tag{5}$$ Pythonic Tip: Computing student's t-interval Unfortunately, SciPy doesn't support computing confidence intereval of difference in mean separately. It is incorporated into computing t-statistic and p-value of t-test, but users can't access its underlying confidence interval. Note that in R, users have access to the CI of difference in means. We can compute CI of difference in means assuming equal variance with eq (4) . Don't forget to compute sample variance, instead of population variance by setting ddof=1 as explained above . In [182]: from scipy import stats import numpy as np In [183]: x1 = [ 12.9 , 10.2 , 7.4 , 7.0 , 10.5 , 11.9 , 7.1 , 9.9 , 14.4 , 11.3 ] x2 = [ 10.2 , 6.9 , 10.9 , 11.0 , 10.1 , 5.3 , 7.5 , 10.3 , 9.2 , 8.8 ] alpha = 0.05 # significance level = 5% n1 , n2 = len ( x1 ), len ( x2 ) # sample sizes s1 , s2 = np . var ( x1 , ddof = 1 ), np . var ( x2 , ddof = 1 ) # sample variances s = np . sqrt ((( n1 - 1 ) * s1 + ( n2 - 1 ) * s2 ) / ( n1 + n2 - 2 )) # pooled standard deviation df = n1 + n2 - 2 # degrees of freedom t = stats . t . ppf ( 1 - alpha / 2 , df ) # two-tailed 95% confidence t-score lower = ( np . mean ( x1 ) - np . mean ( x2 )) - t * np . sqrt ( 1 / len ( x1 ) + 1 / len ( x2 )) * s upper = ( np . mean ( x1 ) - np . mean ( x2 )) + t * np . sqrt ( 1 / len ( x1 ) + 1 / len ( x2 )) * s In [184]: ( lower , upper ) Out[184]: (-0.8520326742900641, 3.332032674290068) The 95% confidence interval of difference in means has 0 within its interval. This means that the null hypothesis, $H_0: \\mu_1 - \\mu_2 = 0$ in figure (9) , falls within the interval and we fail to reject the null hypothesis. We conclude that the sample means are not significantly different. We can confirm this by running a formal hypothesis testing with scipy.stats.ttest_ind() , and setting equal_var=True . Note that this assumes independent t-test with pooled variance, which is equivalent to student's t-test. In [185]: stats . ttest_ind ( x1 , x2 , equal_var = True ) Out[185]: Ttest_indResult(statistic=1.2452689491491107, pvalue=0.22900078577218805) The computed pvalue=0.229 is bigger than the significance level of alpha = 0.05 , and therefore we fail to reject the null hypothesis, which is consistent with the conclusion drawn from the confidence interval of difference in mean. Checking results with R : a <- c(12.9, 10.2, 7.4, 7.0, 10.5, 11.9, 7.1, 9.9, 14.4, 11.3) b <- c(10.2, 6.9, 10.9, 11.0, 10.1, 5.3, 7.5, 10.3, 9.2, 8.8) t.test(a, b, var.equal = TRUE) # Two Sample t-test # data: a and b # t = 1.2453, df = 18, p-value = 0.229 # 95 percent confidence interval: # -0.8520327 3.3320327 # sample estimates: # mean of x mean of y # 10.26 9.02 4.2.2. Independent (unpaired) samples, unequal variance - Welch's t-interval When comparing central tendency of normal distributions, it is safer, and therefore recommended to always use Welch's t-test, which assumes unequal variances of samples, as explained below . Equal variance t-test is not robust when population variances are different, but unequal variances are robust even when population variances are equal. Confidence interval of difference in mean assuming unequal variance (Welch's t-interval) can be calculated as follows: $$ \\text{C.I.}_{\\Delta \\text{mean}}: \\quad (\\mu_{1}- \\mu_{2}) \\pm (t_{1-\\frac{\\alpha}{2},df} \\times \\sqrt{\\frac{s_1&#94;2}{n_1}+\\frac{s_2&#94;2}{n_2}}) \\tag{6}$$ where $\\mu$ : sample mean $\\alpha$ : significance level $n$ : number of samples $df$ : degrees of freedom $s$ : sample standard deviation $t$ : t-score. depends on $\\alpha$ and degrees of freedom $n-1$ The formula is very similar to student's t-interval. There are two main differences: 1. We use each sample's own variance $s_1&#94;2$ and $s_2&#94;2$, instead of pooled (weighted average) variance $s_p&#94;2$. 2. Degrees of freedom $df$ is computed with eq (7). $$ df = \\frac{(\\frac{s&#94;2_1}{n_1} + \\frac{s&#94;2_2}{n_2})&#94;2}{\\frac{(s&#94;2_1/n_1)&#94;2}{n_1-1} + \\frac{(s&#94;2_2/n_2)&#94;2}{n_2-1}} \\tag{7}$$ Pythonic Tip: Computing Welch's t-interval The procedure is very similar to Computing student's t-interval . We will compute confidence interval of difference in mean assuming unequal variance, with eq (6). Although Scipy supports computing t-statistic for Welch's t-test, it doesn't support a function that allows us to compute Welch's t-interval. We will have to write our own codes to compute it. Don't forget to compute sample variance, instead of population variance by setting ddof=1 as explained above . In [186]: from scipy import stats import numpy as np In [187]: x1 = [ 12.9 , 10.2 , 7.4 , 7.0 , 10.5 , 11.9 , 7.1 , 9.9 , 14.4 , 11.3 ] x2 = [ 10.2 , 6.9 , 10.9 , 11.0 , 10.1 , 5.3 , 7.5 , 10.3 , 9.2 , 8.8 ] alpha = 0.05 # significance level = 5% n1 , n2 = len ( x1 ), len ( x2 ) # sample sizes s1 , s2 = np . var ( x1 , ddof = 1 ), np . var ( x2 , ddof = 1 ) # sample variances df = ( s1 / n1 + s2 / n2 ) ** 2 / (( s1 / n1 ) ** 2 / ( n1 - 1 ) + ( s2 / n2 ) ** 2 / ( n2 - 1 )) # degrees of freedom t = stats . t . ppf ( 1 - alpha / 2 , df ) # two-tailed 95% confidence t-score lower = ( np . mean ( x1 ) - np . mean ( x2 )) - t * np . sqrt ( 1 / len ( x1 ) + 1 / len ( x2 )) * s upper = ( np . mean ( x1 ) - np . mean ( x2 )) + t * np . sqrt ( 1 / len ( x1 ) + 1 / len ( x2 )) * s In [188]: ( lower , upper ) Out[188]: (-0.8633815129922358, 3.3433815129922397) The 95% confidence interval of difference in means has 0 within its interval. This means that the null hypothesis, $H_0: \\mu_1 - \\mu_2 = 0$ in figure (9) , falls within the interval and we fail to reject the null hypothesis. We conclude that the sample means are not significantly different. We can confirm this by running a formal hypothesis testing with scipy.stats.ttest_ind() , and setting equal_var=False . Note that this assumes independent t-test with pooled variance, which is equivalent to student's t-test. In [189]: stats . ttest_ind ( x1 , x2 , equal_var = False ) Out[189]: Ttest_indResult(statistic=1.245268949149111, pvalue=0.23018336828903668) The computed pvalue=0.230 is bigger than the significance level of alpha = 0.05 , and therefore we fail to reject the null hypothesis, which is consistent with the conclusion drawn from the confidence interval of difference in mean. Checking results with R : a <- c(12.9, 10.2, 7.4, 7.0, 10.5, 11.9, 7.1, 9.9, 14.4, 11.3) b <- c(10.2, 6.9, 10.9, 11.0, 10.1, 5.3, 7.5, 10.3, 9.2, 8.8) t.test(a, b, var.equal = FALSE) # Welch Two Sample t-test # data: a and b # t = 1.2453, df = 16.74, p-value = 0.2302 # alternative hypothesis: true difference in means is not equal to 0 # 95 percent confidence interval: # -0.8633815 3.3433815 # sample estimates: # mean of x mean of y # 10.26 9.02 4.2.3. Dependent (paired) samples - Paired t-interval This test is used when the samples are dependent; that is, when there is only one sample that has been tested twice (repeated measures) or when there are two samples that have been matched or \"paired\" (paired or unpaired? read below. ) Confidence interval of difference in means assuming paired samples can be calculated as follows: $$ \\text{C.I.}_{\\Delta \\text{mean}}: \\quad \\bar{d} \\pm (t_{1-\\frac{\\alpha}{2}, df} \\times \\frac{s_d}{\\sqrt{n}})\\tag{8}$$ where $\\bar{d}$ : average of sample differences $\\alpha$ : significance level $n$ : number of samples $df$ : degrees of freedom $s_d$ : standard deviation of sample differences $t$ : t-score. depends on $\\alpha$ and degrees of freedom $n-1$ The equation is very similar to eq (1) , except that we are computing mean and standard deviation of differences between before & after state of test subjects. Let's try to understand this with an example. A school develops a tutoring program to improve the SAT scores of high school students. A school requires students to take tests before & after tutoring, and checks if the tutoring had a significant impact on the SAT scores of students. Because the test subjects are compared to themselves, not anyone elses, the measurements taken before & after the training are not independent. To compute dependent t-interval, we compute differences of test scores before & after tutoring: Student # $X_1$ $X_2$ $X_1$ - $X_2$ 1 1480 1510 -30 2 1280 1460 -180 3 890 1320 -430 4 340 700 -360 5 1550 1550 0 6 1230 1420 -190 7 1010 1340 -330 8 1590 1570 20 9 1390 1500 -110 10 980 1300 -320 We find $\\bar{d}$ = -193.0, and $s_d$ = 161.7. These values are plugged into eq (8). Degrees of freedom $df$ for dependent t-interval can be computed with: $$ df = n - 1 \\tag{9}$$ Unlike independent t-test, in which two samples can have different sample sizes $n_1$ and $n_2$, depedent t-test has only one sample size, because the test subjects are compared to themselves. Also note that dependent t-test assumes difference of test scores to be normally distributed, not test scores of students themselves. But as long as the test scores are normally distributed, the difference of test scores will also be normally distributed due to the property of normal distributions. Pythonic Tip: Computing paired t-interval Although Scipy supports computing t-statistic for dependent t-test, it doesn't support a function that allows us to compute dependent t-interval. We will have to write our own codes to compute it. You can compute it with eq (8) Don't forget to compute sample standard devaition, instead of population standard deviation by setting ddof=1 as explained above . In [190]: from scipy import stats import numpy as np In [191]: x1 = np . array ([ 1480 , 1280 , 890 , 340 , 1550 , 1230 , 1010 , 1590 , 1390 , 980 ]) x2 = np . array ([ 1510 , 1460 , 1320 , 700 , 1550 , 1420 , 1340 , 1570 , 1500 , 1300 ]) alpha = 0.05 # significance level = 5% d_bar = np . mean ( x1 - x2 ) # average of sample differences s_d = np . std ( x1 - x2 , ddof = 1 ) # sample standard deviation of sample differences n = len ( x1 ) # sample size df = n - 1 # degrees of freedom t = stats . t . ppf ( 1 - alpha / 2 , df ) # two-tailed 95% confidence t-score lower = d_bar - t * s_d / np . sqrt ( n ) upper = d_bar + t * s_d / np . sqrt ( n ) In [192]: ( lower , upper ) Out[192]: (-308.64567899681356, -77.35432100318641) The 95% confidence interval of difference in means for dependent samples does not have 0 within its interval. This means that the null hypothesis, $H_0: \\mu_1 - \\mu_2 = 0$ in figure (9) , does not fall within the interval. Instead, our estimation falls within the 2.5% outlier zone on the left, $H_1: \\mu_1 - \\mu_2 \\neq 0$ . We reject the null hypothesis $H_0$, and accept the alternate hypothesis $H_1$. We conclude that the sample means are significantly different. In the other words, the tutoring program developed by the school had significant impact on the SAT score of its students. We can confirm this by running a formal hypothesis testing with scipy.stats.ttest_rel(). Note that this assumes dependent t-test. In [193]: stats . ttest_rel ( x1 , x2 ) Out[193]: Ttest_relResult(statistic=-3.7752930865755987, pvalue=0.004380623368522125) The computed pvalue=0.004 is smaller than the significance level of alpha = 0.05 , and therefore we reject the null hypothesis and accept the alternate hypothesis, which is consistent with the conclusion drawn from the confidence interval of difference in mean. Notes : The above hypothesis testing answers the question of \"Did this tutoring program had a significant impact on the SAT scores of students?\". However, in cases like this, a more intuitive question is \"Did this tutoring program significantly improve the SAT scores of students?\" The former uses two-tailed test, and the latter uses one-tailed test, and the procedures for them are a little different. Checking results with R : x1 = c(1480, 1280, 890, 340, 1550, 1230, 1010, 1590, 1390, 980) x2 = c(1510, 1460, 1320, 700, 1550, 1420, 1340, 1570, 1500, 1300) t.test(x1, x2, paired=TRUE) # Paired t-test # data: x1 and x2 # t = -3.7753, df = 9, p-value = 0.004381 # alternative hypothesis: true difference in means is not equal to 0 # 95 percent confidence interval: # -308.64568 -77.35432 # sample estimates: # mean of the differences # -193 Notes: Deciding which t-test to use Equal or unequal variance? Long story short, always assume unequal variance of samples when using t-test or constructing confidence interval of difference in means. Student's t-test is used for samples of equal variance, and Welch's t-test is used for samples of unequal variance. A natural question is, how do you know which test to use? While there exist techniques to check homogeneity of variances (f-test, Barlett's test, Levene's test), it is dangerous to run hypothesis testing for equality of variances to decide which t-test to use (student's t-test or Welch's t-test), because it increases Type I error (asserting something that is absent, false positive). This is shown by Moser and Stevens (1992) and Hayes and Cai (2010). Kubinger, Rasch and Moder (2009) argue that when the assumptions of normality and homogeneity of variances are met, Welch's t-test performs equally well, but outperforms when the assumptions are not met. Ruxton (2006) argues that the \"unequal variance t-test should always be used in preference to the Student's t-test\" (Note: what he means by \"always\" is assuming normality of distribution) Also note that R uses Welch's t-test as the default for the t.test() function. Independent (unpaired) or dependent (paired) samples? Paired t-test compares the same subjects at 2 different times . Unpaired t-test compares two different subjects. Samples are independent (unpaired) if one measurement is taken on different groups. For example in medical treament, group A is a control group, and is given a placebo with no medical effect. Group B is a test group, and receives a prescribed treatment with expected medical effect. Health check is applied on two groups, and the measurements are recorded. We say that the measurement from group A is independent from that of group B. Samples are dependent (paired) when repeated measures are taken on the same or related subjects. For example, there may be instances of the same patients being tested repeatedly - before and after receiving a particular treatment. In such cases, each patient is being used as a control sample against themselves. This method also applies to cases where the samples are related in some manner or have matching characteristics, like a comparative analysis involving children, parents or siblings. If you have a reason to believe that samples are correlated in any ways, it is recommended to use dependent test to reduce the effect of confounding factors . 4.3. Confidence interval of variance Confidence interval of variance is used to estimate the population variance from sample data and quantify the related uncertainty. C.I. of variance is seldom used by itself, but rather used in conjunction with f-test , which tests equality of variances of different populations. Similar to how the confidence interval of difference in mean forms the foundation of t-test , C.I. of variance forms the foundation of f-test. In the field of statistics and machine learning, the equality of variance is an important assumption when choosing which technique to use. For example, when comparing the means of two samples, student's t-test should not be used when you have a reason to believe that the two samples have different variances. Personally, I found f-test to be useful for the purpose of reading and understanding scientific papers, as many of the papers I have read use f-test to test their hypothesis, or use a variation of f-test for more advanced techniques. It is a pre-requisite knowledge you need to know to understand the more advanced techniques. I mentioned that different statistics exhibit different distributions above . When a sample data set originates from a normal distribution, its sample means are normally distributed as shown in figure (7) . On the other hand, its sample variances are chi-square ( $\\chi&#94;2$ ) distributed as shown in figure (10) The curve is asymptotic, and never touches the x-axis. The cumulative probabilty, which is often referred to as \"p-value\" in hypothesis testing, propagates from the right (p-value=0) to the left (p-value=1). For example, $\\chi&#94;2_{.975}=2.70$ is in the lower/left-tail and $\\chi&#94;2_{.025} = 19.02$ is in the upper/right-tail. When the samples follow a normal distribution, the $\\chi&#94;2$ statistic values can be plugged into eq (10) to compute the confidence interval of variance. Figure 10: 95% confidence interval of variance. Source Code For Figure (10) from scipy import stats import matplotlib.pyplot as plt import numpy as np df = 9 x = np.linspace(-1, 28, 1000) y = stats.chi2.pdf(x, df, loc=0, scale=1) right_tail = stats.chi2.ppf(1 - 0.025, df) left_tail = stats.chi2.ppf(1 - 0.975, df) plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(figsize=(12, 5)) ax.plot(x, y, c='black', label='Degrees of freedom = %d' % df) ax.set_xlabel('$\\chi&#94;2$', fontsize=17) ax.set_ylabel(r'Probability', fontsize=17) ax.set_title(r'$\\chi&#94;2\\ \\mathrm{Distribution}$, df = %d' % df, fontsize=17) ax.fill_between(x, 0, y, where=(np.array(x) > min(x)) & (np.array(x) <= left_tail), facecolor='grey') ax.fill_between(x, 0, y, where=(np.array(x) > left_tail) & (np.array(x) < right_tail), facecolor='lightgrey') ax.fill_between(x, 0, y, where=(np.array(x) > right_tail) & (np.array(x) <= max(x)), facecolor='grey') ax.grid(False) ax.text(22, 0.008, '2.5% outlier', fontsize=13) ax.text(-2, 0.008, '2.5% outlier', fontsize=13) ax.text(0.5, 0.04, '$\\chi&#94;2_{.975} = %.2f$' % left_tail, fontsize=14, bbox=dict(boxstyle='round', facecolor='white')) ax.text(16.5, 0.015, '$\\chi&#94;2_{.025} = %.2f$' % right_tail, fontsize=14, bbox=dict(boxstyle='round', facecolor='white')) ax.text(20, 0.08, '$\\chi&#94;2_{.975} \\leq \\chi&#94;2 \\leq \\chi&#94;2_{.025}$', fontsize=16) ax.text(20, 0.06, '$2.70 \\leq \\chi&#94;2 \\leq 19.02$', fontsize=16) ax.text(6, 0.05, '95% confidence interval', fontsize=16) ax.text(6, 0.04, 'of variance', fontsize=16); $$ \\text{C.I.}_{\\text{variance}}: \\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{\\frac{\\alpha}{2}, df}} \\leq \\sigma&#94;2 \\leq \\frac{(n-1)s&#94;{2}}{\\chi&#94;{2}_{1-\\frac{\\alpha}{2}, df}} \\tag{10}$$ where $\\sigma&#94;2$ : population variance $s&#94;2$ : sample variance $\\alpha$ : significance level $n$ : number of samples $df$ : degrees of freedom. $\\chi&#94;2$ : chi-squared statistic. Depends on $\\alpha$ and $df$ In confidence interval of variance, the degrees of freedom is: $$df = n - 1$$ Recall that the goal of any confidence interval is to estimate the population parameter from a fraction of its samples due to the high cost of obtaining measurement data of the entire data set, as explained in Population vs Samples. You attempt to estimate the population variance $\\sigma&#94;2$ within the range of uncertainty with the sample variance $s&#94;2$ obtained from a set of n samples that are \"hopefully\" representative of the true population. Confidence interval of variance assumes normality of samples, and is very sensitive to the sample distribution's deviation from normality. In case of non-normal sample distributions, you can either 1) transform the distribution to normal distribution with Box-Cox transformation , or 2) use non-parametric alternatives. For practitioners, I do not recommend 1) unless you really understand what you are doing, as the back transformation process of Box-Cox transformation can be tricky. Furthermore, it doesn't always result in successful transformation of non-normal to normal distribution, as discussed below . I recommend to use 2). If you have non-normal samples and your goal is to compute the C.I. of variance, use bootstrap . If your goal is to check the equality of variances of multiple sample data sets with hypothesis testing, use Levene's test. Both are the non-parametric alternatives that does not require normality of samples. Notes: Chi-square $\\chi&#94;2$ distribution Chi-square $\\chi&#94;2$ distribution is a function of degrees of freedom $df$ . It is a special case of the gamma distribution and is one of the most widely used probability distributions in inferential statistics, notably in hypothesis testing or in construction of confidence intervals. It is used in the common chi-square goodness of fit test of an observed data set to a theoretical one. Let's say that there's a company that prints baseball cards. The company claims that 30% of the cards are rookies, 60% veterans but not All-Stars, and 10% are veteran All-Stars. Suppose that you purchased a deck of 100 cards. You found out that the card deck has 50 rookies, 45 veterans, and 5 All-Stars. Is this consistent with the company's claim? An answer to this question is explained in detail here using the chi-squared goodness of fit test. Note that the chi-square goodness of fit test does NOT require normality of data, but the chi-square test that checks if a variance equals a specified value DOES require normality of data. When samples have a normal distribution, some of their statistics can be described by $\\chi&#94;2$ distributions. For example, the Mahalanobis distance follows $\\chi&#94;2$ distribution when samples are normally distributed, and can be used for multivariate outlier detection using $\\chi&#94;2$ hypothesis test. Variance of samples also follows $\\chi&#94;2$ distributions when samples are normally distributed, and can be used to construct the confidence interval of variances with eq (10) . By the central limit theorem, a $\\chi&#94;2$ distribution converges to a normal distribution for large sample size $n$ . For many practical purposes, for $n$ > 50 the distribution is sufficiently close to a normal distribution for the difference to be ignored. Note that the sampling distribution of $ln(\\chi&#94;2)$ converges to normality much faster than the sampling distribution of $\\chi&#94;2$ as the logarithm removes much of the asymmetry. Source Code For The Figure from scipy import stats import matplotlib.pyplot as plt import numpy as np df_values = [1, 2, 6, 9] linestyles = ['-', '--', ':', '-.'] x = np.linspace(-1, 20, 1000) plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(figsize=(6.6666666, 5)) fig.tight_layout() plt.subplots_adjust(left=0.09, right=0.96, bottom=0.12, top=0.93) for df, ls in zip(df_values, linestyles): ax.plot(x, stats.chi2.pdf(x, df, loc=0, scale=1), ls=ls, c='black', label=r'Degrees of freedom$=%i$' % df) ax.set_xlim(0, 10) ax.set_ylim(0, 0.5) ax.set_xlabel('$\\chi&#94;2$', fontsize=14) ax.set_ylabel(r'Probability', fontsize=14) ax.set_title(r'$\\chi&#94;2\\ \\mathrm{Distribution}$') ax.legend(loc='best', fontsize=11, framealpha=1, frameon=True) Notes: One-tail vs two-tail As you explore more about the field of statistics, you will encounter many scientific papers or articles using mostly upper/right-tailed f-test, instead of two-tailed or lower/left-tailed f-test. Why? That's because they don't have much practical use in real-life. This information is little beyond the scope of this article, but I still want to touch on it because the C.I. of variance forms the foundation of f-test. When it comes to the test of variances, we often want to maintain a low variance than high variance, because the high variance is often related to high risk or instability. We are usually interested in knowing if a target population variance $\\sigma&#94;2$ is lower than a specified value $\\sigma&#94;2_0$ , not the other way around. This can be doen by using the upper/right-tailed hypothesis test, which is shown in the middle plot below. If the calculated statistic for f-test falls within the dark grey area, you reject your null hypothesis $H_0$ , and accept the alternate hypothesis $H_a$ Source Code For The Figure from scipy import stats import matplotlib.pyplot as plt import numpy as np df = 9 x = np.linspace(-1, 28, 1000) y = stats.chi2.pdf(x, df, loc=0, scale=1) # two-tailed two_right_tail = stats.chi2.ppf(1 - 0.025, df) two_left_tail = stats.chi2.ppf(1 - 0.975, df) # one tailed one_right_tail = stats.chi2.ppf(1 - 0.05, df) one_left_tail = stats.chi2.ppf(1 - 0.95, df) plt.style.use('seaborn-whitegrid') fig, axes = plt.subplots(1, 3, figsize=(12, 3)) for ax in axes: ax.plot(x, y, c='black') ax.grid(False) ax.xaxis.set_major_formatter(plt.NullFormatter()) ax.yaxis.set_major_formatter(plt.NullFormatter()) axes[0].fill_between(x, 0, y, where=(np.array(x) > min(x)) & (np.array(x) <= two_left_tail), facecolor='grey') axes[0].fill_between(x, 0, y, where=(np.array(x) > two_left_tail) & (np.array(x) < two_right_tail), facecolor='lightgrey') axes[0].fill_between(x, 0, y, where=(np.array(x) > two_right_tail) & (np.array(x) <= max(x)), facecolor='grey') axes[0].set_title('Two-tailed', fontsize=20) axes[0].text(14, 0.08, r'$H_0: \\sigma&#94;2 = \\sigma_0&#94;2$', fontsize=20) axes[0].text(14, 0.057, r'$H_a: \\sigma&#94;2 \\neq \\sigma_0&#94;2$', fontsize=20) axes[1].fill_between(x, 0, y, where=(np.array(x) > min(x)) & (np.array(x) < one_right_tail), facecolor='lightgrey') axes[1].fill_between(x, 0, y, where=(np.array(x) > one_right_tail) & (np.array(x) <= max(x)), facecolor='grey') axes[1].set_title('Upper/right-tailed', fontsize=20) axes[1].text(14, 0.08, r'$H_0: \\sigma&#94;2 \\leq \\sigma_0&#94;2$', fontsize=20) axes[1].text(14, 0.057, r'$H_a: \\sigma&#94;2 > \\sigma_0&#94;2$', fontsize=20) axes[2].fill_between(x, 0, y, where=(np.array(x) > min(x)) & (np.array(x) <= one_left_tail), facecolor='grey') axes[2].fill_between(x, 0, y, where=(np.array(x) > one_left_tail) & (np.array(x) <= max(x)), facecolor='lightgrey') axes[2].set_title('Lower/left-tailed', fontsize=20) axes[2].text(14, 0.08, r'$H_0: \\sigma&#94;2 \\geq \\sigma_0&#94;2$', fontsize=20) axes[2].text(14, 0.057, r'$H_a: \\sigma&#94;2 < \\sigma_0&#94;2$', fontsize=20) fig.tight_layout() Pythonic Tip: Computing confidence interval of variance Unfortunately, there's no Python or R library that computes the confidence interval of variance. The fact that the pre-built function does not exist both in Python and R suggests that the C.I. of variance is seldom used. But as I mentioned before, the reason that I introduce the C.I. of variance is because it forms the foundation of f-test, a statistical hypothesis test that is widely used in scientific papers. The C.I. of variance can be manually computed with eq (10) . Don't forget to compute sample variance, instead of population variance by setting ddof=1 as explained above . In [5]: from scipy import stats import numpy as np In [6]: arr = [ 8.69 , 8.15 , 9.25 , 9.45 , 8.96 , 8.65 , 8.43 , 8.79 , 8.63 ] alpha = 0.05 # significance level = 5% n = len ( arr ) # sample sizes s2 = np . var ( arr , ddof = 1 ) # sample variance df = n - 1 # degrees of freedom upper = ( n - 1 ) * s2 / stats . chi2 . ppf ( alpha / 2 , df ) lower = ( n - 1 ) * s2 / stats . chi2 . ppf ( 1 - alpha / 2 , df ) In [7]: ( lower , upper ) Out[7]: (0.07238029119542731, 0.5822533618682987) The output suggests that the 95% confidence interval of variance is — $\\text{C.I.}_{variance}: \\,\\, 0.072 < \\sigma&#94;2 < 0.582$ 4.4. Confidence interval of other statistics: Bootstrap (Note: For those people who have web-development experience, this is not CSS Bootstrap .) I mentioned that different formulas are used to construct confidence intervals of different statistics above. There are three problems with computing the confidence interval of statistics with analytical solutions: Not all statistics have formulas for their confidence intervals Their formulas can be so convoluted, that it may be better to use numerical alternatives You have to memorize their formulas Bootstrapping is nice because it allows you to avoid these practical concerns. For example, there are no formulas to compute the confidence interval of covariance and median. On the other hand, regression coefficient has its own formula for its confidence interval, but the formulas get really messy in cases of multi-linear or non-linear regression. Wouldn't it be nice if there's a \"magic\" that saves you from all the math you have to worry about? Bootstrapping is a statistical method for estimating the sampling distribution of a statistic by sampling with replacement from the original sample, most often with the purpose of estimating confidence intervals of a population parameter like a mean, median, proportion, correlation coefficient or regression coefficient. Bootstrap can construct confidence intervals of any statistics when combined with Monte Carlo method . The process is visually shown in fig (?) . Initially you have 5 samples $[8, 5, 4, 6, 2]$ that you collected from an unknown population. You randomly draw $n=5$ samples from the original sample pool WITH REPLACEMENT, and they become your single bootstrap sample . You repeat this process $r=6$ times to collect multiple bootstrap samples . For each bootstrap sample, you run your functions to compute the statistic of your interest: in this case, np.mean(single_boot) . Now you have $r=6$ sample means obtained from $r$ bootstrap samples. You can construct 95% confidence interval of mean with percentile method: np.percentile(mutliple_boot_means, 97.5) , np.percentile(mutliple_boot_means, 2.5) Note that the bootstraped samples will contain duplicate elements a lot, due to random sampling WITH REPLACEMENT. This causes problems with bootstrapping regression models, as explained below . Figure 11: Bootstrap 95% confidence interval of mean. Source Code For Figure (11) import matplotlib.pyplot as plt import numpy as np np.random.seed(42) arr = [8, 5, 4, 6, 2] ####################### Bootstrap ####################### num_boot_samples = 1000 def estimator(l): # statistic of interest; Ex: mean, median, variance ... return np.mean(l) boot = [estimator(np.random.choice(arr, len(arr))) for _ in range(num_boot_samples)] ######################################################### plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(figsize=(10, 4)) returns = ax.boxplot(boot, widths=0.5, whis=[2.5, 97.5], showfliers=False, patch_artist=True, boxprops=dict(linewidth=3.0, color='grey'), whiskerprops=dict(linewidth=3.0, color='grey'), vert=False, capprops=dict(linewidth=2.0, color='grey'), medianprops=dict(linewidth=2.0, color='yellow')) ax.set_aspect(1) #ax.set_ylim(1.5, -.5) ax.set_xlabel(r'$\\bar{X}$', fontsize=20) ax.yaxis.set_major_formatter(plt.NullFormatter()) ax.set_title('Bootstrap 95% confidence interval of mean', fontsize=20) ax.scatter(arr, [1, 1, 1, 1, 1], facecolors='grey', edgecolors='k', zorder=10, label='Original Samples', s=100) ax.legend(fontsize=15, fancybox=True, framealpha=1, shadow=True, borderpad=0.5, frameon=True); Notes: Monte-Carlo method During your study of statistics, there's a good chance that you've heard of the word, \"Monte-Carlo\". It refers to the process that relies on repeated generation of random numbers to investigate some characteristic of a statistic which is hard to derive analytically. The process is composed of mainly two parts: random number generator, and for-loop. The random number generator can be parametric, or non-parametric. In case of parametric simulation, you must have some previous knowledge about the population of your interest, such as its shape. In the below code snippet, you assume that the sample is from a specific distribution: normal , lognormal , chisquare . Then, you repeatedly randomly draw samples from the pre-defined distribution with a for-loop: Parametric Monte-Carlo simulation # random number generator = normal distribution sim_1 = [np.random.normal(np.mean(sample), np.mean(sample)) for _ in range(iterations)] # random number generator = lognormal distribution sim_2 = [np.random.lognormal(np.mean(sample), np.mean(sample)) for _ in range(iterations)] # random number generator = chi-square distribution sim_3 = [np.random.chisquare(len(sample)) for _ in range(iterations)] In case of non-parametric simulation, the random number generator does not assume anything about the shape of the population. Non-parmetric bootstrap would be the choice of your random number generator in this case (Note: some variations of bootstrap are parametric): Non-Parametric Monte-Carlo simulation # random number generator = non-parametric bootstrap sim_4 = [np.random.choice(original_sample) for _ in range(iterations)] You can create multiple instances of sim_n objects above to experiment with your data set; you use Monte-Carlo simulations to produce hundreds or thousands of \"possible outcomes\" . The results are analyzed to get probabilities of different outcomes occuring. The application of Monte-Carlo method includes constructing confidence interval of statistics with Bootstrap shown in figure (11) , and profit modeling of casino dice roll games . Why does bootstrapping work? (Before you read this section, make sure you understand the difference between Population vs Samples. ) Practitioners wonder WHY bootstrapping works: why is it that resampling the same sample over and over gives good results? If we are resampling from our sample, how is it that we are learning something about the population rather than only about the sample? There seems to be a leap which is somewhat counter-intuitive. The idea comes from the assumption that the sample is a reasonable representation of its underlying population — the population is to the sample as the sample is to the bootstrap samples. You want to ask question of a population, but you can't because you lack the resources to get measurement data of all possible data points. So you take a fraction of the population, a.k.a the sample, and ask the question of it instead. Now, how confident you should be that the sample answer is close to the population answer depends on how well the sample represents the underlying population. One way you might learn about this is to take samples from different portions of the population again and again. You ask the same question to the multiple samples you collected, and see the variability of the different sample answers to quantify the related uncertainty of your estimation. When this is not possible due to practical limitations, you make some assumptions about the population (ex: population is normally distributed), or use the information in the collected sample to learn about the population. In bootstrapping, you treat the original sample (size=$n$) you randomly acquired from the population as if it's the population itself of size $n$. From the original sample that you treated to be the population, you randomly draw samples, each of size $n$, with replacement multiple times to simulate direct sampling from the original population. By doing so, you essentially imitate sampling different portions of the original population multiple times. This idea is shown in figure (12) . This is a reasonable thing to do for two reasons. First, the sample in your had is the best you've got, indeed the only informatoin you have about the population. Second, if the original sample is randomly chosen, it will look like the original population they came from. This means that the sample is a good representation of its underlying population. However, if its not a good representation of the population, bootstrap fails. In fact, there's not much you can do in the first place if your sample is biased. Figure 12: Intuitive idea behind Bootstrapping Assumptions and Limitations of Bootstrap Bootstrapping is great because it saves you from the normality assumption of distributions and all the math you have to know to construct confidence intervals. However, just like many other techniques, bootstrap has its own caveats. While bootstrap is distribution-free, it is not assumption-free. The assumptions are listed in this section. Please note that there is a humongous variety of the bootstrap procedures, each addressing the particular quirk in either the statistic, the sample size, the dependence, or whatever an issue with the bootstrap could be. I am not introducing all of them here as the in-depth technical discussion of bootstrap needs another devoted post, but I still want you to know some of the critical assumptions; I want you to know what you don't know, so that you can google later to learn in-depth. A sample is a good representation of its underlying population The fundamental principle of bootstrapping is that the original sample is a good representation of its underlying population. Bootstrapping resamples from the original samples. This means that if the original sample is biased, the resulting bootstrap samples will also be biased. However, this is a problem of not just bootstrapping, but all statistical techniques. There's not much you can do if the only piece of information you have about the population is corrupted, after all. Insufficient samples make the bootstrap C.I. to be narrower than the analytical C.I. There's a myth in the field of statistics that bootstrap is a \"cure\" for small sample size. NO, it's not. First, if you have too small sample, by a high chance it is not diverse enough to represent all (reasonably) possible aspects of its population. Therefore, it is not a good representation of its population. Second, small sample size makes its bootstrap C.I. to be narrower than the analytical C.I.. This means that bootstrap C.I. reports small uncertainty even when the sample size is small. Not only this is counter-intuitive, but also it is a violation of the mathematic property of C.I. described by eq (1) ; small sample size $n$ in the denominator of eq (1) should give wider C.I.. But this is not true with bootstrap C.I. as shown in the below simulation result in figure (13) . Three things to note in the figure. First, the upper & lower error bars of bootstrap C.I. of means are asymmetric. This is because bootstrap C.I. is not based on $\\pm$ standard error method. This is a very useful property to estimate the central tendency of asymmetric (skewed) populations. Second, both bootstrap and analytical C.I. become narrower with the increasing sample size. This intuitively and mathematically makes sense. Third, bootstap C.I. approximates the analytical C.I. very well with large sample size. This is perhaps the most important advantage of using bootstrap. If you have large sample size, you really don't have to worry anything else (except the indepence of samples), and just stick to bootstrap . All the disadvantages of bootstrap will be overcome by the large sample size. One might wonder what is \"large\" enough in practical applications. Unfortunately, the definition of \"large\" is different for every applications. In the simulation result of figure (13) , it seems that $n = 20$ falls in the category of \"large\" to approximate C.I. of the mean of a normally distributed population with bootstrap. On the other hand, $n=100$ seems to be \"large\" in case of C.I. of the variances of a normally distributed population. The definition of \"large $n$\" can vary with different applications (ex: non-normal data, C.I. of regression coefficient or covariance). Carefully investigate your samples to have a good definition of \"large\" . Figure 13: Comparison of Bootstrap vs Analytical C.I. for different sample sizes Source Code For Figure (13) import matplotlib.pyplot as plt import numpy as np from scipy import stats sample_sizes = [3, 5, 8, 10, 15, 20, 30, 50, 80, 100, 500, 1000] mean = 4 # sample mean std = 3 # sample standard deviation boot_iter = 10000 # bootstrap iterations boot_mean_lo = np.array([]) boot_mean_hi = np.array([]) analy_mean_lo = np.array([]) analy_mean_hi = np.array([]) boot_var_lo = np.array([]) boot_var_hi = np.array([]) analy_var_lo = np.array([]) analy_var_hi = np.array([]) means = np.array([]) variances = np.array([]) for size in sample_sizes: np.random.seed(size * 5) arr = np.random.normal(mean, std, size) # randomly draw from a normal distribution # analytical confidence interval of mean means = np.append(means, np.mean(arr)) analy_conf_mean = stats.t.interval(1 - 0.05, len(arr) - 1, loc=np.mean(arr), scale=stats.sem(arr)) analy_mean_lo = np.append(analy_mean_lo, analy_conf_mean[0]) analy_mean_hi = np.append(analy_mean_hi, analy_conf_mean[1]) # bootstrap confidence interval of mean boot_means = [np.mean(np.random.choice(arr, len(arr))) for _ in range(boot_iter)] boot_mean_lo = np.append(boot_mean_lo, np.percentile(boot_means, 2.5)) boot_mean_hi = np.append(boot_mean_hi, np.percentile(boot_means, 97.5)) # analytical confidence interval of variance variances = np.append(variances, np.var(arr, ddof=1)) analy_conf_var = ( (len(arr) - 1) * np.var(arr, ddof=1) / stats.chi2.ppf(1 - 0.05 / 2, len(arr) - 1), (len(arr) - 1) * np.var(arr, ddof=1) / stats.chi2.ppf(0.05 / 2, len(arr) - 1) ) analy_var_lo = np.append(analy_var_lo, analy_conf_var[0]) analy_var_hi = np.append(analy_var_hi, analy_conf_var[1]) # bootstrap confidence interval of variance boot_vars = [np.var(np.random.choice(arr, len(arr)), ddof=1) for _ in range(boot_iter)] boot_var_lo = np.append(boot_var_lo, np.percentile(boot_vars, 2.5)) boot_var_hi = np.append(boot_var_hi, np.percentile(boot_vars, 97.5)) # plotting def styling(ax, xticks, xticklables): ax.legend(fontsize=14, loc='lower right', framealpha=1, frameon=True) ax.set_xlabel('Sample sizes', fontsize=16) ax.set_facecolor('#eeeeee') ax.grid(True, linestyle='--', color='#acacac') ax.tick_params(color='grey') ax.set_xticks(xticks) ax.set_xticklabels([str(label) for label in xticklables]) _ = [spine.set_edgecolor('grey') for spine in ax.spines.values()] x = np.array([i for i in range(len(sample_sizes))]) fig, axes = plt.subplots(1, 2, figsize=(14, 5)) axes[0].errorbar(x - 0.15, means, yerr=[abs(boot_mean_lo - means), abs(boot_mean_hi - means)], fmt='o', label='95% bootstrap C.I.', color='k', markersize=8, capsize=5, linewidth=2) axes[0].errorbar(x + 0.15, means, yerr=np.array([abs(analy_mean_hi - means), abs(analy_mean_lo - means)]), fmt='o', label='95% analytical C.I.', color='grey', markersize=8, capsize=5, linewidth=2) styling(axes[0], x, sample_sizes) axes[0].set_ylabel('Sample mean', fontsize=16) axes[0].set_title('Confidence interval of means $\\mu$', fontsize=18) axes[0].text(0.75, 0.85, 'aegis4048.github.io', fontsize=15, ha='center', va='center', transform=axes[0].transAxes, color='grey', alpha=0.5); axes[1].errorbar(x - 0.15, means, yerr=[abs(boot_var_lo - variances), abs(boot_var_hi - variances)], fmt='o', label='95% bootstrap C.I.', color='k', markersize=8, capsize=5, linewidth=2) axes[1].errorbar(x + 0.15, means, yerr=np.array([abs(analy_var_hi - variances), abs(analy_var_lo - variances)]), fmt='o', label='95% analytical C.I.', color='grey', markersize=8, capsize=5, linewidth=2) styling(axes[1], x, sample_sizes) axes[1].set_ylabel('Sample variance', fontsize=16) axes[1].set_title('Confidence interval of variances $\\sigma&#94;2$', fontsize=18) axes[1].text(0.75, 0.35, 'aegis4048.github.io', fontsize=15, ha='center', va='center', transform=axes[1].transAxes, color='grey', alpha=0.5); fig.tight_layout() Bootstrap fails to estimate extreme quantiles Bootstrap fails to estimate some really weird statistics that depend on very small features of the data. For example, using bootstrapping to determine anything close to extreme values (ex: min, max) of a distribution can be unreliable. There are also problems with estimating extreme quantiles, like 1% or 99%. Note that bootstrapped 95% or 99% CI are themselves at tails of a distribution, and thus could suffer from such a problem, particularly with small sample sizes. Bootstrap works better in the middle of a distribution than at the tails, which makes bootstrapping the median to be robust, whereas bootstrapping the min or max to fail. Samples are independent and identically distributed (i.i.d.) Another central issue with bootrapping is, \"does the resampling procedure preserve the structure of the original sample?\" The greatest problem with bootstrapping dependent data is to create samples that have the dependence structures that are sufficiently close to those in the original data. Because it is impossible to preserve it with the naive bootstrap, a sample needs to be i.i.d. This assumption raises a few practical issues when dealing with time series. First, by randomly sampling without constraints, naive bootstrap destroys the time-dependence structure in time series. In time series, all data points are aligned with respect to time, but random resampling does not respect their orders. Second, if there's an upward or downward trend in the means or variances, the trend will be lost due to random resampling. Third, because time series is essentially continuous samples of size 1 for each point in time, resampling a sample is equivalent to the original samples; one learns nothing by resampling. Therefore, resampling of a time series requires new ideas, such as block bootstrapping. There are a few variations of bootstrap that attemtp to preserve the dependency structure of samples, which I will not introduce here due to their mathematical complexities. When using tehchniques based on random sampling, ensure that the samples are i.i.d., or use techniques that preserve (reasonably) the structure of the original data. Bootstrap iteration ( Monte-Carlo method ) should be sufficient to reproduce consistent C.I's. Because bootstrap relies on \"random\" resampling, the result of any statistical analysis performed with bootstrap can vary from time to time. The extent of variability depends on the number of bootstrap samples $r$, and $r$ should be large enough to guarantee convergence of bootstrap statistics to a stable value. Note that there's a distinction between the size of the original sample $n$ and the number of bootstrap samples $r$. We can't change $n$, but we can change $r$ because $r$ is equivalent to the number of Monte-Carlo iterations, which can be set by a statistician. So how do we determine what value of $r$ is \"large\" enough to guarantee convergence of bootstrap statistics? You can do it by obtaining multiple bootstrap analysis results for increasing number of simulations $r$, and see if the result converges to certain range of values, as shown in figure (15) . In the figure, it seems that $r=10,000$ is a good choice. But in practice, you want $r$ to be as large as possible, to an extent where the computational cost is not too huge. I've read a research paper where the authors used $r = 500,000$ to really ensure convergence. Figure 14: Convergence of Bootstrap C.I. Source Code For Figure (14) import matplotlib.pyplot as plt import numpy as np from scipy import stats import pandas as pd # r, or number of bootstrap samples, or number of Monte-Carlo iterations r_boots = [10, 20, 50, 70, 100, 150, 300, 500, 700, 1000, 2000, 10000, 20000, 50000, 100000] size = 50 # original sample size mean = 50 # sample mean std = 13 # sample standard deviation # randomly draw from a normal distribution arr = np.random.normal(mean, std, size) boot_mean_lo = np.array([]) boot_mean_hi = np.array([]) results = [] for r_boot in r_boots: np.random.seed(r_boot) boot_means = [np.mean(np.random.choice(arr, len(arr))) for _ in range(r_boot)] results.append(boot_means) # plotting fig, ax = plt.subplots(figsize=(8, 4)) ax.boxplot(results, sym='', whis=[2.5, 97.5], showfliers=False, boxprops=dict(linewidth=2.0, color='#4e98c3'), whiskerprops=dict(linewidth=2.0, color='#4e98c3', linestyle='--'), vert=True, capprops=dict(linewidth=2.0, color='k'), medianprops=dict(linewidth=2.0, color='#ad203e')) ax.set_title('Convergence of 95% Bootstrap C.I. with increasing Monte-Carlo iterations', fontsize=15) ax.set_ylabel('Sample mean', fontsize=15) ax.set_xlabel('# of bootstrap samples (Monte-Carlo iterations)', fontsize=15) ax.set_xticklabels([str(r_boot) for r_boot in r_boots], rotation=45) ax.set_ylim(41.7, 52.3) ax.set_facecolor('#eeeeee') ax.grid(True, linestyle='--', color='#acacac') ax.tick_params(color='grey') _ = [spine.set_edgecolor('grey') for spine in ax.spines.values()] ax.text(0.21, 0.1, 'aegis4048.github.io', fontsize=15, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5); Coverage of naive bootstrap is relatively weak compared to more robust bootstrap methods The term, coverage , means the chance at which the statistical estimation with uncertainty includes the population parameter. Ideally, this coverage rate should be close to the nominal value set by a statistician (ex: 90%, 95%, 99%), but this is not always the case. We call the difference between the inferencial sample statistic and the population statistic as bias . Certain statistics, in certain situations, are biased: no matter how many experiments we perform, the average of the statistics is systematically off, either above or below the population value. For example, the sample median is biased when the original sample size $n$ is small, and we sample from skewed distributions. Variations of bootstrapping, such as the Bias Corrected (BC), and Bias Corrected & Accelerated (BCa) attempt to minimize the sampling bias. Bootstrapping continuous data is a bit tricky The biggest motivation for bootstrapping continuous data would be to acquire uncertainty of a fitted regression model. In regression problems, we assume the data points to be continuous. Bootstrapping makes this a little weird when the dependent variable ($y$) is continuous, because the original populatoin does not have even one exact duplicate, while bootstrap samples are likely to have many exact duplicates. Moreover, the range of independent variables ($x$ in single-regession, $x_1, x_2, ... , x_n$ in multi-regression) changes for each bootstrap sample due to randomness. Since the range of the independent variables defines the amount information available, bootstrapping will lose some of the information in the data. In such cases, alternatives like residual bootstrap (assumes homoscedasticity, or stationary varianace) or wild bootstrap (works for heteroscedasticity, or non-stationary varianace) may be used. Unfortunately, the procedure for these alternatives are very complicated, and they are not implemented in Python . To my knowledge, they are implemented in R though. Bootstrap is not robust in heavy-tailed distributions (This section assumes that you understand the caveats of heavy-tailed distributions) Heavy-tailed distributions have a few extreme values (NOT outliers) that are very different from the most of the samples. These extreme values have non-negligible impact on statistical estimations from samples, because the samples are not likely to contain them due to their low chance of occurrence. This violates the first assumption of bootstrapping I explained above , because the sample is NOT a good representation of its underlying population. Since bootstrapping heavily depends on the quality of the original sample, it is not robust for distributions with heavy tails. It will require extremely large size of the original sample to overcome such problems. Investigate the distribution shape of the population of your interest, and decide if that particular distribution shape will cause problems with heavy-tailedness. For example, exponential distribution is heavier-tailed than normal distribution, but it is not heavy enough to cause problems. Pareto (infinite variance, infinite mean), t-distribution with df = 2 and Cauchy (infinite variance, finite mean) are highly problematic category of distributions. Log-normal distribution has finite variance, so it is theoretically OK, but it can sometimes be heavy tailed enough that the population mean will almost always exceed all of your sample means, which can make inference via a bootstrap tricky. Note that the population mean for lognnormal will not be lower than the sample mean, as the low-occurrence extreme values are on the right tail of the distribution. Pythonic Tip: Bootstrapping in Python Basic bootstrap Bootstrap by itself means resampling from a sample. In its simplest form, it can be implemented in just one-line code with np.random.choice . For demonstration, assume that the original sample of size n=500 was randomly drawn from a normal distribution. In [9]: import numpy as np import pandas as pd In [10]: # prepare original sample data np . random . seed ( 42 ) n = 500 arr = np . random . normal ( loc = 0.15 , scale = 0.022 , size = n ) In [11]: # single bootstrapping single_boot = np . random . choice ( arr , len ( arr )) Basic bootstrap with Monte-Carlo method Bootstrap is often combined with Monte-Carlo method to quantify uncertainty in statistics (ex: mean, median, variance, etc...). It just means that you generate multiple instances of the single_boot object above. In [12]: # 100 monte-carlo bootstrapping r = 1000 monte_boot = [ np . random . choice ( arr , len ( arr )) for _ in range ( r )] With the above simulation, we stored r=1000 instances of bootstrap samples in the object monte_boot . It is a two dimensional array of size $r$ x $n$ (1000 x 500). I will show only the first 10 bootstrap samples with the Pandas DataFrame, since it will be too lengthy if I output all 1000 rows. In [13]: pd . DataFrame ( monte_boot , index = [ 'boot % s ' % str ( i ) for i in range ( r )]) . head ( 10 ) . round ( 3 ) Out[13]: 0 1 2 3 4 5 6 7 8 9 ... 490 491 492 493 494 495 496 497 498 499 boot 0 0.109 0.121 0.174 0.135 0.165 0.150 0.120 0.155 0.159 0.142 ... 0.157 0.158 0.128 0.134 0.129 0.152 0.163 0.140 0.158 0.127 boot 1 0.115 0.155 0.134 0.156 0.151 0.151 0.128 0.132 0.165 0.146 ... 0.127 0.144 0.129 0.140 0.169 0.160 0.164 0.147 0.167 0.122 boot 2 0.168 0.198 0.129 0.133 0.153 0.197 0.145 0.121 0.165 0.161 ... 0.108 0.149 0.147 0.140 0.175 0.180 0.118 0.139 0.176 0.145 boot 3 0.129 0.160 0.145 0.139 0.123 0.138 0.127 0.152 0.197 0.146 ... 0.173 0.120 0.191 0.133 0.173 0.119 0.167 0.160 0.158 0.150 boot 4 0.124 0.148 0.171 0.150 0.150 0.157 0.141 0.163 0.164 0.158 ... 0.121 0.150 0.170 0.152 0.161 0.235 0.146 0.140 0.160 0.122 boot 5 0.139 0.127 0.105 0.152 0.146 0.133 0.134 0.107 0.179 0.145 ... 0.146 0.134 0.156 0.157 0.159 0.127 0.132 0.111 0.103 0.183 boot 6 0.182 0.164 0.168 0.157 0.196 0.131 0.133 0.171 0.158 0.142 ... 0.166 0.124 0.185 0.164 0.133 0.160 0.156 0.109 0.151 0.167 boot 7 0.195 0.160 0.130 0.175 0.115 0.135 0.150 0.173 0.149 0.185 ... 0.153 0.122 0.145 0.163 0.149 0.155 0.136 0.149 0.138 0.137 boot 8 0.124 0.164 0.132 0.126 0.158 0.168 0.150 0.156 0.156 0.126 ... 0.127 0.117 0.115 0.140 0.132 0.132 0.127 0.133 0.160 0.154 boot 9 0.157 0.143 0.157 0.143 0.156 0.178 0.161 0.198 0.197 0.134 ... 0.184 0.197 0.157 0.147 0.161 0.119 0.135 0.124 0.119 0.109 10 rows × 500 columns Let's visualize the results in Matplotlib to understand Monte-Carlo simulations applied with bootstrap more intuitively. Recall that the goal of Monte-Carlo method is to simulate hundreds or thousands of \"possible outcomes\". Each line in the right plot below represents a single possible outcome. Figure 15: 1000 Bootstrap simulations Source Code For Figure (15) import numpy as np import matplotlib.pyplot as plt np.random.seed(42) n = 500 arr = np.random.normal(loc=0.15, scale=0.022, size=n) r = 1000 monte_boot = [np.random.choice(arr, len(arr)) for _ in range(r)] fig, axes = plt.subplots(1, 2, figsize=(14, 4)) axes[0].hist(arr, bins='auto', range=(min(arr), max(arr)), histtype='step', density=True) for boot in monte_boot: axes[1].hist(boot, bins='auto', range=(min(boot), max(boot)), histtype='step', density=True) for ax in axes: ax.grid(True, linestyle='--', color='#acacac') ax.set_ylabel('Probability', fontsize=15) ax.set_xlabel('$X$', fontsize=15) axes[0].set_title('Original sample', fontsize=15) axes[1].set_title('% s bootstrap samples' % r, fontsize=15) fig.tight_layout() Basic bootstrap with Monte-Carlo method + constructing confidence intervals We then analyze the simulation result to do whatever statistical estimation we want to do. Since this article is about confidence intervals, I will show how to construct confidence intervals of various statistics with bootstrap percentile method. It's actually very simple to implement. Just wrap your single bootstrap sample with a function that calculates the statistic of your interest. The result is an array of statistics of 1000 sample sets. In the other words, thousand data points of the statistics. In [5]: from scipy import stats import numpy as np # 100 monte-carlo bootstrapping r = 1000 monte_boot_mean = [ np . mean ( np . random . choice ( arr , len ( arr ))) for _ in range ( r )] monte_boot_median = [ np . median ( np . random . choice ( arr , len ( arr ))) for _ in range ( r )] monte_boot_std = [ np . std ( np . random . choice ( arr , len ( arr )), ddof = 1 ) for _ in range ( r )] monte_boot_skew = [ stats . skew ( np . random . choice ( arr , len ( arr ))) for _ in range ( r )] monte_boot_kurtosis = [ stats . kurtosis ( np . random . choice ( arr , len ( arr ))) for _ in range ( r )] In [6]: len ( monte_boot_mean ) Out[6]: 1000 If the statistic of your interest does not have a library function, you can define your own function, and wrap the bootstrap sample with it. In [7]: def custom_stats ( arr ): return sum ( arr ) / len ( arr ) + 0.002 In [8]: monte_boot_custom = [ custom_stats ( np . random . choice ( arr , len ( arr ))) for _ in range ( r )] Let's visualize the 95% confidence interval of various statistics obtained from Monte-Carlo bootstrap. Note that statistics like median, skew, kurtosis do not have analytical solutions to construct C.I., and can only be constructed from numerical methods like Monte-Carlo bootstrap (which makes bootstrap very powerful). Figure 16: Uncertainty models obtained from Monte-Carlo bootstrap Source Code For Figure (16) from scipy import stats import matplotlib.pyplot as plt import numpy as np # generate original sample np.random.seed(42) n = 500 arr = np.random.normal(loc=0.15, scale=0.022, size=n) # 100 monte-carlo bootstrapping r = 1000 monte_boot_mean = [np.mean(np.random.choice(arr, len(arr))) for _ in range(r)] monte_boot_median = [np.median(np.random.choice(arr, len(arr))) for _ in range(r)] monte_boot_std = [np.std(np.random.choice(arr, len(arr)), ddof=1) for _ in range(r)] monte_boot_skew = [stats.skew(np.random.choice(arr, len(arr))) for _ in range(r)] monte_boot_kurtosis = [stats.kurtosis(np.random.choice(arr, len(arr))) for _ in range(r)] def custom_stats(arr): return sum(arr) / len(arr) + 0.002 monte_boot_custom = [custom_stats(np.random.choice(arr, len(arr))) for _ in range(r)] # plotting styling = {'sym': '', 'whis': [2.5, 97.5], 'showfliers': False, 'vert': True, 'boxprops': dict(linewidth=2.0, color='#4e98c3'), 'whiskerprops': dict(linewidth=2.0, color='#4e98c3', linestyle='--'), 'capprops': dict(linewidth=2.0, color='k'), 'medianprops': dict(linewidth=2.0, color='#ad203e') } fig, axes = plt.subplots(1, 2, figsize=(14, 4)) axes[0].boxplot([monte_boot_mean, monte_boot_median, monte_boot_custom], **styling) axes[1].boxplot([monte_boot_std, monte_boot_skew, monte_boot_kurtosis], **styling) axes[0].set_xticklabels(['Mean', 'Median', '\"Custom\"'], fontsize=20) axes[1].set_xticklabels(['Stdev', 'Skew', 'Kurtosis'], fontsize=20) for ax in axes: ax.set_facecolor('#eeeeee') ax.grid(True, linestyle='--', color='#acacac') ax.text(0.25, 0.85, 'aegis4048.github.io', fontsize=17, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5); fig.tight_layout(rect=[0, 0.03, 1, 0.92]) fig.suptitle('Monte-Carlo bootstrap uncertainty modeling', fontsize=25) 5. Confidence interval of non-normal distribution One of the biggest assumptions in the field of statistics is the assumption of normality . It is important because of the two key characteristics of normal distribution: symmetry (low skew) and light/short-tails (low kurtosis). Symmetry is important because many statistical techniques use $\\pm$ standard error methods that assume equal properties from both sides of a distribution. On the other hand, heavy-tailedness is detrimental in inferencing population parameters because heavy tailed distributions (ex: log-normal distribution, cauchy distribution) have non-negligible number of extreme data points that may introduce bias in your samples (understanding the impact of heavy-tailedness is very important in inferencial statistics. Make sure you understand the issues of it by reading below ). As I mentioned in the Key Takeaway 4 & 8 above, constructing confidence intervals are very different when data is not normally distributed. This section explains the reasons why they are different, and their non-parametric alternatives. 5.1 Problems of non-normal distributions and central tendency When reporting a summary of a sample data, statisticians tend to report the mean (average) of a sample. But have you wondered why they bother specifically about the means? Often times the ultimate goal is NOT to compute a mean of a distribution, but to compute a measure of central tendency of a distribution. A measure of central tendency is a single value that attempts to describe a set of data by identifying the central position within that set of data. The mean is the measure of central tendency that you are the most familiar with, but there are others, such as the median and the mode. However, mean is not a good measure of central tendency when there is a sign of deviation from normality, which can be characterized by skewness (asymmetry) and kutrosis (heavy-tails). Problems with Skewness (asymmetry) Figure (17) below shows the effectiveness of mean, median, and mode as a measure of central tendency for different skewness. For normal distribution (a), most samples are found at the middle, and they are symmetrically distributed around the mean. This makes the mean as a good measure of central tendency. However, in asymmetrical distributions like (b) and (c), the median (or arguably the mode) is a better choice of central tendency, as it is closer to the central location of the distribution than the mean does. Naively reporting the mean as a summary of data results in misinterpretation of the central location of population. Note that some parametric techniques that assume normality of data are robust to mild skewness. There are many parametric alternatives that account for skewness, such as skewness-adjusted t-test and Box-Cox transformation. More discussion of robustness of parametric techinques relative to skewness is done below . Figure 17: Central tendency of distributions Source Code For Figure (17) from scipy import stats import matplotlib.pyplot as plt import numpy as np np.random.seed(42) y_norm = stats.norm.rvs(size=1000) y_expon = stats.expon.rvs(size=1000) y_skewnorm = stats.skewnorm.rvs(a=10, size=1000) plt.style.use('seaborn-whitegrid') fig, axes = plt.subplots(1, 3, figsize=(13, 3)) axes[0].set_title('Normal distribution', fontsize=20) axes[1].set_title('Skewed distribution', fontsize=20) axes[2].set_title('Exponential distribution', fontsize=20) adjust = 0.12 for ax, y, label in zip(axes, [y_norm, y_skewnorm, y_expon], ['(a)', '(b)', '(c)']): ax.grid(True, linestyle='--', color='#acacac') n, bins, patches = ax.hist(y, bins='auto', histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) ax.axvline(np.mean(y) + adjust, color='k', label='Mean', linestyle='-', alpha=0.9) ax.axvline(np.median(y) + adjust, color='k', label='Median', linestyle='--', alpha=0.9) ax.axvline(bins[np.where(n == max(n))[0][0]] + adjust, color='k', label='Mode', linestyle=':', alpha=0.9) ax.xaxis.set_major_formatter(plt.NullFormatter()) ax.yaxis.set_major_formatter(plt.NullFormatter()) ax.text(0.9, 0.4, label, fontsize=20, ha='center', va='center', transform=ax.transAxes) ax.text(0.75, 0.15, 'aegis4048.github.io', fontsize=13, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) ax.legend(loc='upper right', framealpha=1, frameon=True) fig.tight_layout() Problems with kurtosis (heavy-tails) (Note that heavy-, long-, fat-tails are all synonyms. Some literature distinguishes among their meanings, but in general, they are all equivalent terms.) Unlike skewness, which can be relatively easily adjusted, heavy-tails can be very painful in inferencial statistics. When a distribution has heavy-tails, it means that the sample has extreme data points that can introduce bias to statistical inferences (note that the term bias is defined as the difference between the statistical estimation vs. the actual population parameter). This is because the occurrence of extreme data points are so low that they are unlikely to be included in the sample you collected, and yet there are substantial number of them lurking in the uncollected portion of a population that impacts population parameters due to their extremity. Figure (18) below shows the comparison of heavy- vs light-tailed distributions in a form of probability density function (PDF). Let's talk about the left plot first. Observe that in the heavy-tailed distribution (black line), the chance of occurrence for extreme values does not decay to zero as fast as that of the light-tailed distribution (grey line). This means that you have non-negligible chance of observing extreme values, and they may not have upper/lower bounds. In finance, such property is translated into high risk & unpredictability, which is modeled by Cauchy distributions. The right plot in figure (18) compares normal vs Cauchy distributions. Note that the tails of Cauchy distribution is higher than that of the normal distributions. The heavy tails in Cauchy attempt to model financial/investment risks by representing randomness in which extremes are encountered. When data arise from an underlying heavy-tailed distribution, shoehorning in the \"normal distribution\" model of risk would severely understate the true degree of risk. The narrow peak of the Cauchy distribution signifies that less samples fall within the range of Six-Sigma ( $\\pm 3\\sigma$ ), increasing unpredictability as less samples have the typical values . Practitioners often neglect the distinction between light- vs heavy-tail because they visually don't look very different when plotted in PDF. This is a big misconception. Figure 18: Heavy-tailed distributions have more extreme data points that can be detrimental to statistical inferences Source Code For Figure (18) from scipy import stats import matplotlib.pyplot as plt import numpy as np plt.style.use('seaborn-whitegrid') x = np.linspace(0, 5, 1000) y1 = stats.expon.pdf(x, scale=1) + 0.1 y2 = stats.lognorm.pdf(x, 0.5, loc=-0.001, scale=1) y3 = stats.norm.pdf(x, loc=2.5) y4 = stats.cauchy.pdf(x, loc=2.5) fig, axes = plt.subplots(1, 2, figsize=(14, 4)) axes[0].plot(x, y1, label='Heavy-tail', color='k', linewidth=2) axes[0].plot(x, y2, label='Light-tail', color='grey', linewidth=2) axes[0].set_xlabel(r'Extreme values $\\longrightarrow$', fontsize=20) axes[1].plot(x, y3, label='Normal', color='k', linewidth=2) axes[1].plot(x, y4, label='Cauchy', color='grey', linewidth=2) axes[1].set_xlabel(r'$\\longleftarrow$ Extreme values $\\longrightarrow$', fontsize=20) for ax in axes: ax.set_ylabel(r'Chance of occurrence $\\longrightarrow$', fontsize=20) ax.yaxis.set_major_formatter(plt.NullFormatter()) ax.xaxis.set_major_formatter(plt.NullFormatter()) ax.legend(fontsize=17, loc='upper right', framealpha=1, frameon=True) ax.grid(True, linestyle='--', color='#acacac') _ = [spine.set_edgecolor('grey') for spine in ax.spines.values()] ax.text(0.78, 0.3, 'aegis4048.github.io', fontsize=20, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) fig.tight_layout() Notes: Cauchy distribution Some distributions have undefined mean, or undefined variance, or both. Cauchy distributions have undefined mean, and as such, the Law of Large Numbers (LLM: the result of performing the same experiment a large number of times will converge to a single value) and the Central Limit Theorem (CLT: the distribution of sample means approximates a normal distribution with the increasing sample size) do not apply. In the below figure, I simulated 1000 Cauchy samples with the increasing sample size, and plotted their means. It seems that the sample means are mostly 50 (because I set loc=50 ), but then all of a sudden a huge outlier appears in the sample and adds so much weight to the average that it pulls the sample mean away from 50 by a considerable amount. The extreme outliers keep coming and hitting the sample mean like a hammer, and just kepps going on like this. The sample mean never converge to a single value, which is a violation of LLM and CLT. This casts a few practical problems with inferential statistics, because the collected sample is unlikely to contain the extreme values due to their low chance of occurrence, and yet they significantly impact the population parameters due to their extremity. It is translated as a greater risk in financial modeling. Source Code For The Figure from scipy import stats import matplotlib.pyplot as plt import numpy as np np.random.seed(18) cauchy_means = [] sample_sizes = [i for i in range(1000)] for size in sample_sizes: y_cauchy = stats.cauchy.rvs(loc=50, size=size) cauchy_means.append(np.mean(y_cauchy)) plt.style.use('seaborn-whitegrid') fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(sample_sizes, means, 'k', alpha=0.7) ax.set_xlabel('Sample sizes', fontsize=18) ax.set_ylabel('Sample means', fontsize=18) ax.set_title('Undefined means of Cauchy distributions', fontsize=18) ax.text(0.23, 0.85, 'aegis4048.github.io', fontsize=16, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) fig.tight_layout() Treatment method for heavy-tailed distribution depends on the situation. The first step would be to map the distribution to a normal distribution using transformation techniques discussed below . However, the heavy-tails may still be present even after the presentation. If you are running a regression model, you may simply remove the tails and see if there's any performance improvement. In case of inferencial statistics, naive removal maybe detrimental, as it completely ignores the extremity in your population. Sometimes the heavy-tails may suggest amalgamation of two distinct populations, in which case you may need to separate them apart before running your model. This can be seen easily by running a quick test. I generated two samples from two distinct normal distribution as pop_1 and pop_2 , and plotted their combined distributions. Even though the samples were both generated from normal distributions, it exhibit heavy tails due to their difference in central tendencies. Generating two distinct normal samples : pop_1 = np.random.normal(10, 3, 100) pop_2 = np.random.normal(15, 6, 100) Figure 19: Heavy-tails due to two distinct populations Source Code For Figure (19) %matplotlib inline import numpy as np import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec np.random.seed(4) # generate samples from two distinct populations pop_1 = np.random.normal(10, 3, 100) pop_2 = np.random.normal(15, 6, 100) # combine data = np.append(pop_1, pop_2) fig = plt.figure(figsize=(10, 4)) plt.suptitle('Heavy-tails due to amalgamation of two distinct populations', fontsize=15) gs = gridspec.GridSpec(2, 2) axes = [plt.subplot(gs[0, 0]), plt.subplot(gs[1, 0]), plt.subplot(gs[:2, 1])] axes[0].hist(pop_1, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) axes[1].hist(pop_2, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) axes[2].hist(data, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) for ax in axes: ax.text(0.73, 0.85, 'aegis4048.github.io', fontsize=11, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) ax.grid(True, linestyle='--', color='#acacac') ax.set_xlim(0, 35) plt.subplots_adjust(wspace=0.5) axes[2].text(-0.415, 0.55, 'Combine', transform=axes[2].transAxes, fontsize=13) axes[2].text(-0.4, 0.43, r'$\\Longrightarrow$', transform=axes[2].transAxes, fontsize=30) Problems with multi-modal distributions In case of multi-modal distributions, reporting the mean, median, or mode can be uninformative at all, as none of them describes the central location of populations. While it is possible to compute the confidence interval of statistics using non-parameteric methods like bootstrap, it is useless . I hope that figure (20) below is descriptive enough to understand the problems of multi-modal distributions. You will need to devise your own method to describe the central location of data, such as separating the multi-modes into distinct unimodal distributions. Figure 20: Absence of central tendency in multi-modal distributions Source Code For Figure (20) import numpy as np import matplotlib.pyplot as plt np.random.seed(4) n = 1000 np.random.seed(1) x = np.concatenate((np.random.normal(0, 1, int(0.3 * n)), np.random.normal(14, 1, int(0.7 * n)), np.random.normal(8, 2, int(0.7 * n))))[:, np.newaxis] plt.rcParams.update(plt.rcParamsDefault) fig, ax = plt.subplots(figsize=(8, 4)) adjust = 0.12 n, bins, patches = ax.hist(x, bins=30, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) ax.axvline(np.mean(x) + adjust, color='k', label='Mean', linestyle='-', alpha=0.9) ax.axvline(np.median(x) + adjust, color='k', label='Median', linestyle='--', alpha=0.9) ax.axvline(bins[np.where(n == max(n))[0][0]] + adjust, color='k', label='Mode', linestyle=':', alpha=0.9) ax.text(0.2, 0.9, 'aegis4048.github.io', fontsize=15, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) ax.grid(True, linestyle='--', color='#acacac') ax.set_xlabel('X', fontsize=16) ax.set_ylabel('Probability', fontsize=16) ax.legend(loc='upper right', framealpha=1, frameon=True) fig.tight_layout() 5.2 Robustness of confidence intervals to non-normality Confidence interval of mean is robust to mild deviation from normality. This means that hypothesis tests that rely on the means (ex: t-test) are also robust to mild deviation from non-normality. In fact, there are a few variations of t-test that deals with mild non-normality (ex: skewness-adjusted t-statistic). Confidence interval of variance is VERY sensitive to even small deviation from non-normality. Its low popularity in real-life applications can be attributed to its high sensitivity. In real-life, people tend to not care much about the C.I. of variance, but techniques that check the equality of variances of multiple samples with hypothesis testing. When sample is normal, you can use f-test or Barlett's test to check equality of variances. When the sample is not normal, use non-parametric alternative like Levene's test. Many techniques that assume normality of data are still resistant to mild departure from its assumptions. Then the natural question is, how do I know the severity of deviation from normality? I found from here that the skewness and kurtosis of $-2 < 0 < +2$ is an acceptable deviation from normality, but I've seen some people arguing $-1 < 0 < +1$ is the limit. This all depends on how much you are willing to tolerate the deviation. Another way to assess departure from normality is visualizing the distribution in Q-Q plots, as shown in figure (21). You can also use this online interactive QQ-plot generator to study the effect of asymmetry and heavy-tailedness. Note that I introduced the code snippet for visualizing Q-Q plots in Python below . Figure 21: Assessing deviation from normality with Q-Q plots Notes: Be cautious with hypothesis testing for normality If you have very large sample size, hypothesis tests that check normality (ex: Shapiro-Wilk, D'Agostino's $K&#94;2$ , Anderson-Darling) are essentially useless. This is counter-intuitive. Isn't it always better to have larger sample size than the otherwise? The reason is that the confidence intervals for test statistics become too narrow with large sample size. For example, when using t-test, we compute the confidence interval of difference in means with eq (6) . If the C.I. of difference in mean includes 0, we accept the null hypothesis. However, the width of the C.I. decreases with increasing sample size, because of sample sizes $n_1$ and $n_2$ are in the denominator of eq (6) . While the C.I. becoming narrow signifies small uncertainty in your statistical estimation, it is not desirable from a hypothesis test's point of view, because the test becomes too exact to be practical. Consider the plots below. I generated multiple samples from a normal distribution with increasing sample sizes, and added small noises from a uniform distribution. Visual inspection tells us that the samples are normally distributed, but the p-values from the Shapiro-Wilk test tell the otherwise. You can see that the p-value is almost always smaller than 0.05 when sample size > 15,000 and the null hypothesis (null: sample is normally distributed) is rejected. Is there something wrong with the Shapiro-Wilk test? No, it's actually doing \"exactly\" what it's supposed to do; it's testing if a sample is \"perfectly\" normally distributed. In fact, all samples contain some white noise that are not from a normal distribution, and the test is precisely detecting them. The problem is, that the test is too \"exact\" to be \"practical\" . The test has so many samples available that it is able to detect even the smallest non-normal noises from the sample. If you try to run Shaprio-Wilk test with SciPy for sample size > 5,000, you will see this warning message: UserWarning: p-value may not be accurate for N > 5000 . I recommend you to almost always use Q-Q plots to assess normality. If that's not possible, make sure that you don't have too large samples for normality test. Source Code For The Figure import numpy as np from scipy import stats import matplotlib.pyplot as plt import matplotlib ########################### Simulation Parameters ################################ np.random.seed(5) mean = 10 std = 3 lo_noise = 6 hi_noise = 14 sizes = [100, 1500, 10000, 20000] dist_arr = [] p_vals = [] ####################### Hypothesis testing simulation ############################ for size in sizes: data = np.random.normal(mean, std, size) noise = np.random.uniform(low=lo_noise, high=hi_noise, size=size) stat, p = stats.shapiro(data + noise) dist_arr.append(data + noise) p_vals.append(p) ################################## Plotting ###################################### matplotlib.style.use('ggplot') fig, axes = plt.subplots(1, len(sizes), figsize=(15, 3)) for ax, dist, size, p in zip(axes, dist_arr, sizes, p_vals): ax.hist(dist, bins='auto', color='k', alpha=0.5) ax.set_ylabel('Count') ax.set_xlabel('X') ax.set_title('Sample Size = %d' % size) ax.text(0.45, 0.3, 'p-val = %.4f' % p, fontsize=14, bbox=dict(boxstyle='round', facecolor='white', edgecolor='k'), transform=ax.transAxes) ax.text(0.5, 0.1, 'aegis4048.github.io', fontsize=8, ha='center', va='center', transform=ax.transAxes, color='white', alpha=0.5) fig.tight_layout() Source Code For The Figure import numpy as np from scipy import stats import matplotlib.pyplot as plt np.random.seed(1) p_vals = [] sizes = [i for i in range(100, 25000, 100)] for size in sizes: data = np.random.normal(10, 3, size) noise = np.random.uniform(low=6, high=14, size=size) stat, p = stats.shapiro(data + noise) p_vals.append(p) plt.style.use('default') fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(sizes, p_vals) ax.axhspan(0, 0.05, alpha=0.5, color='#ad203e') ax.set_title('Change in p-value with increasing sample size', fontsize=18) ax.set_ylim(-0.05, 1.05) ax.set_ylabel('P-value', fontsize=15) ax.set_xlabel('Sample size', fontsize=15) ax.set_facecolor('#eeeeee') ax.grid(True, linestyle='--', color='#acacac') _ = [spine.set_edgecolor('grey') for spine in ax.spines.values()] ax.axhline(0.05, color='#ad203e', linestyle='--') ax.text(16000, 0.1, 'Reject the null hypothesis', fontsize=14, color='#ad203e') ax.text(0.6, 0.8, '$H_0$: Sample is normal\\n$H_1$: Sample is non-normal', fontsize=14, bbox=dict(boxstyle='round', facecolor='white', edgecolor='k'), transform=ax.transAxes) ax.text(0.86, 0.3, 'aegis4048.github.io', fontsize=13, ha='center', va='center', transform=ax.transAxes, color='grey', alpha=0.5) fig.tight_layout() Pythonic Tip: Q-Q plots with SciPy Q-Q plots are useful when assessing deviation from a pre-defined distribution. It is implemented in SciPy pakcage as scipy.stats.probplot . Note that the pre-defined distribution can be anything of your choice by changing the argument dist ; it can be lognormal, Weibull, exponential, Cauchy, or anything. The red line in the Q-Q plot represents the theoretical distribution of your data in a form of Cumulative Density Function (CDF). In [1]: from scipy import stats import matplotlib.pyplot as plt In [2]: # sample data generation data_1 = stats . skewnorm . rvs ( 4 , size = 1000 , random_state = 1 ) data_2 = stats . norm . rvs ( size = 1000 , random_state = 1 ) In [17]: # plotting plt . style . use ( 'seaborn-whitegrid' ) fig , axes = plt . subplots ( 2 , 2 , figsize = ( 6 , 4 )) # Q-Q plot stats . probplot ( data_1 , dist = stats . norm , plot = axes [ 0 , 0 ]) stats . probplot ( data_2 , dist = stats . norm , plot = axes [ 0 , 1 ]) axes [ 0 , 0 ] . set_title ( 'Normal Q-Q plot' ) axes [ 0 , 1 ] . set_title ( 'Normal Q-Q plot' ) axes [ 1 , 0 ] . hist ( data_1 , density = True , bins = 'auto' ) axes [ 1 , 1 ] . hist ( data_2 , density = True , bins = 'auto' ) fig . tight_layout () 5.3 Transform to normal distribution: Box-Cox When you want to construct a confidence interval of a sample, but the sample is non-normal, you have two options: transform the sample into a normal distribution, or use non-parametric alternatives. This section discusses the transformation part. WARNING! Use transformation techniques only if you really know what you are doing! The assumptions & back-transform process related with non-normal to normal distributions are very tricky, and can lead to wrong inferences when implemented wrongly. Box-Cox transformations are most useful when the transformed variable has its own interpretation. For example, when the transformed variable is symmetric, taking an inverse of the transformed mean yields the median of the original variable. This is a useful property if your goal is to estimate the central tendecy of a distribution. But its useless if your goal is to inference the C.I. of the mean of the original variable, in which case you will use non-parametric alternatives like bootstrap . There are three techniques used to map data to a normal distribution: Box-Cox, Yeo-Johnson, and normal quantile transform (check the SciPy documentation to see the comparison plot of each tecnnique). I will discuss Box-Cox transformation here. Box-Cox transformation is a type of power transformation to convert non-normal data to normal data by raising the distribution to a power of lambda ($\\lambda$). The algorithm automatically solves for $\\lambda$ that best transforms a distribution into a normal distribution. Box-Cox transformation is a statistical technique known to have remedial effects on highly skewed data. If $\\lambda$ is determined to be 2, then the distribution will be raised to a power of 2 — $Y&#94;2$. The exception to this rule is when the $\\lambda$ is 0 - log will be taken to the distribution — log($Y$). Note that using a $\\lambda = 1$ does not do anything to the distribution. If the Box-Cox algorithm spits out $\\lambda = 1$, it probably means that your data is Gaussian-like or Gaussian enough to an extent that there is no need for transformation. The figure below shows the effect of raising the exponential distribution (left) with the power of $\\lambda = .316$ to acquire the transformed normal distribution (right). Figure 22: Box-cox transformation Source Code For Figure (22) from scipy import stats import matplotlib.plyplot as plt # generate sample data x = stats.expon.rvs(size=100, random_state=1) # Box-Cox transform xt, lmbda = stats.boxcox(x) # plot fig, axes = plt.subplots(2, 2, figsize=(10, 5)) axes[0, 0].hist(x, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) axes[0, 1].hist(xt, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) stats.probplot(x, dist=stats.norm, plot=axes[1, 0]) stats.probplot(xt, dist=stats.norm, plot=axes[1, 1]) axes[0, 0].set_title('Original data') axes[0, 1].set_title(r'Transformed data, $\\lambda$=%.3f' % lmbda) axes[1, 0].set_title('Normal Q-Q plot') axes[1, 1].set_title('Normal Q-Q plot') axes[1, 1].set_ylabel('') for ax in axes.flatten(): ax.grid(True, linestyle='--', color='#acacac') ax.text(0.05, 0.85, 'aegis4048.github.io', fontsize=12, transform=ax.transAxes, color='grey', alpha=0.5) for ax in axes.flatten()[2:]: ax.get_lines()[0].set_marker('o') ax.get_lines()[0].set_color('grey') ax.get_lines()[0].set_markeredgecolor('black') ax.get_lines()[0].set_markersize(5.0) ax.get_lines()[0].set_alpha(0.5) ax.get_lines()[1].set_linewidth(1.0) ax.get_lines()[1].set_color('k') plt.subplots_adjust(wspace=13) fig.text(0.47, 0.33, 'Box-Cox', size=14, ha='center', va='top') fig.text(0.465, 0.3, r'$\\Longleftrightarrow$', size=30, ha='center', va='top') fig.text(0.47, 0.8, 'Box-Cox', size=14, ha='center', va='top') fig.text(0.465, 0.77, r'$\\Longleftrightarrow$', size=30, ha='center', va='top') fig.tight_layout() Not all transformations work perfectly The example illustrated above is the most ideal case of Box-Cox transform. Not all transforms work perfectly, especially in case of heavy tails. Visualize your transformed histrogram, and the Q-Q plot to evaluate the performance of the transform. If the transform did not mitigate the skewness (this is rare), you will have to look for non-parametric alternatives, like bootstrap explained above. If the transform did not mitigate the heavy-tails, your solution depends on the situation, as discussed above . Figure 23: Box-cox transformation Source Code For Figure (23) from scipy import stats import matplotlib.pyplot as plt # generate sample data x = stats.skewnorm.rvs(100, size=1000) + 1 # Box-Cox transform xt, lmbda = stats.boxcox(x) # plot fig, axes = plt.subplots(2, 2, figsize=(10, 5)) axes[0, 0].hist(x, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) axes[0, 1].hist(xt, histtype='stepfilled', edgecolor='k', alpha=0.4, color='grey', density=True) stats.probplot(x, dist=stats.norm, plot=axes[1, 0]) stats.probplot(xt, dist=stats.norm, plot=axes[1, 1]) axes[0, 0].set_title('Original data') axes[0, 1].set_title(r'Transformed data, $\\lambda$=%.3f' % lmbda) axes[1, 0].set_title('Normal Q-Q plot') axes[1, 1].set_title('Normal Q-Q plot') axes[1, 1].set_ylabel('') for ax in axes.flatten(): ax.grid(True, linestyle='--', color='#acacac') ax.text(0.05, 0.85, 'aegis4048.github.io', fontsize=12, transform=ax.transAxes, color='grey', alpha=0.5) for ax in axes.flatten()[2:]: ax.get_lines()[0].set_marker('o') ax.get_lines()[0].set_color('grey') ax.get_lines()[0].set_markeredgecolor('black') ax.get_lines()[0].set_markersize(5.0) ax.get_lines()[0].set_alpha(0.5) ax.get_lines()[1].set_linewidth(1.0) ax.get_lines()[1].set_color('k') plt.subplots_adjust(wspace=13) fig.text(0.47, 0.33, 'Box-Cox', size=14, ha='center', va='top') fig.text(0.465, 0.3, r'$\\Longleftrightarrow$', size=30, ha='center', va='top') fig.text(0.47, 0.8, 'Box-Cox', size=14, ha='center', va='top') fig.text(0.465, 0.77, r'$\\Longleftrightarrow$', size=30, ha='center', va='top') fig.tight_layout() All data to be positive and greater than 0 (Y > 0) Box-Cox transformation does not work if data is smaller than 0. This can easily be fixed by adding a constant ($C$) that will make all your data greater than zero. The transformation equation is then: $$Y&#94;{'} = (Y + C)&#94;{\\lambda}$$ Note that you do not have to worry about this if you are using Yeo-Johnson transform instead of Box-Cox transform. Back-transformation Since box-cox transform raises a sample to the power of $\\lambda$, the scale of your sample changes. While removing skewness in a sample is desirable, the change in scale is not. Once you construct the confidence interval of a statistic of your interest, you have to take the inverse of the $\\lambda$ power to your estimated statistics to put it back to its original scale. In the same way, if you've added a constant $C$ to satisfy the assumption above, if have to subtract your statistical estimation by $C$ at the end. Pythonic Tip: Box-Cox transform with SciPy and Scikit-Learn There are two ways to do Box-Cox transform, and its back transform: with scipy.special.boxcox and sklearn.preprocessing.PowerTransformer . Scipy's implementation is preferrable for one-dimensional data, and Scikit-Learn's for multi-dimensional data. Note that you also need to backtransform your data, or your calculated statistics to its original scale. Here, I will calculate the centeral tendency of non-normal distribution , which is described by a median. SciPy Implementation First, you need to transform the data with scipy.special.boxcox . Make sure to return & store lmbda , which raises the original distribution to the power of $\\lambda$. You need it later to back-transform the calculated statistic into its original scale. Let's first generate non-normal sample data we are going to use, and take a look at it. Assess the normality of your sample with Q-Q plots explained above . In [26]: from scipy import stats import matplotlib.pyplot as plt import pandas as pd import numpy as np # generate non-normal sample x = stats . lognorm . rvs ( s = 1 , loc = 0 , scale = 5 , size = 1000 , random_state = 4 ) # plot fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 3 )) axes [ 0 ] . hist ( x ) stats . probplot ( x , dist = stats . norm , plot = axes [ 1 ]) fig . tight_layout () # summary statistics df = pd . DataFrame ( x ) . describe () . T df [ 'Median' ] = np . median ( x ) df Out[26]: count mean std min 25% 50% 75% max Median 0 1000.0 8.300435 9.606277 0.279772 2.768348 5.256457 9.943978 81.145311 5.256457 The distribution seems to be non-normal. The mean is 8.30, and the median is 5.26. Let's transform this data into a normal distribution with Box-Cox transform, and see how it changes. In [27]: from scipy import stats import matplotlib.pyplot as plt import pandas as pd import numpy as np # box-cox transform xt , lmbda = stats . boxcox ( x ) # plot fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 3 )) axes [ 0 ] . hist ( xt ) stats . probplot ( xt , dist = stats . norm , plot = axes [ 1 ]) fig . tight_layout () # summary statistics df = pd . DataFrame ( xt ) . describe () . T df [ 'Median' ] = np . median ( xt ) df Out[27]: count mean std min 25% 50% 75% max Median 0 1000.0 1.628602 0.924383 -1.288433 1.009014 1.635019 2.250321 4.227487 1.635019 The transformation seemed to work well. Note the change in scale due to transform. The mean changed from 8.30 to 1.63, and the median changed from 5.26 to 1.64. This shows the need to apply back-transformation to the calculated statistic. We proceed to calculate the confidence interval of your statistic. In this case, we compute the 95% C.I. of mean, with the code snippet described above . If the transformation did not work well, use a non-parametric alternative explained below . In [5]: import numpy as np from scipy import stats # 95% confidence interval of mean in a transformed scale lo_xt , hi_xt = stats . t . interval ( 1 - 0.05 , len ( xt ) - 1 , loc = np . mean ( xt , ddof = 1 ), scale = stats . sem ( xt )) ( lo_xt , hi_xt ) Out[5]: (1.571239695096202, 1.6859642780066368) Note that the above C.I. of mean is in the transformed scale. We need to apply back-transform to put it back to its original scale. We use scipy.special.inv_boxcox . In [6]: from scipy.special import inv_boxcox # inverse transform lo_x , hi_x = inv_boxcox ( lo_xt , lmbda ), inv_boxcox ( hi_xt , lmbda ) ( lo_x , hi_x ) Out[6]: (4.922371850163526, 5.5398361421708175) Taking the inverse of the transformed C.I. of mean returned a range of 4.93 ~ 5.54. Recall that in the original sample, Mean = 8.30, and median = 5.26. The result is consistent with the statement in the WARNING above : \"when the transformed variable is symmetric, taking an inverse of the transformed mean yields the median of the original variable.\" Additionally, we can also try a non-parametric alternative, bootstrap , to obtain the C.I. of median of the non-normal distribution. Recall that the variable x generated above is a non-normal sample. One can see that the C.I. of median obtained from Box-Cox and bootstrap agree with each other. In [7]: import numpy as np iteration = 100000 boot_median = [ np . median ( np . random . choice ( x , len ( x ))) for _ in range ( iteration )] lo_x_boot = np . percentile ( boot_median , 2.5 ) hi_x_boot = np . percentile ( boot_median , 97.5 ) ( lo_x_boot , hi_x_boot ) Out[7]: (4.832966540955844, 5.616555703219367) Scikit-Learn implementation Box-cox transform can also be implemented with Scikiy Learn: sklearn.preprocessing.PowerTransformer . Scikit-Learn's implementation of box-cox transformation is specialized for multi-dimensional data, and therefore it accepts 2-D array as its input. It's ability to handle multi-dimensional data is quite useful in machine learning. This function is available in versions scikit-learn v0.20 or above. Most versions of Anaconda support scikit-learn v0.19.1 . If you are using Anaconda Python, you will need to update Scikit Learn with the following command in the console (note that if you are using Jupyter Notebook, you must restart your Jupyter after upgrading Scikit-Learn): In [40]: # pip install scikit-learn==0.20 For consistency, we will keep using the non-normal sample x I generated above. Before we start, recall that x is an 1-D array. Since Scikiy-Learn's Box-Cox expects 2-D array as input, you will have to change the data type into a numpy matrix with np.asmatrix : In [5]: import numpy as np # convert data type x_mat = np . asmatrix ( x ) . T (Note: You need to have some basic understanding of Objected Oriented Programming (OOP) to understand this explanation) Let's apply the transform. First, instantiate the transformer object pt . Second, fit the $\\lambda$ parameter using fit() , which will store the $\\lambda$ parameter as a class attribute inside the pt object. The $\\lambda$ parameter stored will be used later to apply inverse transform. Last, use transform() to apply Box-Cox transformation. Note that appling pt.fit() and pt.transform() can also be done with one-line with pt.fit_transform() . In [30]: from sklearn.preprocessing import PowerTransformer # box-cox transform pt = PowerTransformer ( method = 'box-cox' , standardize = False ) pt . fit ( x_mat ) xt = pt . transform ( x_mat ) # convert data type for plotting xt = xt . flatten () # plot fig , axes = plt . subplots ( 1 , 2 , figsize = ( 10 , 3 )) axes [ 0 ] . hist ( xt ) stats . probplot ( xt , dist = stats . norm , plot = axes [ 1 ]) fig . tight_layout () # summary statistics df = pd . DataFrame ( xt ) . describe () . T df [ 'Median' ] = np . median ( xt ) df Out[30]: count mean std min 25% 50% 75% max Median 0 1000.0 1.628602 0.924383 -1.288433 1.009014 1.635019 2.250321 4.227487 1.635019 From this point, the procedures for obtaining the C.I. of median of a non-normal distribution are the same as in SciPy's implementation, except that we use pt.inverse_transform (Scikit-Learn) instead of inv_boxcox (SciPy), and convert 1-D array to 2-D datatype array. Note that the output is the exact same is the one given by the SciPy implementation above. In [29]: import numpy as np from scipy import stats # 95% confidence interval of mean in a transformed scale lo_xt , hi_xt = stats . t . interval ( 1 - 0.05 , len ( xt ) - 1 , loc = np . mean ( xt ), scale = stats . sem ( xt )) # convert data type lo_xt_mat = np . asmatrix ( lo_xt ) hi_xt_mat = np . asmatrix ( hi_xt ) # inverse transform hi_x = pt . inverse_transform ( hi_xt_mat )[ 0 ][ 0 ] lo_x = pt . inverse_transform ( lo_xt_mat )[ 0 ][ 0 ] ( lo_x , hi_x ) Out[29]: (4.9223718501635245, 5.539836142170828) 5.4 Non-parametric alternative: Bootstrap (Note: This section is a continuation of Section 4.4. Confidence interval of other statistics: Bootstrap explained above . For bootstrap code, navigate to here .) Bootstrap is the most popular choice when making a point estimation of a population parameter of an unknown distribution. It is distribution-free. This means that it does not assume anything about the shape of the distribution (Ex: normal, lognormal, weibull, exponential). For example, computing the confidence interval of mean with eq (1) requires symmetry of a distribution, as it relies on $\\pm$ standard error method. Any parametric methods (Ex: t-test, f-test) that assume normality of data has less coverage than their non-parametric alternatives when their assumptions are violated. Let's take a deeper look at the robustness of parametric vs non-parametric methods for different distributions by running simulations. We compute the confidence interval of mean and variance. CI of mean is known to be resistent to deviation from normality, while CI of variance is very sensitive. The procedure is as follows: Randomly generate POPUPLATION_SIZE observations from a specified distribution. Assume this to be a population. We generate 4 populations: normal, exponential, skewed, and lognormal. Each population goes through step 2-5. Randomly draw samples NUM_SAMPLES times from a population. Each sample has a size = SAMPLE_SIZE . Each sample goes through step 3-4. Compute the parametric & non-parametric 95% confidence interval of variance and mean for a sample. For parametric CI of mean and variance, use eq (1) and eq (10) . For non-parametric CI, use bootstrap . Check if a population mean or variance falls within the computed confidence interval. Count the number of times a population mean and variance falls within the computed confidence interval. The above procedure describes a situation in which we attempt to inference the unknown population parameters from a small portion of the population, a.k.a. the samples (check Section 3. Population vs Samples above ). We want to know if the computed confidence interval of samples contain the true population parameter. Figure (24) summarizes the simulation result: Figure 24: Coverage of parametric vs non-parametric confidence intervals Source Code For Figure (24) from scipy import stats import matplotlib.pyplot as plt import numpy as np # simulation settings POPUPLATION_SIZE = 100000 NUM_SAMPLES = 10000 SAMPLE_SIZE = 100 BOOT_SAMPLE_SIZE = 100 # analytical confidence interval of mean def ci_mean_analy(arr, alpha): return stats.t.interval(1 - alpha, len(arr) - 1, loc=np.mean(arr), scale=stats.sem(arr)) # bootstrap confidence interval of mean def ci_mean_boot(arr, p_lo, p_hi, r=BOOT_SAMPLE_SIZE): boot_var = [np.mean(np.random.choice(arr, len(arr))) for _ in range(r)] lo = np.percentile(boot_var, p_lo) hi = np.percentile(boot_var, p_hi) return (lo, hi) # analytical confidence interval of variance def ci_var_analy(arr, alpha): lo, hi = ( (len(arr) - 1) * np.var(arr, ddof=1) / stats.chi2.ppf(1 - alpha / 2, len(arr) - 1), (len(arr) - 1) * np.var(arr, ddof=1) / stats.chi2.ppf(alpha / 2, len(arr) - 1) ) return (lo, hi) # bootstrap confidence interval of variance def ci_var_boot(arr, p_lo, p_hi, r=BOOT_SAMPLE_SIZE): boot_var = [np.var(np.random.choice(arr, len(arr)), ddof=1) for _ in range(r)] lo = np.percentile(boot_var, p_lo) hi = np.percentile(boot_var, p_hi) return (lo, hi) # check if the confidence interval includes the population parameter def coverage_test(lo, hi, target): if lo <= target <= hi: return 1 else: return 0 # define population norm_pop = stats.norm.rvs(size=POPUPLATION_SIZE, scale=100) expon_pop = stats.expon.rvs(size=POPUPLATION_SIZE, scale=100) skew_pop = stats.skewnorm.rvs(a=50, size=POPUPLATION_SIZE, scale=100) lognorm_pop = stats.lognorm.rvs(1, size=POPUPLATION_SIZE, scale=100) # population mean mean_norm_pop = np.mean(norm_pop) mean_expon_pop = np.mean(expon_pop) mean_skew_pop = np.mean(skew_pop) mean_lognorm_pop = np.mean(lognorm_pop) # population variance var_norm_pop = np.var(norm_pop, ddof=0) var_expon_pop = np.var(expon_pop, ddof=0) var_skew_pop = np.var(skew_pop, ddof=0) var_lognorm_pop = np.var(lognorm_pop, ddof=0) # initialize count_mean_norm_analy, count_mean_expon_analy, count_mean_skew_analy, count_mean_lognorm_analy = [], [], [], [] count_mean_norm_boot, count_mean_expon_boot, count_mean_skew_boot, count_mean_lognorm_boot = [], [], [], [] count_var_norm_analy, count_var_expon_analy, count_var_skew_analy, count_var_lognorm_analy = [], [], [], [] count_var_norm_boot, count_var_expon_boot, count_var_skew_boot, count_var_lognorm_boot = [], [], [], [] for i in range(NUM_SAMPLES): # randomly draw samples from population norm_samp = np.random.choice(norm_pop, SAMPLE_SIZE) expon_samp = np.random.choice(expon_pop, SAMPLE_SIZE) skew_samp = np.random.choice(skew_pop, SAMPLE_SIZE) lognorm_samp = np.random.choice(lognorm_pop, SAMPLE_SIZE) # 95% ANALYTICAL confidence interval of MEAN mean_lo_norm_analy, mean_hi_norm_analy = ci_mean_analy(norm_samp, 0.05) mean_lo_expon_analy, mean_hi_expon_analy = ci_mean_analy(expon_samp, 0.05) mean_lo_skew_analy, mean_hi_skew_analy = ci_mean_analy(skew_samp, 0.05) mean_lo_lognorm_analy, mean_hi_lognorm_analy = ci_mean_analy(lognorm_samp, 0.05) # 95% BOOTSTRAP confidence interval of MEAN mean_lo_norm_boot, mean_hi_norm_boot = ci_mean_boot(norm_samp, 2.5, 97.5) mean_lo_expon_boot, mean_hi_expon_boot = ci_mean_boot(expon_samp, 2.5, 97.5) mean_lo_skew_boot, mean_hi_skew_boot = ci_mean_boot(skew_samp, 2.5, 97.5) mean_lo_lognorm_boot, mean_hi_lognorm_boot = ci_mean_boot(lognorm_samp, 2.5, 97.5) # 95% ANALYTICAL confidence interval of VARIANCE var_lo_norm_analy, var_hi_norm_analy = ci_var_analy(norm_samp, 0.05) var_lo_expon_analy, var_hi_expon_analy = ci_var_analy(expon_samp, 0.05) var_lo_skew_analy, var_hi_skew_analy = ci_var_analy(skew_samp, 0.05) var_lo_lognorm_analy, var_hi_lognorm_analy = ci_var_analy(lognorm_samp, 0.05) # 95% BOOSTRAP confidence interval of VARIANCE var_lo_norm_boot, var_hi_norm_boot = ci_var_boot(norm_samp, 2.5, 97.5) var_lo_expon_boot, var_hi_expon_boot = ci_var_boot(expon_samp, 2.5, 97.5) var_lo_skew_boot, var_hi_skew_boot = ci_var_boot(skew_samp, 2.5, 97.5) var_lo_lognorm_boot, var_hi_lognorm_boot = ci_var_boot(lognorm_samp, 2.5, 97.5) # coverage test for ANALYTICAL CI of MEAN count_mean_norm_analy.append(coverage_test(mean_lo_norm_analy, mean_hi_norm_analy, mean_norm_pop)) count_mean_expon_analy.append(coverage_test(mean_lo_expon_analy, mean_hi_expon_analy, mean_expon_pop)) count_mean_skew_analy.append(coverage_test(mean_lo_skew_analy, mean_hi_skew_analy, mean_skew_pop)) count_mean_lognorm_analy.append(coverage_test(mean_lo_lognorm_analy, mean_hi_lognorm_analy, mean_lognorm_pop)) # coverage test for BOOTSTRAP CI of MEAN count_mean_norm_boot.append(coverage_test(mean_lo_norm_boot, mean_hi_norm_boot, mean_norm_pop)) count_mean_expon_boot.append(coverage_test(mean_lo_expon_boot, mean_hi_expon_boot, mean_expon_pop)) count_mean_skew_boot.append(coverage_test(mean_lo_skew_boot, mean_hi_skew_boot, mean_skew_pop)) count_mean_lognorm_boot.append(coverage_test(mean_lo_lognorm_boot, mean_hi_lognorm_boot, mean_lognorm_pop)) # coverage test for ANALYTICAL CI of VARIANCE count_var_norm_analy.append(coverage_test(var_lo_norm_analy, var_hi_norm_analy, var_norm_pop)) count_var_expon_analy.append(coverage_test(var_lo_expon_analy, var_hi_expon_analy, var_expon_pop)) count_var_skew_analy.append(coverage_test(var_lo_skew_analy, var_hi_skew_analy, var_skew_pop)) count_var_lognorm_analy.append(coverage_test(var_lo_lognorm_analy, var_hi_lognorm_analy, var_lognorm_pop)) # coverage test for BOOTSTRAP CI of VARIANCE count_var_norm_boot.append(coverage_test(var_lo_norm_boot, var_hi_norm_boot, var_norm_pop)) count_var_expon_boot.append(coverage_test(var_lo_expon_boot, var_hi_expon_boot, var_expon_pop)) count_var_skew_boot.append(coverage_test(var_lo_skew_boot, var_hi_skew_boot, var_skew_pop)) count_var_lognorm_boot.append(coverage_test(var_lo_lognorm_boot, var_hi_lognorm_boot, var_lognorm_pop)) print() print('###########################################################') print(' Coverage Test (%) ') print('###########################################################') print() print() print('------------------ Parametric CI of mean ------------------') print() print('{:<40} {:>15} %'.format('Normal Population: ', round(sum(count_mean_norm_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Exponential Population: ', round(sum(count_mean_expon_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Skewed Population: ', round(sum(count_mean_skew_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Lognormal Population: ', round(sum(count_mean_lognorm_analy) / NUM_SAMPLES * 100, 1))) print() print('------------------ Non-parametric CI of mean --------------') print() print('{:<40} {:>15} %'.format('Normal Population: ', round(sum(count_mean_norm_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Exponential Population: ', round(sum(count_mean_expon_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Skewed Population: ', round(sum(count_mean_skew_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Lognormal Population: ', round(sum(count_mean_lognorm_boot) / NUM_SAMPLES * 100, 1))) print() print('---------------- Parametric CI of variance ----------------') print() print('{:<40} {:>15} %'.format('Normal Population: ', round(sum(count_var_norm_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Exponential Population: ', round(sum(count_var_expon_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Skewed Population: ', round(sum(count_var_skew_analy) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Lognormal Population: ', round(sum(count_var_lognorm_analy) / NUM_SAMPLES * 100, 1))) print() print('---------------- Non-parametric CI of variance ------------') print() print('{:<40} {:>15} %'.format('Normal Population: ', round(sum(count_var_norm_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Exponential Population: ', round(sum(count_var_expon_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Skewed Population: ', round(sum(count_var_skew_boot) / NUM_SAMPLES * 100, 1))) print('{:<40} {:>15} %'.format('Lognormal Population: ', round(sum(count_var_lognorm_boot) / NUM_SAMPLES * 100, 1))) Highlights of the simulation result There are lots of things we can learn from the simulation result, shown in figure (24) . I want to mainly emphasize on the distinction between the parametric vs. non-parametric methods here. Note that bootstrap is one kind of non-parametric methods Some statistics are sensitive to deviation from normality Mean is resistent to deviation from normality, while variance is not. One of the reason that t-test is so popular is because the C.I. of mean is resistent to deviation from normality (which is translated as broader applicability). On the other hand, C.I. of variance is rarely used due to its extreme sensitivity (check out Section 4.3. Confidence interval of variance above ). Similar idea applies to the other statistics (Ex: covariance, regression coefficient, f-statistic). Do not blindly use parametric methods if you are not sure if a population satisfies the assumptions. Parametric methods acquire 95% nominal coverage rate ONLY under normality This is an expected behavior, as I specified the confidence level to be 95% in the simulation setting; it means that I want the C.I. to corretly guess the population parameter 19/20 times. Parametric C.I.'s were able to acquire the norminal 95% coverage rate under normality, but when the population was not normal, it acquired lower coverage rate due to the violation of normality. Making an inference about heavy-tailed distribution is difficult. Exponential and lognormal distributions have heavier tails than normal distribution. This means that they have extreme data points that significantly affect the population parameter, and yet the occurrence rate of those extreme points is so low that they are unlikely to be included in the collected samples, which in turn increases bias. Theoretically, exponential is heavier-tailed than normal, and lognormal is heavier-tailed than exponential. In the simulation result, you can see that the coverage rate drops in order: normal -> exponential -> lognormal. For more information check out Problems with kurtosis (heavy-tails) above . Bootstrap outperforms parametric method under non-normality This is the whole point of using non-parametric methods. We can see this by comparing the coverage rate of variance for exponential and lognormal populations. For the variance of lognormal distribution, the difference in coverage rate is almost double. Parametric method outperforms non-parametric method under normality You don't want to blindly always use non-parametric methods. If you are confident that your population is normally distributed, use parametric method. Not doing so results in abandoning a piece of information which is perfectly fine. You can see this by comparing the coverage rate of normal distribution for both parametric and non-parametric methods. An exception to this rule is when a sample size very large. In that case, you can blindly use bootstrap, as the samples are diverse enough to account for all possible variations within a population. Check out figure (13) ; bootstrap C.I. gets approximates the analytical C.I. really well with the increasing sample size. Non-parametric methods yield \"approximate\" solutions with smaller risk The central idea behind most non-parametric methods is to approximate the near-exact solution with asymptotic process — their accuracy increases with the increasing sample size. Pay attention to the term, \"near-exact\" . Parametric methods are statistically more powerful when their assumptions are met; they guess the exact solution. But in return, when the assumptions are not met, they suffer massive loss in coverage rate, as it can be seen in the C.I. of variance of lognormal & exponential distributions. On the other hand, non-parametric methods highlight on broader applicability with smaller risk, which can be overcome by increasing sample size. They aim to acquire near-exact solutions by making less assumptions about the population.","tags":"Statistics","url":"https://aegis4048.github.io/comprehensive_confidence_intervals_for_python_developers","loc":"https://aegis4048.github.io/comprehensive_confidence_intervals_for_python_developers"},{"title":"Optimize Computational Efficiency of Skip-Gram with Negative Sampling","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement The materials on this post are based the on five NLP papers, Distributed Representations of Words and Phrases and their Compositionality (Mikolov et al., 2013), word2vec Parameter Learning Explained (Rong, 2014), Distributed Negative Sampling for Word Embeddings (Stergiou et al., 2017), Incremental Skip-gram Model with Negative Sampling (Kaji and Kobayashi, 2017), and word2vec Explained: Deriving Mikolov et al.'s Negative-Sampling Word-Embedding Method (Goldberg and Levy, 2014). Review on Word2Vec Skip-Gram In my previous post , I illustrated the neural network structure of Skip-Gram Word2Vec model that represents words in a vector space. Figure 1: Neural network structure of Skip-Gram I also derived the cost function of Skip-Gram in Derivation of Cost Function : $$\\begin{align} J(\\theta) = & - \\frac{1}{T} \\sum_{t=1}&#94;{T} \\sum_{-c\\leq j \\leq c,j\\neq 0} \\log p(w_{t+j} \\mid w_t ; \\, \\theta) \\\\ \\end{align} \\tag{1} $$ where $p(w_{t+j} \\mid w_t ; \\, \\theta)$ is a probability of observing $w_{t+j}$ given $w_{t}$ with parameters $\\theta$. In vanilla Skip-Gram, the probability is computed with softmax. I also noted that stochastic gradient descent (SGD) is used to mitigate computational burden — the size of $T$ in $\\frac{1}{T} \\sum&#94;T_{t=1}$ can be billions or more in NLP applications. The new cost function using SGD is: $$J(\\theta; w&#94;{(t)}) = - \\sum_{c=1}&#94;{C} log \\frac{exp(W_{output_{(c)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\tag{2}$$ where $T$ is the size of training samples, $C$ is the window size , $V$ is the size of unique vocab in the corpus, and $W_{input}$, $W_{output}$ and $h$ are illustrated in figure 1 . Review on Softmax Softmax is a multinomial regression classifier. It means that it classifies multiple labels, such as predicting if an hand-written digit is $0,\\,1,\\,2,\\,...\\,8\\,$ or $9$. In case of binary classification (True or False), such as classifying fraud or not-fraud in bank transactions, binomial regression classifier called Sigmoid function is used. In eq (2) , the fraction inside the summation of log yields the probability distribution of all $V$-vocabs in the corpus, given the input word. In statistics, the conditional probability of $A$ given $B$ is denoted as $p(A|B)$. In Skip-Gram, we use the notation, $p(w_{context}| w_{center})$, to denote the conditional probability of observing a context word given a center word. It is obtained by using the softmax function: $$ p(w_{context}|w_{center}) = \\frac{exp(W_{output_{(context)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\in \\mathbb{R}&#94;{1} \\tag{3} $$ Exponentiation ensures that the transformed values are positive, and the normalization factor in the denominator ensures that the values have a range of $[0, 1)$ and their sum equals $1$. Figure 2: softmax function transformation The probability is computed $V$ times using eq (3) to obtain a conditional probability distribution of observing all $V$-unique vocabs in the corpus, given a center word ($w&#94;{(t)}$). $$ \\left[ \\begin{array}{c} p(w_{1}|w&#94;{(t)}) \\\\ p(w_{2}|w&#94;{(t)}) \\\\ p(w_{3}|w&#94;{(t)}) \\\\ \\vdots \\\\ p(w_{V}|w&#94;{(t)}) \\end{array} \\right] = \\frac{exp(W_{output} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\in \\mathbb{R}&#94;{V}\\tag{4} $$ Softmax is computationally very expensive There is an issue with the vanilla Skip-Gram — softmax is computationally very expensive, as it requires scanning through the entire output embedding matrix ($W_{output}$) to compute the probability distribution of all $V$ words, where $V$ can be millions or more. Figure 3: Algorithm complexity of vanilla Skip-Gram Furtheremore, the normalization factor in the denominator also requires $V$ iterations. In mathematical context, the normalization factor needs to be computed for each probability p($w_{context}| w_{center}$), making the alogrithm complexity = $O(V \\times V)$. However, when implemented on code, the normalization factor is computed only once and cached as a Python variable, making the alogrithm complexity = $O(V + V) \\approx O(V)$. This is possible because normalization factor is the same for all words. Due to this computational inefficiency, softmax is not used in most implementaions of Skip-Gram . Instead we use an alternative called negative sampling with sigmoid function , which rephrases the problem into a set of independent binary classification task of algorithm complexity = $O(K \\, + \\, 1)$, where $K$ typically has a range of $[5, 20]$. Skip-Gram Negative Sampling In Skip-Gram, assuming stochastic gradient descent , weight marices in the neural network are updated for each training sample to correctly predict output. Let's assume that the training corpus has 10,000 unique vocabs ($V$ = 10000) and the hidden layer is 300-dimensional ($N$ = 300). This means that there are 3,000,000 neurons in the output weight matrix ($W_{output}$) that need to be updated for each training sample (Notes: for the input weight matrix ($W_{input}$), only 300 neurons are updated for each training sample. This is illustrated in figure 18 of my previous post .) Since the size of the training corpus ($T$) is very large, updating 3M neurons for each training sample is unrealistic in terms of computational efficiency. Negative sampling addresses this issue by updating only a small fraction of the output weight neurons for each training sample. In negative sampling, $K$ negative samples are randomly drawn from a noise distribution . $K$ is a hyper-parameter that can be empirically tuned, with a typical range of $[5,\\, 20]$. For each training sample (positive pair: $w$ and $c_{pos}$), you randomly draw $K$ number of negative samples from a noise distribution $P_n(w)$, and the model will update $(K+1) \\times N$ neurons in the output weight matrix ($W_{output}$). $N$ is the dimension of the hidden layer ($h$), or the size of a word vector. $+1$ accounts for a positive sample . With the above assumption, if you set K=9 , the model will update $(9 + 1) \\times 300 = 3000$ neurons, which is only 0.1% of the 3M neurons in $W_{output}$. This is computationally much cheaper than the original Skip-Gram, and yet maintains a good quality of word vectors. The below figure has 3-dimensional hidden layer ($N=3$), 11 vocabs ($V=11$), and 3 negative samples ($K=3$). Figure 4: Skip-Gram model structure Notes: Choice of $K$ The paper (Mikolov et al., 2013) says that K=2 ~ 5 works for large data sets, and K=5 ~ 20 for small data sets. How does negative sampling work? With negative sampling, word vectors are no longer learned by predicting context words of a center word. Instead of using softmax to compute the $V$-dimensional probability distribution of observing an output word given an input word, $p(w_O|w_I)$, the model uses sigmoid function to learn to differentiate the actual context words ( positive ) from randomly drawn words ( negative ) from the noise distribution $P_n(w)$. Assume that the center word is \"regression\" . It is likely to observe \"regression\" + { \"logistic\" , \"machine\" , \"sigmoid\" , \"supervised\" , \"neural\" } pairs, but it is unlikely to observe \"regression\" + { \"zebra\" , \"pimples\" , \"Gangnam-Style\" , \"toothpaste\" , \"idiot\" }. The model maximizes the probability $p(D=1|w,c_{pos})$ of observing positive pairs, while minimizing the probability $p(D=1|w,c_{neg})$ of observing negative pairs. The idea is that if the model can distinguish between the likely (positive) pairs vs unlikely (negative) pairs, good word vectors will be learned. Figure 5: Binomial classification of negative sampling Negative sampling converts multi-classification task into binary-classification task. The new objective is to predict, for any given word-context pair ($w,\\,c$), whether the word ($c$) is in the context window of the the center word ($w$) or not. Since the goal is to identify a given word as True ( positive , $D=1$) or False ( negative , $D=0$), we use sigmoid function instead of softmax function. The probability of a word ($c$) appearing within the context of the center word ($w$) can be defined as the following: $$ p(D=1|w,c;\\theta)=\\frac{1}{1+exp(-\\bar{c}_{output_{(j)}} \\cdot w)} \\in \\mathbb{R}&#94;{1} \\tag{5} $$ where $c$ is the word you want to know whether it came from the context window or the noise distribution. $w$ is the input (center) word, and $\\theta$ is the weight matrix passed into the model. Note that $w$ is equivalent to the hidden layer ($h$). $\\bar{c}_{output_{(j)}}$ is the word vector from the output weight matrix ($W_{output}$) of figure 1 . Eq (5) computes the probability that the given word ($c$) is a positive word ($D=1$). It only needs to be applied $K + 1$ times instead of $V$ times for every word in the vocabulary, because $\\bar{c}_{output_{(j)}}$ comes from the concatenation of a true context word ($c_{pos}$) and $K$ negative words ($\\bar{W}_{neg} = \\{ \\bar{c}_{neg, j}|j=1,\\cdots,K \\}$): $$ \\bar{c}_{output{(j)}} \\in \\{\\bar{c}_{pos}\\} \\cup \\bar{W}_{neg} \\tag{6} $$ This probability is computed $K + 1$ times to obtain a probability distribution of a true context word and $K$ negative samples: $$ \\left[ \\begin{array}{c} p(D=1|w,c_{pos}) \\\\ p(D=1|w,c_{neg, 1}) \\\\ p(D=1|w,c_{neg, 2}) \\\\ p(D=1|w,c_{neg, 3}) \\\\ \\vdots \\\\ p(D=1|w,c_{neg, K}) \\end{array} \\right] = \\frac{1}{1+exp(-(\\{\\bar{c}_{pos}\\} \\cup \\bar{W}_{neg}) \\cdot h)} \\in \\mathbb{R}&#94;{K+1}\\tag{7} $$ Compare this equation with eq (4) — you will notice that eq (7) is computationally much cheaper because $K$ is between 5 ~ 20, whereas $V$ can be millions. Moreover, no extra iterations are necessary to compute the normalization factor in the denominator of eq (4) , because sigmoid function is a binary regression classifier. The algorithm complexity for probability distribution of vanilla Skip-Gram is $O(V)$, whereas negative sampling's is $O(K+1)$. This shows why negative sampling saves a significant amount of computational cost per iteration. Notes: Sigmoid function $\\sigma(x)$ Sigmoid function is used for two-class logistic regression. $$ \\sigma(x) = \\frac{1}{1+exp(-x))}$$ It is used to classify if a given sample is True or False based on the computed probability. The sample is classified as True if the value is greater then 0.5, and vice versa. For example, if you want to classify if a certain bank transaction is fraud or not, you will use sigmoid for binary classification. If you are working on a multi-class task, such as hand-written digit classification, you will use softmax regression classifier. from matplotlib import pylab import pylab as plt import numpy as np %matplotlib notebook #sigmoid = lambda x: 1 / (1 + np.exp(-x)) def sigmoid(x): return (1 / (1 + np.exp(-x))) mySamples = [] mySigmoid = [] x = plt.linspace(-10,10,10) y = plt.linspace(-10,10,100) plt.plot(y, sigmoid(y)) plt.title('Sigmoid Function $\\sigma(x)$') plt.text(4, 0.8, r'$\\sigma(x)=\\frac{1}{1+e&#94;{-x}}$', fontsize=15) plt.xlabel('X', fontsize=12) plt.ylabel('$\\sigma(x)$', fontsize=14) Figure 6: Choice of negative samples (Text source: Petrowiki ) For the purpose of illustration, consider the above paragraphs. Assume that our center word ($w$) is drilling , window size is $3$, and the number of negative samples ($K$) is $5$. With the window size of $3$, the contexts words are: \"engineer\" , \"traditionally\" , \"designs\" , \"fluids\" , \"with\" , and \"two\" . These context words are considered as positive labels ($D = 1$). Our current context word ($c_{pos}$) is engineer . We also need negative words. We randomly pick $5$-words from the noise distribution $P_n(w)$ of the corpus for each context word, and consider them as negative samples ($D = 0$). For the current context word, engineer , the 5 randomly drawn negative words ($c_{neg}$) are: \"minimized\" , \"primary\" , \"concerns\" , \"led\" , and \"page\" . The idea of negative sampling is that it is more likely to observe positive word pairs ($w$, $c_{pos}$) together than negative word pairs ($w$, $c_{neg}$) together in the corpus. The model attempts to maximize the the probability of observing positive pairs $p(c_{pos}|w) \\rightarrow 1$ and minimize the probability of observing negative pairs $p(c_{neg}|w) \\rightarrow 0$ simultaneously by iterating through the training samples and updating the weights ($\\theta$). Note that the sum of the probability distribution obtained by sigmoid function ( eq (7) ) does not need to equal $1$, unlike softmax ( eq (4) ). Figure 7: maximizing postive pairs and minimizing negative pairs By the time the output probability distribution is nearly one-hot-encoded as in $iter = 4$ of the above figure, weight matrices $\\theta$ are optimized and good word vectors are learned. This optimization is achieved by maximizing the dot product of positive pairs ($\\bar{c}_{pos}\\cdot \\bar{w}$) and minimizing the dot product of negative pairs ($c_{neg}\\cdot w$) in eq (18) . Notes: Drawing random negative samples For each positive word-context pair ($w,\\,c_{pos}$), $K$ new negative samples are randomly drawn from a noise distribution . In figure 6 , there are $6$ positive context words ( \"engineer\" , \"traditionally\" , \"designs\" , \"fluids\" , \"with\" , and \"two\" ) for one center word ( \"drilling\" ), and $K$ is $5$. This means that a total of $6 \\times 5 = 30$ word vectors are updated for each center word $w$. What is a positive word $c_{pos}$? Words that actually appear within the context window of the center word ($w$). After the model is optimized, the probability computed with eq (5) for positive words $c_{pos}$ will output $\\approx$ 1 as shown in fig 7 . A word vector of a center word ($w$) will be more similar to a word vector of positive word ($c_{pos}$) than of randomly drawn negative words ($c_{neg}$). This is because words that frequently appear together show strong correlation with each other. Therefore, once the model is optimized: $p(D=1|w,c_{pos})\\approx1$. What is a negative word $c_{neg}$? Words that are randomly drawn from a noise distribution $P_n(w)$. After the model is optimized, the probability computed with eq (5) for negative words $c_{neg}$ will output $\\approx$ 0 as shown in fig 7 . When training an Word2Vec model, the vocab size ($V$) easily exceeds tens of thousands. When 5 ~ 20 negative samples are randomly drawn among the vocabs, it is unlikely to observe the random word with a center word together in the corpus. Therefore, once the model is optimized: $p(D=1|w,c_{neg})\\approx0$. What is a noise distribution $P_n(w)$? Imagine a distribution of words based on how many times each word appeared in a corpus, denoted as $U(w)$ (this is called unigram distribution). For each word $w$, divide the number of times it appeared in a corpus by a normalization factor $Z$ so that the distribution becomes a probability distribution of range $[0, 1)$ and sums up to $1$. Raise the normalized distribution to the power of $\\alpha$ so that the distribution is \"smoothed-out\". Then this becomes your noise distribution $P_n(w)$ — normalized frequency distribution of words raised to the power of $\\alpha$. Mathematically, it can be expressed as: $$ P_n(w) = \\left(\\frac{U(w)}{Z}\\right)&#94;{\\alpha} \\tag{8} $$ Raising the unigram distribution $U(w)$ to the power of $\\alpha$ has an effect of smoothing out the distribution. It attempts to combat the imbalance between common words and rare words by decreasing the probability of drawing common words, and increasing the probability drawing rare words. $\\alpha$ is a hyper-parameter that can be empirically tuned. The authors of the original Word2Vec paper claims that the unigram distribution $U(w)$ raised to the $3/4$rd power (i.e., $U(w)&#94;{3/4}/Z$) yielded the best result. Figure 8: Effect of raising power of unigram distribution $U(w)$ Notes: Incremental noise distribution Noise distribution $P_n(w)$ needs to be pre-computed by iterating through the entire corpus to obtain word frequency $U(w)$ and normalization factor $Z$ of the distribution. If an additional training data is added to the corpus, $P_n(w)$ needs to be computed all over again. To address this problem, a simple incremental extension of negative sampling was provided in this paper (Kaji and Kobayashi, 2017). import numpy as np import matplotlib.pyplot as plt from scipy import stats %matplotlib notebook # sample data generation data = sorted(stats.norm.rvs(size=1000) + 5) # fit normal distribution mean, std = stats.norm.fit(data, loc=0) pdf_norm = stats.norm.pdf(data, mean, std) temp = np.power(data, 3/4) temp_mean, temp_std = stats.norm.fit(temp, loc=0) temp_pdf_norm = stats.norm.pdf(temp, temp_mean, temp_std) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4), sharey=True) ax1.set_title('$U(w)$') ax1.hist(temp, bins='auto', density=True) ax1.set_xticklabels(['apple', 'desk', 'cup', 'chair', 'zebra', 'room', 'pencil', 'water', 'coin']) ax1.plot(temp, temp_pdf_norm, label='norm') ax2.set_title('$U(w)&#94;{3/4}$') ax2.hist(data, bins='auto', density=True) ax2.plot(data, pdf_norm, label='norm') ax2.set_xticklabels(['apple', 'desk', 'cup', 'chair', 'zebra', 'room', 'pencil', 'water', 'coin']) How are negative samples drawn? $K$-negative samples are randomly drawn from a noise distribution $P_n(w)$. The noise distribution is generated with eq (8) and the random samples are drawn with np.random.choice . In [2]: import numpy as np In [7]: unig_dist = { 'apple' : 0.023 , 'bee' : 0.12 , 'desk' : 0.34 , 'chair' : 0.517 } sum ( unig_dist . values ()) Out[7]: 1.0 In [5]: alpha = 3 / 4 noise_dist = { key : val ** alpha for key , val in unig_dist . items ()} Z = sum ( noise_dist . values ()) noise_dist_normalized = { key : val / Z for key , val in noise_dist . items ()} noise_dist_normalized Out[5]: {'apple': 0.044813853132981724, 'bee': 0.15470428538870049, 'desk': 0.33785130228003507, 'chair': 0.4626305591982827} In [8]: sum ( noise_dist_normalized . values ()) Out[8]: 1.0 In the initial unigram distribution, chair appeared the most in the corpus, and had 0.517 chance of being drawn as a negative sample. However, the unigram distribution is raised to the power of $3/4$rd to combat the imbalance between common vs rare words, as shown in figure 8 . After unig_dist was raised to the power of alpha = 3/4 and normalized, chair now has 0.463 chance of being drawn. On the other hand, apple had the lowest probability ( 0.023 ) of being drawn. After the transformation, it now has a bit higher probability ( 0.049 ) of being drawn. The imbalance between the most common word ( chair ) and the least common word ( apple ) was mitigated. Once the noise distribution ( noise_dist_normalized ) is generated, you randomly draw $K$ negative samples according to each word's probability. In [6]: K = 10 np . random . choice ( list ( noise_dist_normalized . keys ()), size = K , p = list ( noise_dist_normalized . values ())) Out[6]: array(['apple', 'chair', 'bee', 'desk', 'chair', 'bee', 'bee', 'chair', 'desk', 'chair'], dtype=' Derivation of Cost Function in Negative Sampling The derivations written here are based on the work of word2vec Explained: Deriving Mikolov et al.'s Negative-Sampling Word-Embedding Method (Goldberg and Levy, 2014). Consider a pair ($w,\\,c$) of center word and its context. Did this pair come from the context window or the noise distribution ? Let $p(D=1|w,c)$ be the probability that ($w,\\,c$) is observed in the true corpus, and $p(D=0|w,c) = 1 - p(D=1|w,c)$ the probability that ($w,\\,c$) is non-observed. There are parameters $\\theta$ controlling the probability distribution: $p(D=1|w,c;\\theta)$. Negative sampling attempts to optimize the parameters $\\theta$ by maximizing the probability of observing positive pairs ($w,\\,c_{pos}$) while minimizing the probability of observing negative pairs ($w,\\,c_{neg}$). For each positive pair, the model randomly draws $K$ negative words $W_{neg} = \\{ c_{neg, j}|j=1,\\cdots,K \\}$. Our objective function is then: $$ \\begin{align} & \\underset{\\theta}{\\text{argmax}} \\ p(D=1|w,c_{pos};\\theta) \\prod_{c_{neg} \\in W_{neg}} p(D=0|w,c_{neg};\\theta) \\label{}\\tag{9}\\\\ =\\quad & \\underset{\\theta}{\\text{argmax}} \\ p(D=1|w,c_{pos};\\theta) \\prod_{c_{neg} \\in W_{neg}} (1 - p(D=1|w,c_{neg};\\theta))\\label{}\\tag{10} \\end{align} $$ Notes: Probability Product In statistics, probability of observing $C$ multiple events at the same time is computed by the product of each event's probability. $$p(x_{1}, x_{2} ... x_{C}) = p(x_{1}) \\times p(x_{2}) \\, \\times \\, ... \\, \\times \\, p(x_{C})$$ This can be shortened with a product notation: $$p(x_{1}, x_{2} ... x_{C}) = \\prod_{c=1}&#94;{C}p(x_{c})$$ It is a common practice in machine learning to take a natural log to the objective function to simplify derivations. This does not affect the optimized weights ($\\theta$) because natural log is a monotonically increasing function. It ensures that the maximum value of the original probability function occurs at the same point as the log probability function. Therefore: $$ \\begin{align} =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, (p(D=1|w,c_{pos};\\theta) \\prod_{c_{neg} \\in W_{neg}} (1 - p(D=1|w,c_{neg};\\theta)) \\label{}\\tag{11} \\end{align} $$ Using the property of logs, the objective function can be simplified: $$ \\begin{align} =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, p(D=1|w,c_{pos};\\theta) + log \\, \\prod_{c_{neg} \\in W_{neg}} (1 - p(D=1|w,c_{neg};\\theta)) \\label{}\\tag{12}\\\\ =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, p(D=1|w,c_{pos};\\theta) + \\sum_{c_{neg} \\in W_{neg}} log \\, (1 - p(D=1|w,c_{neg};\\theta)) \\label{}\\tag{13} \\end{align} $$ The binomial probability $p(D=1|w,c;\\theta)$ can be replaced with eq (5) : $$ \\begin{align} =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, \\frac{1}{1+exp(-\\bar{c}_{pos} \\cdot \\bar{w})} + \\sum_{c_{pos} \\in W_{neg}} log \\, (1 - \\frac{1}{1+exp(-\\bar{c}_{neg} \\cdot \\bar{w})}) \\label{}\\tag{14}\\\\ =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, \\frac{1}{1+exp(-\\bar{c}_{pos} \\cdot \\bar{w})} + \\sum_{c_{pos} \\in W_{neg}} log \\, \\frac{1}{1+exp(\\bar{c}_{neg} \\cdot \\bar{w})} \\label{}\\tag{15}\\\\ \\end{align} $$ Using the definition of sigmoid function $\\sigma(x)=\\frac{1}{1+exp(-x)}$: $$ \\begin{align} =\\quad & \\underset{\\theta}{\\text{argmax}} \\ log \\, \\sigma(\\bar{c}_{pos} \\cdot \\bar{w}) + \\sum_{c_{pos} \\in W_{neg}} log \\, \\sigma(-\\bar{c}_{neg} \\cdot \\bar{w}) \\label{}\\tag{16} \\end{align} $$ According to Mikolov, eq (16) replaces every $log \\, p(w_O|w_I)$ in the vanilla Skip-Gram cost function defined in eq (1) . Then, the cost function we want to minimize becomes: $$J(\\theta) = - \\frac{1}{T} \\sum_{i = 1}&#94;T \\sum_{-c\\leq j \\leq c,j\\neq 0}( log \\, \\sigma(\\bar{c}_{pos} \\cdot \\bar{w}) + \\sum_{c_{neg} \\in W_{neg}} log \\, \\sigma(-\\bar{c}_{neg} \\cdot \\bar{w})) \\tag{17}$$ However, when implemented in codes, batch gradient descent (making one update after iterating through the entire $T$ corpus) is almost never used due to its high computational cost. Instead, we use stochastic gradient descent . Also, for negative sampling, gradients are calculated and weights are updated for each positive training pairs ($w,\\, c_{pos}$). In the other words, one update for each word within the context window of a center word $w$. This is shown below . The new cost function is then: $$J(\\theta; w,c_{pos}) = - log \\, \\sigma(\\bar{c}_{pos} \\cdot \\bar{w}) - \\sum_{c_{neg} \\in W_{neg}} log \\, \\sigma(-\\bar{c}_{neg} \\cdot \\bar{w}) \\tag{18}$$ Note that $w$ is a word vector for an input word, and that it is equivalent to a hidden layer ($w = h$). For clarification: $$J(\\theta; w,c_{pos}) = - log \\, \\sigma(\\bar{c}_{pos} \\cdot h) - \\sum_{c_{neg} \\in W_{neg}} log \\, \\sigma(-\\bar{c}_{neg} \\cdot h)\\tag{19}$$ Notes: Notations used in different papers Different papers use different notations. In word2vec Parameter Learning Explained (Rong, 2014): $$J(\\theta; w_I, w_O) = - log \\, \\sigma(v&#94;{'}_{w_{O}} \\cdot h) - \\sum_{w_j \\in W_{neg}} log \\, \\sigma(-v&#94;{'}_{w_{j}} \\cdot h)$$ where $w_I$ is the input (center) word in the corpus. $w_{O}$ is a word found in the context window of $w_I$ and is a positive word. $v&#94;{'}$ is a word vector in the output weight matrix ($v&#94;{'} \\in W_{output}$), $w_j$ is a randomly drawn negative word from the noise distribution , and $v&#94;{'}_{w_{j}}$ is a $j$-th word vector in $W_{output}$ that corresponds to the negative word $w_j$. $h$ is a hidden layer . In the original Word2Vec paper, Distributed Representations of Words and Phrases and their Compositionality (Mikolov et al., 2013): $$J(\\theta; w_I, w_O) = - log \\, \\sigma(v&#94;{'}_{w_{O}} \\top v_I) - \\sum&#94;k_{i=1} \\mathbb{E}_{w_{i} \\sim P_n(w)}\\big[ log \\, \\sigma(-v&#94;{'}_{w_{i}} \\top v_I) \\big]$$ $k$ is the number of negative samples and $w_i$ is an $i$-th negative word drawn from the noise distribution $P_n(w)$. $v_{w_{I}}$ is a word vector in the input weight matrix $W_{input}$ for the input word $w_I$ and is equivalent to the hidden layer $h$. These are all equivalent to eq (19) . Derivation of gradients The goal of any machine learning model is to find the optimal values of a weight matrix ($\\theta$) to minimize prediction error. A general update equation for weight matrix looks like the following: $$ \\theta&#94;{(new)}=\\theta&#94;{(old)}-\\eta\\cdot\\frac{\\partial J}{\\partial \\theta} \\tag{20}$$ $\\theta$ is a parameter that needs to be optimized, and $\\eta$ is a learning rate. In negative sampling, we take the derivative to the cost function $J(\\theta; w, c_{pos})$ defined in eq (19) with respect to $\\theta$. Note that the derivative of a sigmoid function is $\\frac{\\partial \\sigma}{\\partial x} = \\sigma(x)(1–\\sigma(x))$. $$ \\frac{\\partial J}{\\partial \\theta} = (\\sigma(\\bar{c}_{pos} \\cdot h)) - 1)\\frac{\\partial \\bar{c}_{pos} \\cdot h}{\\partial \\theta} + \\sum_{c_{neg} \\in W_{neg}} \\sigma(\\bar{c}_{neg} \\cdot h) \\frac{\\partial \\bar{c}_{neg} \\cdot h}{\\partial \\theta} \\tag{21}$$ Since the parameter $\\theta$ is a concatenation of the input and output weight matrix $[W_{input} \\quad W_{output}]$, the cost function needs to be differentiated with respect to the both matrices — $[\\frac{\\partial J}{\\partial W_{input}} \\quad \\frac{\\partial J}{\\partial W_{output}}]$. Notes: Clarification on notation $\\bar{c}$ represents a word vector in the output weight matrix ($\\bar{c} \\in W_{output}$) for a context word. The context word can be a positive word ($c_{pos}$) from a context window or a negative word ($c_{neg} \\in W_{neg}$) from a noise distribution . $h$ is a hidden layer . Recall that the hidden layer is essentially a word vector for the input word that is looked up from the input weight matrix $W_{input}$. Gradients with respect to output weight matrix $\\frac{\\partial J}{\\partial W_{output}}$ With negative sampling, we do not update the entire output weight matrix $W_{output}$, but only a fraction of it. We update $K + 1$ word vectors in the output weight matrix — $\\bar{c}_{pos}$, $\\bar{c}_{neg,1},\\,...\\,\\bar{c}_{neg,K}$. We take partial derivatives to the cost function defined in eq (19) with respect to positive words and negative words. This can be done by replacing $\\theta$ in eq (21) with $\\bar{c}_{pos}$ and $\\bar{c}_{neg}$ each. $$ \\begin{align} \\frac{\\partial J}{\\partial \\bar{c}_{pos}} &= (\\sigma(\\bar{c}_{pos} \\cdot h) - 1)\\cdot h \\label{}\\tag{22}\\\\[5pt] \\frac{\\partial J}{\\partial \\bar{c}_{eng}} &= \\sigma(\\bar{c}_{neg} \\cdot h)\\cdot h \\label{}\\tag{23} \\end{align} $$ The update equations are then: $$ \\begin{align} \\bar{c}_{pos}&#94;{(new)} &= \\bar{c}_{pos}&#94;{(old)} - \\eta \\cdot (\\sigma(\\bar{c}_{pos} \\cdot h) - 1)\\cdot h \\label{}\\tag{24}\\\\[6pt] \\bar{c}_{neg}&#94;{(new)} &= \\bar{c}_{neg}&#94;{(old)} - \\eta \\cdot \\sigma(\\bar{c}_{neg} \\cdot h) \\label{}\\tag{25} \\end{align} $$ The gradients for positive and negative words can be merged for brevity: $$ \\bar{c}_{j}&#94;{(new)} = \\bar{c}_{j}&#94;{(old)}-\\eta\\cdot (\\sigma(\\bar{c}_{j} \\cdot h) - t_j) \\cdot h \\tag{26}$$ where $t_j = 1$ for positive words ($c_j = c_{pos}$) and $t_j = 0$ for negative words ($c_j = c_{neg} \\in W_{neg}$). $\\bar{c}_{j}$ is the $j$-th word vector in the output word matrix ($\\bar{c}_j \\in W_{output}$). For each positive pairs ($w$, $c_{pos}$), eq (26) is applied to $K + 1$ word vectors in $W_{output}$ as shown in figure 4 . Notes: Prediction Error In eq (26) , $\\sigma(\\bar{c}_{j} \\cdot h) - t_j$ is called a prediction error . Recall that negative sampling attempts to maximize the the probability of observing positive pairs $p(c_{pos}|w) \\rightarrow 1$ while minimizing the probability of observing negative pairs $p(c_{neg}|w) \\rightarrow 0$. If good word vectors are learned, $\\sigma(\\bar{c}_{pos}\\cdot h) \\approx 1$ for positive pairs, and $\\sigma(\\bar{c}_{neg}\\cdot h) \\approx 0$ for negative pairs as shown in figure 7 . The prediction error will gradually approach zero $\\sigma(\\bar{c}_{pos}\\cdot h) - t_j \\approx 0$, as the model iterates through the training samples (positive pairs) and optimizes the weights. Gradients with respect to input weight matrix $\\frac{\\partial J}{\\partial W_{input}}$ Just like vanilla Skip-Gram, only one word vector that corresponds to the input word $w$ in $W_{input}$ is updated with negative sampling. This is because the input layer is an one-hot-encoded vector (however, the equation for the gradient descent is different.) Therefore, taking the derivative for the input weight matrix is equivalent to taking the derivative to the hidden layer ($\\frac{\\partial J}{\\partial W_{input}} = \\frac{\\partial J}{\\partial h}$). We replace $\\theta$ in eq (21) with $h$, and differentiate it: $$ \\begin{align} \\frac{\\partial J}{\\partial h} &= (\\sigma(\\bar{c}_{pos} \\cdot h) - 1) \\cdot \\bar{c}_{pos} + \\sum_{c_{eng} \\in W_{neg}} \\sigma(\\bar{c}_{neg} \\cdot h) \\cdot \\bar{c}_{neg} \\label{}\\tag{27}\\\\ &= \\sum_{c_j \\in \\{c_{pos}\\} \\cup W_{neg}} (\\sigma(\\bar{c}_{j} \\cdot h) - t_j) \\cdot \\bar{c}_{j} \\label{}\\tag{28} \\end{align} $$ Same as eq (26) , $t_j = 1$ for positive words ($c_j = c_{pos}$) and $t_j = 0$ for negative words ($c_j = c_{neg} \\in W_{neg}$). The update equation is then: $$ \\bar{w}&#94;{(new)} = \\bar{w}&#94;{(old)}-\\eta\\cdot \\sum_{c_j \\in \\{c_{pos}\\} \\cup W_{neg}} (\\sigma(\\bar{c}_{j} \\cdot h) - t_j) \\cdot \\bar{c}_{j} \\tag{29}$$ Recall that $w$ is a word vector in the input weight matrix ($\\bar{w} \\in W_{input}$) and $\\bar{c}_j$ is a $j$-th word vector in the output weight matrix ($\\bar{c}_j \\in W_{output}$). Negative Sampling Algorithm For each positive word-context pair ($w, c_{pos}$), $1$ word vector that corresponds to the center word ($w$) is updated in the input weight matrix $W_{input}$ as shown in figure 15 . In the output weight matrix $W_{output}$, $1+K$ word vectors that correspond to the positive and negative words ($\\{\\bar{c}_{pos}\\} \\cup \\bar{W}_{neg} \\in \\mathbb{R}&#94;{1+K} $) are updated as shown in figure 4 . Since Skip-Gram uses SGD to reduce computational cost, negative sampling also uses SGD too. Then, the training for Skip-Gram negative sampling has the following algorithm structure: Algorithm 1: Skip-Gram Negative Sampling P_nw = # generate noise distribution for word in corpus: for context in context_window: # draw K negative samples from P_nw W_neg = np.random.choice(Pn_w.keys(), size=K, p=Pn_w.values()) # compute gradients. w is a input word vector = hidden layer grad_V_output_pos = (sigmoid(c_pos * h) - 1) * w grad_V_input = (sigmoid(c_pos * h) - 1) * c_pos grad_V_output_neg_list = [] for c_neg in W_neg: grad_V_output_neg_list.append(sigmoid(c_neg * h) * h) grad_V_input += sigmoid(c_neg * h) * c_neg # use SGD to update w, c_pos, and c_neg_1, ... , c_neg_K V_output_pos = V_output_pos - alpha * grad_V_output_pos V_input = V_input - alpha * grad_V_input for grad_V_output_neg in grad_V_output_neg_list: V_output_neg = V_output_neg - alpha * grad_V_output_neg The Python implementation of negative sampling here is based on the interpretation of Algorithm 1 SGNS Word2Vec in Distributed Negative Sampling for Word Embeddings (Stergiou et al., 2017). In vanilla Skip-Gram, one update is made for the entire weight matrices $[W_{input} \\quad W_{output}]$ for each input word. Each update involves summing up dot products for all context words within the context window of size $C$ as shown in eq (20) and eq (21) of my previous post . In negative sampling, $C$ updates are made for a fraction of the weights for each input word. This is because negative sampling treats each positive pair ($w$, $c_{pos}$) as one training sample, whereas vanilla Skip-Gram treats a center word ($w$) and its $C$ neighboring context words ($c_{pos, 1}$, $...$, $c_{pos,C}$) all together as one training sample for SGD. Numerical Demonstration For the ease of illustration, screenshots from Excel will be used to demonstrate the concept of updating weight matrices through forward and backward propagations. Description of the Corpus Assume that the training corpus is the entire text in the book, \" A Song of Ice and Fire .\" Unlike the simple one-sentence training corpus used in my previous post , the training corpus needs to be much bigger to illustrate negative sampling, because we need to randomly draw negative samples that are unlikely to be observed in a pair with a center word. The sentence that has the current center word is \"Ned Stark is the most honorable man\" . Center (input) word is Ned , and window size is $C = 2$, making Stark and is context words. Number of negative samples drawn from the noise distribution for each positive pair is $K = 3$. Figure 9: Training corpus for negative sampling For your information, Ned Stark is a fictional character from the book, A Song of Ice and Fire . The book also has a TV show adaptation, known as the Game of Thrones (GoT). Ned Stark is a noble lord of his land and has a reputation of being the most honorable man in the kingdom. So here's the idea. The center word Ned will be observed in a pair with context words (postive) like Stark , because it is his last name. The same thing goes for is too, because is is a verb tense used to describe a singular object. However, Ned most likely won't be observed in a pair with random words (negative) like pimples , zebra , donkey within the book. If the model can differentiate between positive pairs and negative pairs as shown in figure 5 , good word vectors will be learned. 1. Positive word pair: ( Ned , Stark ) Recall that in negative sampling, one update is made for each of the positive training pairs. This means that $C$ weight updates are made for each input (center) word, where $C$ is the window size. Our current positive word pair is ( Ned , Stark ). For the current positive pair, we randomly draw $K=3$ negative words from the noise distribution: pimples , zebra , idiot Forward Propagation: Computing hidden (projection) layer Hidden layer ($h$) is looked up from $W_{input}$ by multiplying the one-hot-encoded input vector with the input weight matrix $W_{input}$. Figure 10: Computing hidden (projection) layer Forward Propagation: Sigmoid output layer Output layer is a probability distribution of positive and negative words ($c_{pos} \\cup W_{neg}$), given a center word ($w$). It is computed with eq (7) . Recall that sigmoid function has $\\sigma(x) = \\frac{1}{1+exp(-x)}$. Figure 11: Sigmoid output layer Backward Propagation: Prediction Error The details about the prediction error is described above . Since our current positive word is Stark , $t_j = 1$ for Stark and $t_j=0$ for other negative words ( pimples , zebra , idiot ). Figure 12: Prediction errors of positive and negative words Backward Propagation: Computing $\\nabla W_{input}$ Gradients of input weight matrix ($\\frac{\\partial J}{\\partial W_{input}}$) are computed using eq (28) . Just like vanilla Skip-Gram, only the word vector in the input weight matrix $W_{input}$ that corresponds to the input (center) word $w$ is updated. Figure 13: Computing input weight matrix gradient $\\nabla W_{input}$ Backward Propagation: Computing $\\nabla W_{output}$ With negative sampling, only a fraction of word vectors in the output weight matrix $W_{output}$ is updated. Gradients for $K + 1$ word vectors for positive and negative words in the $W_{output}$ are computed using eq (22) and eq (23) . Recall that $K$ is the number of negative samples drawn from a noise distribution, and that $K = 3$ in our example. Figure 14: Computing output weight matrix gradient $\\nabla W_{output}$ Backward Propagation: Updating Weight matrices Input and output weight matrices ($[W_{input} \\quad W_{output}]$) are updated using eq (26) and eq (29) . Figure 15: Updating $W_{input}$ Figure 16: Updating $W_{output}$ 2. Positive word pair: ( Ned , is ) The center word Ned has two context words: Stark and is . This means that we have two positive pairs = two updates to make. Since we already update the matrices $[W_{input} \\quad W_{output}]$ using ( Ned , Stark ), we will use ( Ned , is ) to update weight matrices this time. In negative sampling, we draw new $K$ negative words for each positive pairs. Assume that we randomly drew coins , donkey , and machine as our negative words this time. Forward Propagation: Computing hidden (projection) layer Figure 17: Computing hidden (projection) layer Forward Propagation: Sigmoid output layer Figure 18 Sigmoid output layer Backward Propagation: Prediction Error Our current positive word is Stark : $t_j = 1$ for Stark and $t_j=0$ for other negative words ( coins , donkey , and machine ). Figure 19: Prediction errors of positive and negative words Backward Propagation: Computing $\\nabla W_{input}$ Figure 20: Computing input weight matrix gradient $\\nabla W_{input}$ Backward Propagation: Computing $\\nabla W_{output}$ Figure 21: Computing output weight matrix gradient $\\nabla W_{output}$ Backward Propagation: Updating Weight matrices Figure 22: Updating $W_{input}$ Figure 23: Updating $W_{output}$","tags":"Natural Language Processing","url":"https://aegis4048.github.io/optimize_computational_efficiency_of_skip-gram_with_negative_sampling","loc":"https://aegis4048.github.io/optimize_computational_efficiency_of_skip-gram_with_negative_sampling"},{"title":"Demystifying Neural Network in Skip-Gram Language Modeling","text":"Acknowledgement The materials on this post are based the on two NLP papers, Distributed Representations of Words and Phrases and their Compositionality (Mikolov et al., 2013) and word2vec Parameter Learning Explained (Rong, 2014). Paradigm Shift in Word Embedding: Count-Based to Prediction-Based Up until 2013, the traditional models for NLP tasks were count-based models. They mainly involve computing a co-occurence matrix to capture meaningful relationships among words (If you are interested in how co-occurrence matrix is used for language modeling, check out Understanding Multi-Dimensionality in Vector Space Modeling ). For example: Document 1: \"all that glitters is not gold\" Document 2: \"all is well that ends well\" * START all that glitters is not gold well ends END START 0 2 0 0 0 0 0 0 0 0 all 2 0 1 0 1 0 0 0 0 0 that 0 1 0 1 0 0 0 1 1 0 glitters 0 0 1 0 1 0 0 0 0 0 is 0 1 0 1 0 1 0 1 0 0 not 0 0 0 0 1 0 1 0 0 0 gold 0 0 0 0 0 1 0 0 0 1 well 0 0 1 0 1 0 0 0 1 1 ends 0 0 1 0 0 0 0 1 0 0 END 0 0 0 0 0 0 1 1 0 0 Table 1: Co-Occurence Matrix Count-based language modeling is easy to comprehend — related words are observed (counted) together more often than unrelated words. Many attempts were made to improve the performance of the model to the state-of-art, using SVD, ramped window, and non-negative matrix factorization ( Rohde et al. ms., 2005 ), but the model did not do well in capturing complex relationships among words. Then, the paradigm started to change in 2013, when Thomas Mikolov proposed the prediction-based modeling technique, called Word2Vec, in his famous paper, Distributed Representations of Words and Phrases and their Compositionality . Unlike counting word co-occurrences, the model uses neural networks to learn intelligent representation of words in a vector space. Then, the paper submitted to ACL in 2014, Don't count, predict! A systematic comparison of context-counting vs. context-predicting semantic vectors , quantified & compared the performances of count-based vs prediction-based models. Figure 1: Performance comparison of models ( source ) The blue bars represent the count-based models, and the red bars are for prediction-based models. The full summary of the paper and more detailed description about the result graph can be found here . Long story short, prediction-based models outperformed count-based models by a large margin on various language tasks. Prediction-based word-embedding: Word2Vec Skip-Gram One of the prediction-based language model introduced by Mikolov is Skip-Gram: Figure 2: Original Skip-gram model architecture Figure 2 is a diagram presented in the original Word2Vec paper. It is essentially describing that the model uses a neural network of one hidden (projection) layer to correctly predict context words ($w(t-2)$, $w(t-1)$, $w(t+1)$, $w(t+2)$) of an input word ($w(t)$). In the other words, the model attempts to maximize the probability of observing all four context words together, given a center word. Mathematically, it can be denoted as eq (1) . The training objective is to learn word vector representations that are good at predicting the nearby words. Notes: CBOW and Skip-Gram There are two models for Word2Vec: Continous Bag Of Words (CBOW) and Skip-Gram . While Skip-Gram model predicts context words given a center word, CBOW model predicts a center word given context words. According to Mikolov: Skip-gram : works well with small amount of the training data, represents well even rare words or phrases CBOW : several times faster to train than the skip-gram, slightly better accuracy for the frequent words Skip-Gram model is a better choice most of the time due to its ability to predict infrequent words, but this comes at the price of increased computational cost. If training time is a big concern, and you have large enough data to overcome the issue of predicting infrequent words, CBOW model may be a more viable choice. The details of CBOW model won't be covered in this post. Why predict context words? A natural question is, why do we predict context words? One must understand that the ultimate goal of Skip-Gram model is not to predict context words, but to learn intelligent vector representation of words. It just happens that predicting context words inevitably results in good vector representations of words, because of the neural network structure of Skip-Gram. Neural network at its essence is just optimizing weight marices ($\\theta$) to correctly predict output. In Word2Vec Skip-Gram, the weight matrices are, in fact, the vector representations of words. Therefore, optimizing weight matrix = good vector representations of words. This is described in detail below . What is the application of vector representations of words? In Word2Vec, words are represented as vectors, and related words are placed closed to each other on a vector space. Mathematically, this means that the vector distance between related words are smaller than the vector distance between unrelated words. Figure 3: Vector distance between two words For example in figure 3 , correlation between \"success\" and \"achieve\" can be quantified by computing the vector distance between them (Notes: For illustration purpose, three-dimensional word vectors are assumed in the figure, because higher dimensional vectors can't be visualized. Also, distance annotated in the figure is Euclidean, but in real-life, we use Cosine distance to evaluate vector correlations). One interesting application of vector representaion of words is that it can be used to solve analogy tasks. Let's assume the following word vectors for \"Germany\" , \"capital\" , and \"Berlin\" . $$ \\begin{align*} vec(\\text{Germany}) & = [1.22 \\quad 0.34 \\quad -3.82] \\\\ vec(\\text{capital}) & = [3.02 \\quad -0.93 \\quad 1.82] \\\\ vec(\\text{Berlin}) & = [4.09 \\quad -0.58 \\quad 2.01] \\end{align*} $$ To find out the capital of Germany, the word vector of \"capital\" can be added to the word vector of \"Germany\" . $$ \\begin{align*} vec(\\text{Germany}) + vec(\\text{capital}) &= [1.22 \\quad 0.34 \\quad -3.82] + [3.02 \\quad -0.93 \\quad 1.82] \\\\ &= [4.24 \\quad -0.59 \\quad -2.00] \\end{align*} $$ Since the sum of the word vectors of \"Germany\" and \"capital\" is similar to the word vector of \"Berlin\" , the model may conclude that the capital of Germany is Berlin. $$ \\begin{align*} [4.24 \\quad -0.59 \\quad -2.00] & \\cong [4.09 \\quad -0.58 \\quad 2.01] \\\\ vec(\\text{Germany}) + vec(\\text{capital}) & \\cong vec(\\text{Berlin}) \\end{align*} $$ Notes: Analogy tasks don't always work Not all analogy tasks can be solved like this. The above illustration works like a magic, but there are many analogy problems that can't be solved with Word2Vec. Think of the above illustration as just one use case of Word2Vec. Derivation of Cost Function Skip-Gram model seeks to optimize the word weight (embedding) matrix by correctly predicting context words, given a center word. In the other words, the model wants to maximize the probability of correctly predicting all context words at the same time, given a center word. Maximizing the probability of predicting context words leads to optimizing the weight matrix ($\\theta$) that best represents words in a vector space. $\\theta$ is a concatenation of input and output weight matrices — $[W_{input} \\quad W_{output}]$, as described below . It is passed into the cost function ($J$) as a variable and optimized. Mathematically, it can be expressed as: $$ \\underset{\\theta}{\\text{argmax}} \\,\\, p(w_{1}, w_{2}, ... , w_{C}|w_{center}; \\, \\theta) \\tag{1} $$ where $C$ is the window size. Recall that in statistics, the probability of $A$ given $B$ is expressed as $P(A|B)$. Then, natural log is taken on eq (1) to simplify taking derivatives. $$ \\underset{\\theta}{\\text{argmax}} \\,\\, log \\, p(w_{1}, w_{2}, ... , w_{C}|w_{center}; \\, \\theta) \\tag{2} $$ Notes: Why take a natural log? In machine learning, it is a common practice to take a natural log to the objective function to simplify taking derivatives. For example, a multinomial regression classifer called Softmax (details explained below ) has the following probability function: $p(x_i) = \\frac{e&#94;{x_i}}{\\sum_{j=1}e&#94;{x_{j}}}$ Taking a log simplifies the function: $log \\, p(x_i) = x_i - log \\, {\\sum_{j=1}e&#94;{x_{j}}}$ Depending on a model, the argument ($x_i$) passed into the probability function ($p$) can be complicated, and simplifying the original softmax function helps with taking the derivatives in the future. Taking a log does not affect the optimized weights ($\\theta$), because natural log is a monotonically increasing function. This means that increasing the value of $x$-axis results in increasing the value of $y$-axis. This is important because it ensures that the maximum value of the original probability function occurs at the same point as the log probability function. Therefore: $\\underset{\\theta}{\\text{argmax}} \\,\\, p(x_i) = \\underset{\\theta}{\\text{argmax}} \\,\\, log \\, p(x_i)$ In Skip-Gram, softmax function is used for context words classfication. The details are explained below . Softmax in Skip-Gram has the following equation: $$ p(w_{context}|w_{center}; \\, \\theta) = \\frac{exp(W_{output_{(context)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\tag{3} $$ $W_{output_{(context)}}$ is a row vector for a context word from the output embedding matrix (see below ), and $h$ is the hidden (projection) layer word vector for a center word (see below ). Softmax function is then plugged into the eq (2) to yield a new objective function that maximizes the probability of observing all $C$ context words, given a center word: $$ \\underset{\\theta}{\\text{argmax}} \\,\\, log \\, \\prod_{c=1}&#94;{C} \\frac{exp(W_{output_{(c)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\tag{4} $$ Notes: Probability Product In statistics, probability of observing $C$ multiple events at the same time is computed by the product of each event's probability. $$p(x_{1}, x_{2} ... x_{C}) = p(x_{1}) \\times p(x_{2}) \\, \\times \\, ... \\, \\times \\, p(x_{C})$$ This can be shortened with a product notation: $$p(x_{1}, x_{2} ... x_{C}) = \\prod_{c=1}&#94;{C}p(x_{c})$$ However, in machine learning, the convention is to minimize the cost function, not to maximize it. To stick to the convention, we add a negative sign to eq (4) . This can be done because minimizing a negative log-likelihood is equivalent to maximizing a positive log-likelihood. Therefore, the cost function we want to minimize becomes: $$ J(\\theta; w&#94;{(t)}) = -log \\, \\prod_{c=1}&#94;{C} \\frac{exp(W_{output_{(c)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\tag{5} $$ where $c$ is the index of the context word around the center word ($w_{t}$). $t$ is the index of the center word within a corpus of size $T$. Using the property of log, it can be changed to: $$J(\\theta; w&#94;{(t)}) = - \\sum_{c=1}&#94;{C} log \\frac{exp(W_{output_{(c)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\tag{6}$$ Taking a log to the softmax function allows us to simplify the expression into simpler forms because we can split the fraction into addtion of the numerator and the denominator: $$ J(\\theta; w&#94;{(t)}) = - \\sum_{c=1}&#94;{C}(W_{output_{(c)}} \\cdot h) + C \\cdot log \\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h) \\tag{7} $$ Different paper uses different notations for the cost function. To stick to the notation used in the Word2Vec original paper , some of the notations in eq (7) can be changed. However, they are all equivalent: $$J(\\theta;w&#94;{(t)}) = -\\sum_{-c\\leq j \\leq c,j\\neq 0} \\log p(w_{t+j} \\mid w_t ; \\, \\theta) \\tag{8}$$ Note that eq (7) and eq (8) are equivalent. They both assume stochastic gradient descent , which means that for each training sample ($w&#94;{(t)}$) in the corpus of size ($T$), one update is made to the weight matrix ($\\theta$). The cost function expressed in the paper shows batch gradient descent eq (9) , which means that only one update is made for all $T$ training samples: $$J(\\theta) = -\\frac{1}{T} \\sum&#94;T_{t=1} \\sum_{-c\\leq j \\leq c,j\\neq 0} \\log p(w_{t+j} \\mid w_t ;\\, \\theta) \\tag{9}$$ However, in Word2Vec, batch gradient descent is almost never used due to its high computational cost. The author of the paper stated that he used stochastic gradient descent for training. Read the below notes for more information about stochastic gradient descent. Window Size of Skip-Gram Softmax regression (or multinomial logistic regression) is a generalization of logistic regression to the case where we want to handle multiple classes. A general form of the softmax regression looks like this: $$J(\\theta) = -\\frac{1}{T} \\sum&#94;T_{t=1} \\sum&#94;K_{k=1} log \\frac {exp(\\theta&#94;{(k)\\top}x&#94;{(t)})} {\\sum&#94;K_{i=1} exp(\\theta&#94;{(i)\\top}x&#94;{(t)})} \\tag{10}$$ where $T$ is the number of training samples, and $K$ is the number of labels to classify. In NLP applications, $K = V$, because there are $V$ unique vocabulary we need to classify in a vector space. $V$ can easily exceed tens of thousands. Skip-Gram tweaks this a little, and replaces $K$ with a variable called window size $C$. Window size is a hyper parameter of the model with a typical range of $[1, 10]$ (see figure 4 ). Recall that Skip-Gram is a model that attempts to predict neighboring words of a center word. It doesn't have to predict all $V$ vocab in the corpus that may be 100 or more words away from it, but instead predict only a few, 1~10 neighboring context words. This is also intuitive, considering how words that are far away carry less information about each another. Thus, the adapted form of the softmax regression equation for Skip-Gram becomes: $$J(\\theta) = -\\frac{1}{T} \\sum&#94;T_{t=1} \\sum_{-c\\leq j \\leq c,j\\neq 0} log \\frac {exp(\\theta&#94;{(t+j)\\top}x&#94;{(t)})} {\\sum&#94;K_{i=1} exp(\\theta&#94;{(i)\\top}x&#94;{(t)})} \\tag{11}$$ This is equivalent to eq (9) . Note that the $K$ in the denominator is still equal to $V$, because the denominator acts as a normalization factor, as described below . However, the size of $K$ in the denominator can still be reduced to smaller size using negative sampling . Neural Network Structure of Skip-Gram How is neural network used to minimize the cost functoin described in eq (11) ? One needs to look into the structure of the Skip-Gram model to gain insights about their correlation. For illustration purpose, let's assume that the entire corpus is composed of the quote from the Game of Thrones, \"The man who passes the sentence should swing the sword\" , by Ned Stark. There are 10 words ($T = 10$), and 8 unique words ($V = 8$). Note that in real life, the corpus is much bigger than just one sentence. The man who passes the sentence should swing the sword. - Ned Stark We will use window=1 , and assume that 'passes' is the current center word, making 'who' and 'the' context words. window is a hyper-parameter that can be empirically tuned. It typically has a range of $[1, 10]$. Figure 4: Training Window For illustration purpose, a three-dimensional neural net will be constructed. In *gensim*, this can be implemented by setting size=3 . This makes $N = 3$. Note that size is also a hyper-parameter that can be empirically tuned. In real life, a typical Word2Vec model has 200-600 neurons. from gensim.models import Word2Vec model = Word2Vec(corpus, size=3, window=1) This means that the input weight matrix ($W_{input}$) will have a size of $8 \\times 3$, and output weight matrix ($W_{output}&#94;T$) will have a size of $3 \\times 8$. Recall that the corpus, \"The man who passes the sentence should swing the sword\" , has 8 unique vocabularies ($V = 8$). Figure 5: Skip-Gram model structure Training: Forward Propagation The word embedding matrices ($W_{input}$, $W_{output}$) in Skip-Gram are optimized through forward and backward propagations. For each iteration of forward + backward propagations, the model learns to reduce prediction error by optimizing the weight matrix ($\\theta$), thus acquiring higher quality embedding matrices that better capture relationships among words. Forward propagation includes obtaining the probability distribution of words ($y_{pred}$ in figure 5 ) given a center word, and backward propagation includes calculating the prediction error, and updating the weight (embedding) matrices to minimize the prediction error. Input Layer ($x$) The input layer is a $V$-dim one-hot encoded vector. Every element in the vector is 0 except one element that corresponds to the center (input) word. Input vector is multiplied with the input weight matrix ($W_{input}$) of size $V \\times N$, and yields a hidden (projection) layer ($h$) of $N$-dim vector. Because the input layer is one-hot encoded, it makes the input weight matrix ($W_{input}$) to behave like a look-up table for the center word. Assuming epoch number of 1 ( iter=1 in gensim Word2Vec implementation) and stochastic gradient descent, the input vector is injected into the network $T$ times for every word in the corpus and makes $T$ updates to the weight matrix ($\\theta$) to learn from the training samples. Derivation of the stochasitc update equations are explained below . Figure 6: One-hot encoded input vector and parameter update Notes: Stochastic Gradient Descent The goal of any machine learning model is to find the optimal values of a weight matrix ($\\theta$) to minimize prediction error. A general update equation for weight matrix looks like the following: $\\theta&#94;{(new)}=\\theta&#94;{(old)}-\\eta\\cdot\\nabla_{J(\\theta)}$ $\\eta$ is learning rate, $\\nabla_{J(\\theta)}$ is gradient for the weight matrix, and $J(\\theta)$ is the cost function that has different forms for each model. The cost function for the Skip-Gram model proposed in the Word2Vec original paper has the following equation: $$J(\\theta) = -\\frac{1}{T} \\sum&#94;T_{t=1} \\sum_{-c\\leq j \\leq c,j\\neq 0} \\log p(w_{t+j} \\mid w_t ; \\theta)$$ Here, what gives us headache is the expression, $\\frac{1}{T} \\sum&#94;T_{t=1}$, because $T$ can be larger than billions or more in many NLP applications. It is basically telling us that billions of iterations need to be computed to make just one update to the weight matrix ($\\theta$). In order to mitigate this computational burden, the author of the paper states that Stochastic Gradient Descent (SGD) was used for parameter optimization. SGD removes the expression, $\\frac{1}{T} \\sum&#94;T_{t=1}$, from the cost function and performs parameter update for each training example, $w&#94;{(t)}$: $$J(\\theta;w&#94;{(t)}) = -\\sum_{-c\\leq j \\leq c,j\\neq 0} \\log p(w_{t+j} \\mid w_t ; \\theta)$$ Then, the new parameter update equation for SGD becomes: $\\theta&#94;{(new)}=\\theta&#94;{(old)}-\\eta\\cdot\\nabla_{J(\\theta;w&#94;{(t)})}$ The original vanilla graident descent makes $1$ parameter update for $T$ training samples, but the new update equation using SGD makes $T$ parameter update for $T$ training samples. However, this comes at the price of higher fluctuation (or variance) in minimizing prediction error. Input and Output Weight Matrix ($W_{input}$, $W_{output}$) Why does Skip-Gram model attempt to predict context words given a center word? How does predicting context words help with quantifying words and representing them in a vector space? In fact, the ultimate goal of the model is not to predict context words, but to construct the word embedding matrices ($W_{input}$, $W_{output}$) that best caputure relationship among words in a vector space. Skip-Gram achieves this by using a neural net — it optimizes the weight (embedding) matrices by adjusting the weight matrix to minimize the prediction error ($y_{pred} - y_{true}$). This will make more sense once you understand how the embedding matrix behaves like a look-up table . Each row in a word-embedding matrix is a word-vector for each word. Consider the following word-embedding matrix, $W_{input}$. Figure 7: Word-embedding matrix, $W_{input}$ The words of our interest are \"passes\" and \"should\" . \"passes\" has a word vector of $[0.1 \\quad 0.2 \\quad 0.7]$ and \"should\" has $[-2 \\quad 0.2 \\quad 0.8]$. Since we set the size of the weight matrix to be size=3 above , the matrix is three-dimensional, and can be visualized in a 3D vector space: Figure 8: 3D visualization of word vectors in embedding matrix Optimizing the embedding (weight) matrices ($\\theta$) results in representing words in a high quality vector space, and the model will be able to capture meaningful relationships among words. Notes: $\\theta$ in cost function There are two weight matrices that need to be optimized in Skip-Gram model: $W_{input}$ and $W_{output}$. Often times in neural net, the weights are expressed as $\\theta$. In Skip-Gram, $\\theta$ is a concatenation of input and output weight matrices — $[W_{input} \\quad W_{output}]$. $$ \\theta = [W_{input} \\quad W_{output}] = \\left[ \\begin{array}{l} u_{the} \\\\ u_{passes} \\\\ \\vdots \\\\ u_{who} \\\\ v_{the} \\\\ v_{passes} \\\\ \\vdots \\\\ v_{who} \\end{array} \\right] \\in \\mathbb{R}&#94;{2NV}$$ $\\theta$ has a size of $2V \\times N$, where $V$ is the number of unique vocab in a corpus, and $N$ is the dimension of word vectors in the embedding matrices. $2$ is multipled to $V$ because there are two weight matrices, $W_{input}$ and $W_{output}$. $u$ is a word vector from $W_{input}$ and $v$ is a word vector from $W_{output}$. Each word vectors are $N$-dim row vectors from input and output embedding matrices. Hidden (Projection) Layer ($h$) Skip-Gram uses a neural net with one hidden layer. In the context of natural language processing, hidden layer is often referred to as a projection layer, because $h$ is essentially an 1D vector projected by the one-hot encoded input vector. Figure 9: Computing projection layer $h$ is obtained by multiplying the input word embedding matrix with the $V$-dim input vector. $$h = W_{input}&#94;T \\cdot x \\in \\mathbb{R}&#94;{N} \\tag{12}$$ Softmax Output Layer ($y_{pred}$) The output layer is a $V$-dim probability distribution of all unique words in the corpus, given a center word. In statistics, the conditional probability of $A$ given $B$ is denoted as $p(A|B)$. In Skip-Gram, we use the notation, $p(w_{context}| w_{center})$, to denote the conditional probability of observing a context word given a center word. It is obtained by using the softmax function, $$ p(w_{context}|w_{center}) = \\frac{exp(W_{output_{(context)}} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\in \\mathbb{R}&#94;{1} \\tag{13} $$ where $W_{output_{(i)}}$ is the $i$-th row vector of size $1 \\times N$ from the output embedding matrix, $W_{output_{context}}$ is also a row vector of size $1 \\times N$ from the output embedding matrix corresponding to the context word. $V$ is the size of unique vocab in the corpus, and $h$ is the hidden (projection) layer of size ($N \\times 1$). The output is an $1 \\times 1$ scalar value of probability of range $[0, 1)$. This probability is computed $V$ times to obtain a conditional probability distribution of observing each unique vocabs in the corpus, given a center word. $$ \\left[ \\begin{array}{c} p(w_{1}|w_{center}) \\\\ p(w_{2}|w_{center}) \\\\ p(w_{3}|w_{center}) \\\\ \\vdots \\\\ p(w_{V}|w_{center}) \\end{array} \\right] = \\frac{exp(W_{output} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\in \\mathbb{R}&#94;{V}\\tag{14} $$ $W_{output}$ in the denominator of eq 13 has size $V \\times N$. Multiplying $W_{output}$ with $h$ of size $N \\times 1$ will yield a dot product vector of size $V \\times 1$. This dot product vector goes through the softmax function: Figure 10: softmax function transformation The exponentiation ensures that the transformed values are positive, and the normalization factor in the denominator ensures that the values have a range of $[0, 1)$. The result is a conditional probability distribution of observing each unique vocabs in the corpus, given a center word. Notes: Negative Sampling Softmax function in Skip-Gram has the following equation: $$ P = \\frac{exp(W_{output} \\cdot h)}{\\sum&#94;V_{i=1}exp(W_{output_{(i)}} \\cdot h)} \\in \\mathbb{R}&#94;{V}$$ There is an issue with softmax in Skip-Gram — it is computationally very expensive, as it requires scanning through the entire output embedding matrix ($W_{output}$) to compute the probability distribution of all $V$ words, where $V$ can be millions or more. Furtheremore, the normalization factor in the denominator also requires $V$ iterations. When implemented in codes, the normalization factor is computed only once and cached as a Python variable, making the alogrithm complexity = $O(V+V)\\approx O(V)$. Due to this computational inefficiency, softmax is not used in most implementaions of Skip-Gram . Instead we use an alternative called negative sampling with sigmoid function, which rephrases the problem into a set of independent binary classification task of algorithm complexity = $O(K+1)$, where $K$ typically has a range of $[5,20]$. Then, the new probability distribution is defined as: $$ P = \\frac{1}{1+exp(-(\\{c_{pos}\\} \\cup W_{neg}) \\cdot h)} \\in \\mathbb{R}&#94;{K+1}$$ $K=20$ is used for small corpus, and $K=5$ is used for big corpus. Negative sampling is much cheaper than vanilla Skip-Gram with softmax, because $K$ is between 5 ~ 20, whereas $V$ can be millions. Moreover, no extra iterations are necessary to compute the normalization factor in the denominator, because sigmoid function is a binary regression classifier. The algorithm complexity of the probability distribution of vanilla Skip-Gram is $O(V)$, whereas negative sampling's is $O(K+1)$. This shows why negative sampling saves a significant amount of computational cost per iteration. In gensim , negative sampling is applied by default with Word2Vec(negative=5, ns_exponent=0.75) , where negative is the number of $K$-negative samples, and ns_exponent is a hyperparameter related to negative sampling, of range $(0, 1)$. The details of the methodology behind negative sampling deserves another fully devoted post, and as such, covered in a different post . Training: Backward Propagation Backward propagation involves computing prediction errors, and updating the weight matrix ($\\theta$) to optimize vector representation of words. Assuming stochastic gradient descent , we have the following general update equations for the weight matrix ($\\theta$): $$ \\theta_{new}=\\theta_{old}-\\eta\\cdot\\nabla_{J(\\theta;w&#94;{(t)}}) \\tag{15} $$ $\\eta$ is learning rate, $\\nabla_{J(\\theta;w&#94;{(t)})}$ is gradient for the weight matrix, and $J(\\theta;w&#94;{(t)})$ is the cost function defined in eq (6) . Since the $\\theta$ is a concatenation of input and output weight matrices ($[W_{input} \\quad W_{output}]$) as described above , there are two update equations for each embedding matrix: $$ W_{input}&#94;{(new)}=W_{input}&#94;{(old)}- \\eta \\cdot \\frac{\\partial J}{\\partial W_{input}} \\tag{16} $$ $$ W_{output}&#94;{(new)}=W_{output}&#94;{(old)}- \\eta \\cdot \\frac{\\partial J}{\\partial W_{output}} \\tag{17} $$ Mathematically, it can be shown that the gradients of $W_{input}$ $W_{output}$ have the following forms: $$ \\frac{\\partial J}{\\partial W_{input}} = x \\cdot (W_{output}&#94;T \\sum&#94;C_{c=1} e_c) \\tag{18}$$ $$ \\frac{\\partial J}{\\partial W_{output}} = h \\cdot \\sum&#94;C_{c=1} e_c \\tag{19}$$ The gradients can be substitued into eq (16) and eq (17) : $$ W_{input}&#94;{(new)}=W_{input}&#94;{(old)}- \\eta \\cdot x \\cdot (W_{output}&#94;T \\sum&#94;C_{c=1} e_c) \\tag{20} $$ $$ W_{output}&#94;{(new)}=W_{output}&#94;{(old)}- \\eta \\cdot h \\cdot \\sum&#94;C_{c=1} e_c \\tag{21} $$ $W_{input}$ is input weight matrix , $W_{output}$ is output weight matrix , $x$ is one-hot encoded input layer , $C$ is window size , and $e_{c}$ is prediction error for $c$-th context word in the window. Note that $h$ (hidden layer) is equivalent to $W_{input}&#94;T x$. Notes: Applying softmax Although eq (21) does not explicitly show it, softmax function is applied in the prediction error ($e_c$). Prediction error is the difference between the predicted and true probability ($y_{pred} - y_{true}$) as illustrated below . The predicted probability $y_{pred}$ is computed using softmax function using eq (13) . Prediction Error ($y_{pred} - y_{true}$) Skip-Gram model optimizes the weight matrix ($\\theta$) to reduce the prediction error. Prediction error is the difference between the probability distribution of words computed from the softmax output layer ($y_{pred}$) and the true probability distribution ($y_{true}$) of the $c$-th context word. Just like the input layer, $y_{true}$ is one-hot encoded vector, in which only one element in the vector that corresponds to the $c$-th context word is $1$, and the rest is all $0$. Figure 11: Prediction error window The figure has a window size of $2$, so two prediction errors were computed. Recall from the above notes about the window size that the original softmax regression classifier ( eq (10) ) has $K$ labels to classify, in which $K = V$ in NLP applications because there are $V$ words to classify. Employing window size transforms eq (10) into eq (11) and significantly reduces the algorithm complexity because the model only needs to compute prediction errors for $[1, 10]$ neighboring words, instead of computing all $V$-prediction errors for all vocabs that can be millions or more. Then, prediction errors for all $C$ context words are summed up to compute weight gradients to the update weight matrices. Figure 12: Sum of prediction errors Numerical Demonstration For the ease of illustration, screenshots from Excel will be used to demonstrate the concept of updating weight matrices through forward and backward propagations. Forward Propagation: Computing hidden (projection) layer Center word is \"passes\" . Window size is size=1 , making \"the\" and \"who\" context words. Hidden layer ($h$) is looked up from the input weight matrix. It is computed with eq (12) . Figure 13: Computing hidden (projection) layer Forward Propagation: Softmax output layer Output layer is a probability distribution of all words, given a center word. It is computed with eq (14) . Note that all context windows share the same output layer ($y_{pred}$). Only the errors ($e_c$) are different. Figure 14: Softmax output layer Backward Propagation: Sum of Prediction Errors $C$ different prediction errors are computed, then summed up. In this case, since we set window=1 above , only two errors are computed. Figure 15: Prediction errors of context words Backward Propagation: Computing $\\nabla W_{input}$ Gradients of input weight matrix ($\\frac{\\partial J}{\\partial W_{input}}$) are computed using eq (18) . Note that multiplying $W_{output}&#94;T \\sum&#94;C_{c=1} e_c$ with the one-hot-encoded input vector ($x$) makes the neural net to update only one word vector that corresponds to the input (center) word. Figure 16: Computing input weight matrix gradient $\\nabla W_{input}$ Backward Propagation: Computing $\\nabla W_{output}$ Gradients of output weight matrix ($\\frac{\\partial J}{\\partial W_{output}}$) are computed using eq (19) . Unlike the input weight matrix ($W_{input}$), all word vectors in the output weight matrix ($W_{output}$) are updated. Figure 17: Computing output weight matrix gradient $\\nabla W_{output}$ Backward Propagation: Updating Weight matrices Input and output weight matrices ($[W_{input} \\quad W_{output}]$) are updated using eq (20) and eq (21) . Figure 18: Updating $W_{input}$ Figure 19: Updating $W_{output}$ Note that for each iteration in the learning process, all weights in $W_{output}$ are updated, but only one row vector that corresponds to the center word is updated in $W_{input}$. When the model finishes updating both of the weight matrices, then one iteration is completed. The model then moves to the next iteration with the next center word. However, remember that this uses eq (8) as the cost function and assumes stochastic gradient descent . This means that one update is made for each training example. If eq (9) is used as a cost function instead (which is almost never the case), then one update is made for all $T$ training examples in the corpus.","tags":"Natural Language Processing","url":"https://aegis4048.github.io/demystifying_neural_network_in_skip_gram_language_modeling","loc":"https://aegis4048.github.io/demystifying_neural_network_in_skip_gram_language_modeling"},{"title":"Understanding Multi-Dimensionality in Vector Space Modeling","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement Some materials on this post are from CS224n: Natural Language Processing with Deep Learning at the Stanford University. Check out the YouTube Lecture on Word Vectors and Word Senses taught by Dr. Chris Manning . One of the critical components in Natural Langauge Processing (NLP) is to encode text information in a numerical format that can be fed into an NLP model. Such technique, representing words in a numerical vector space, is called Vector Space Modeling . It is often synonymous to word embedding . A typical vector space model that haven't went through dimensional reduction has a dimension of $V \\times N$, where $V$ is a size of unique vocabulary, and $N$ varies based on the choice of modeling method (Notes: in document-to-word embedding model like TF-IDF, $V$ is a number of documents and and $N$ is a size of unique vocabulary). In this context, $V$ is basically a sample data size — the larger the $V$, the bigger the training data set. It is always good to have more training data than the otherwise. Therefore, our prime interest lies within the size of $N$, which affects the multi-dimensionality of a vector space model. Here is a simple illustration of how words look like in a high dimensional vector space. Figure 1: simple 10-dimensional word vectors Consider the two semantically similar words, \"Success\" and \"Achieve\". When converted into 10-dimensional word vectors using a vector space model of one's choice (Ex: Word2Vec), each word is a $1 \\times 10$ vector where each value in a vector represent the word's position in a 10D space. When projected on this high dimensional vector space, the similarity between words can be quantified by evaluating the similarity between these two word vectors. Observe that the vectors in the illustration above looks similar to each other: positions of non-zero values, and values of each cell. Similar word vectors will put similar words close to each other in a vector space, and as a result, \"Success\" and \"Achieve\" will have small Euclidean or Cosine Distance. One might experience difficulty in trying to visualize the Euclidean or Cosine distance of the word vectors in a 10D vector space. In fact, you can't visualize anything bigger then 3D. If one attempts to visualize the word vectors in a 2D or 3D space, he will have to represent the word vectors in 2D or 3D space first using dimensional reduction. Let's assume that such dimensional reduction was performed and the word vectors for \"Success\" and \"Achieve\" are reduced to 3D vectors. The word vectors will then look like this: Figure 2: Dimensional-reduced word vectors visualization in 3D Observe the dissimilarity between two word vectors and their positions within the 3D vector space. This is because 3 dimensions are not enough to capture all relationship among words and as a result fails to maintain the semantic relationship between two similar words, \"Success\" and \"Achieve\". Multi-dimensionality in vector space modeling has great significance because it directly affects the performance of any NLP model. In this post, the concept and effect of multi-dimensionality in NLP will be illustrated using mainly Co-Occurence Matrix and some Word2Vec models. Review on Vector Space Model Techniques Before we talk about the significance of the size of dimensions ($N$), let us review how text information is transformed into a numerical matrix. Please feel free to skip this part if you are already knowledgable about this topic. There are two types of methods for word embedding: Frequency-Based Methods and Prediction-Based Methods . The below table lists some options we have for each type of embedding method. Frequency-Based Methods Prediction-Based Methods Count Vector Continuous Bag of words TF-IDF Doc2Vec Co-Occurence Matrix Word2Vec Frequency-based methods are pretty straightforward to understand. It counts how many times each word appeared in each document, or how many times each word appeared together with each words. Co-Occurence Matrix is a type of frequency-based methods. Co-Occurence Matrix The value of $N$ for co-occurence matrix is the size of unique vocabulary. In the other words, co-occurence matrix is a square matrix of size $V \\times V$. Consider a co-occurence matrix with a fixed window size of $n=1$. Setting window size $n=1$ will tell the model to search adjacent context words that are positioned directly left or right of a center word. The matrix is contructed using the following two input documents: Document 1: \"all that glitters is not gold\" Document 2: \"all is well that ends well\" * START all that glitters is not gold well ends END START 0 2 0 0 0 0 0 0 0 0 all 2 0 1 0 1 0 0 0 0 0 that 0 1 0 1 0 0 0 1 1 0 glitters 0 0 1 0 1 0 0 0 0 0 is 0 1 0 1 0 1 0 1 0 0 not 0 0 0 0 1 0 1 0 0 0 gold 0 0 0 0 0 1 0 0 0 1 well 0 0 1 0 1 0 0 0 1 1 ends 0 0 1 0 0 0 0 1 0 0 END 0 0 0 0 0 0 1 1 0 0 Table 1: Co-Occurence Matrix Notes: START and END tokens In NLP, we often add START and END tokens to represent the beginning and end of sentences, paragraphs or documents. In thise case we imagine START and END tokens encapsulating each document, e.g., \"START All that glitters is not gold END\", and include these tokens in our co-occurrence counts. This co-occurence matrix is essentially a vector space model of $V$-dimensional ($V$ columns) matrix, in which $V = 10$. However, in most NLP tasks, this co-occurence matrix goes through PCA or SVD for dimensional reduction and decomposed into a new $k$-dimensional matrix. * $k_{1}$ $k_{2}$ START 0.705 0.484 all 0.705 -0.484 that 0.654 -0.783 glitters 0.52 0 is 1.027 0 not 0.654 0.783 gold 0.382 0.656 well 0.382 -0.656 ends 1.394 -1.061 END 1.394 1.061 Table 2: Dimension Reduced Co-Occurence Matrix The original matrix was 10D matrix (10 columns) — this can't be visualized. Humans can understand only up to 3D visualizations. However, dimensional reduction was performed with sklearn.decomposition.TruncatedSVD(n_components=2) , and the output table yielded a new matrix with reduced dimension of $k = 2$. This was because I set n_components = 2 . The word vectors can now be visualized in a 2D space. Further discussions about the choice of n_components and dimensional reduction will be followed in the later section of this post. Figure 3: Dimensional-reduced word vectors visualization in 2D Word2Vec Contrary to frequency-based methods, prediction-based methods are more difficult to understand. As the name 'prediction' implies, their methodologies are based on predicting context words given a center word ( Word2Vec Skip-Gram: $P(w_{context} \\mid w_{center})$), or a center word given context words ( Continuous Bag of Words: $P(w_{center} \\mid w_{context})$). Prediction-based methods use neural network algorithm, which means that we have to worry about the number of neurons (weights) in a network. In Word2Vec model, the model matrix has a dimension of $V \\times N$, where $V$ is the size of unique vocabulary and the size of $N$ is the number of neurons in a network. Figure 3: Skip-Gram algorithm structure for Word2Vec During the forward and back propagation process, the weights in Matrix $W$ ( Embedding matrix ) of size $V \\times N$ and Matrix $W'$ ( Context matrix ) of size $N \\times V$ are optimized to minimize a loss function. Recall that the number of neurons ($N$) is a hyper-parameter that needs to be empirically optimized. Choosing different values for $N$ will yield different output performances. $N = 300$ is a dimensional parameter known to work well with Word2Vec models. Note that a matrix with a dimension of 300 cannot be visualized. However, the dimension can be reduced down to 2D or 3D using t-distributed stochastic neighbor embedding (t-SNE) , or PCA. For NLP visualization purpose, T-SNE is often preferred over PCA or SVD due to its ability to reduce high dimensions to low dimensions while capturing complex relationships with neighboring wods. More comparison about PCA vs T-SNE will be illustrated later. Notes: Word2Vec algorithm The theory behind Word2Vec skip-gram algorithm maybe complex and difficult to understand for beginners. I encourage you to read the following two and articles that explain the theory. They do it quite well. Why is Multi-Dimensionality Important? First , high dimensionality leads to high computational cost. This is especially true in the case of co-occurence matrix, in which it has a dimension of $V \\times V$, where $V$ is the size of vocabulary in a corpus. The previous example shown in Table 1 had a corpus size of 12 words, and vocab size of 10 words. In real-life applications, corpus size easily exceeds 10's or 100 GB's. For example, Gensim 's pre-trained Word2Vec model trained from Google News had a vocab size of three million ( Github Source ). If we obtain a co-occurence matrix and feed it into an NLP model without dimensional reduction, we will be training our model with a matrix size of $3M \\times 3M$. This is unrealistic. We need to choose an optimal value for reduced dimension $k$ that will best describe the variability of the data while significantly cutting down the computational cost. On the other hand, computational cost due to high dimensionality is NOT a big concern with Word2Vec, because the most optimal dimension for Word2Vec are already known to be between 200 - 600 (Note: this doesn't mean that Word2Vec is superior to co-occurence matrix. Each has its own pros and cons). It is natural to think that high dimension would lead to higher accuracy, but this happens at the cost of increased computation time. One needs to find a \"sweet spot\" that optimizes the trade-off between accuracy vs. computation time. The recent paper submitted in Dec 2018 proposed a deterministic way to compute the optimal number of $k$-dimensions. It's code implementation is available on this Github repo . Second , dimension is a critical parameter in word embedding. Too low dimension leads to underfitting and makes your model not expressive enough to capture all possible word relations. On the other hand, too high dimension results in overfitting. However, in the recent paper , it was discovered that Word2Vec and GloVe models are not sensitive to overfitting. Figure 4: skip-gram Word2Vec: over-parametrization does not significantly hurt performance Figure 5: GloVe: over-parametrization does not significantly hurt performance The spikes of the skip gram Word2Vec and and GloVe models revealed the existence of the \"sweet spot\" in which a certain number of dimensions leads to the highest accuracy. The sharp rise in accuracy in the far left zone showed that too low number of dimensions results in underfitting. However, it is interesting to note that the flat right tail of the charts showed that indefinitely increasing the number of dimensions did not really result in overfitting. Often times in neural net applications, too high number of dimensions (neurons) results in overfitting, but in skip-gram Word2Vec and GloVe, this was not the case. A typical good NLP model trained on a wide variety of corpora has a dimension in the order of hundreds. The famous Mikolov et al. 2013 paper on skip-gram Word2Vec model suggests 300 neurons, and Rohde et al. ms., 2005 paper on co-occurence/correlation matrix suggests 600-800 dimensions (columns) as the optimum parameters for vector space modeling. Vector Space Modeling: Crude Oil News Figure 6: International news organization, Reuters Enough of theories. Now let's dive into the actual application of vector space modeling with Python code implementation. We will explore multi-dimensionality in NLP task using Reuters news articles on crude oil . Take a glance at the overall content of the crude oil articles with the following WordCloud visualizaiton. Figure 7: WordCloud of crude oil articles Imports Here is all the imports you need to follow with this tutorial. In [2]: import pandas as pd import numpy as np import nltk nltk . download ( 'reuters' ) from nltk.corpus import reuters from sklearn.decomposition import TruncatedSVD import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D % matplotlib notebook [nltk_data] Downloading package reuters to [nltk_data] C:\\Users\\EricKim\\AppData\\Roaming\\nltk_data... [nltk_data] Package reuters is already up-to-date! Sample Data Description First, you will have to download the articles. NLTK provides a nice api that allows us to download the digitized articles. In [3]: import nltk nltk . download ( 'reuters' ) from nltk.corpus import reuters [nltk_data] Downloading package reuters to [nltk_data] C:\\Users\\EricKim\\AppData\\Roaming\\nltk_data... [nltk_data] Package reuters is already up-to-date! In [4]: data = [] for fileid in reuters . fileids (): category = reuters . categories ( fileid ) text = reuters . raw ( fileid ) data . append ([ fileid , category , text ]) df_reuters = pd . DataFrame ( data , columns = [ 'File ID' , 'Category' , 'Text' ]) In [5]: df_reuters . head ( 10 ) Out[5]: File ID Category Text 0 test/14826 [trade] ASIAN EXPORTERS FEAR DAMAGE FROM U.S.-JAPAN RI... 1 test/14828 [grain] CHINA DAILY SAYS VERMIN EAT 7-12 PCT GRAIN STO... 2 test/14829 [crude, nat-gas] JAPAN TO REVISE LONG-TERM ENERGY DEMAND DOWNWA... 3 test/14832 [corn, grain, rice, rubber, sugar, tin, trade] THAI TRADE DEFICIT WIDENS IN FIRST QUARTER\\n ... 4 test/14833 [palm-oil, veg-oil] INDONESIA SEES CPO PRICE RISING SHARPLY\\n Ind... 5 test/14839 [ship] AUSTRALIAN FOREIGN SHIP BAN ENDS BUT NSW PORTS... 6 test/14840 [coffee, lumber, palm-oil, rubber, veg-oil] INDONESIAN COMMODITY EXCHANGE MAY EXPAND\\n Th... 7 test/14841 [grain, wheat] SRI LANKA GETS USDA APPROVAL FOR WHEAT PRICE\\n... 8 test/14842 [gold] WESTERN MINING TO OPEN NEW GOLD MINE IN AUSTRA... 9 test/14843 [acq] SUMITOMO BANK AIMS AT QUICK RECOVERY FROM MERG... In [6]: len ( df_reuters ) Out[6]: 10788 There are a total of 10,788 articles. To our convinience, the articles are already labeled with their respective categories. This helps us in a case we want to perform further analysis and run supervised learning. But we won't be running any supervised learning in this post. But instead, we will extract only the articles that are in the category of crude . In the other words, only the articles that talk about crude oil. In [7]: df_crude = df_reuters [ df_reuters [ 'Category' ] . apply ( lambda x : 'crude' in x )] df_crude . head ( 10 ) Out[7]: File ID Category Text 2 test/14829 [crude, nat-gas] JAPAN TO REVISE LONG-TERM ENERGY DEMAND DOWNWA... 123 test/15063 [acq, crude, earn, pet-chem] ENERGY/U.S. PETROCHEMICAL INDUSTRY\\n Cheap oi... 187 test/15200 [crude] TURKEY CALLS FOR DIALOGUE TO SOLVE DISPUTE\\n ... 205 test/15230 [crude] IRAQI TROOPS REPORTED PUSHING BACK IRANIANS\\n ... 209 test/15238 [crude, earn] UNION TEXAS OIL RESERVES DROPPED IN 1986\\n Un... 214 test/15244 [crude] GHANA TO BUY CRUDE OIL FROM IRAN\\n Ghana will... 257 test/15322 [crude, nat-gas] U.S.SENATE LIFTS SOME BANS ON NATURAL GAS\\n T... 266 test/15339 [crude, gas] EIA SAYS DISTILLATE STOCKS UNCHANGED, GASOLINE... 268 test/15344 [crude, gas] EIA SAYS DISTILLATE STOCKS UNCHANGED IN WEEK\\n... 272 test/15351 [crude, gas] RECENT U.S. OIL DEMAND OFF 2.6 PCT FROM YEAR A... In [8]: df_crude . shape Out[8]: (578, 3) There are 578 articles that talk about crude oil. Constructing Co-Occurence Matrix We will build co-occurence matrix that looks like Table 1 above. Before we build the matrix, we need to consider tokenization and window size . Tokenization Tokenization is a process of splitting sentences into separate words. Tokenization usually isn't as simple as splitting senteces based on space bars. It is usually a very complicated process that involves heavy regex manipulation, lemmatization, stemming, and some hard-coding with different rules for different cases. For example, converting 'unchanged' to 'unchange', 'stocks' to 'stock', 'pushing' to 'push', 'is, was, being', to 'be'. Or treating multi-words as one word, such as 'in spite of', 'no matter of', 'Panda Express', 'North America', or 'beat down'. Or dealing with punctuations, such as 'Parskin-disease', 'one-to-one' or 'O'reilly'. And many more. Tokenization won't be covered in detail in this post, because complex tokenization is not necessary for the purpose of explaining multi-dimensinoality in NLP. However, please do note that you will need advanced tokenization scheme in real-life applications. On the other hand, NLTK has a convinient package that allows you to check if a word is within the corpora of English. However, this does not remove punctuations. The basic use case looks like this: >>> from nltk.corpus import words >>> \"fine\" in words.words() True We will split the sentences using nltk.corpus.reuters.words() . In [52]: def read_corpus ( category = '' ): files = reuters . fileids ( category ) return [[ 'START' ] + [ w . lower () for w in list ( reuters . words ( f ))] + [ 'END' ] for f in files ] In [53]: corpus_crude = read_corpus ( category = [ 'crude' ]) In [54]: pd . DataFrame ( corpus_crude ) . head ( 10 ) Out[54]: 0 1 2 3 4 5 6 7 8 9 ... 991 992 993 994 995 996 997 998 999 1000 0 START japan to revise long - term energy demand downwards ... None None None None None None None None None None 1 START energy / u . s . petrochemical industry cheap ... . economy continues its modest rate of growth . END 2 START turkey calls for dialogue to solve dispute turkey said ... None None None None None None None None None None 3 START iraqi troops reported pushing back iranians iraq said today ... None None None None None None None None None None 4 START union texas oil reserves dropped in 1986 union texas ... None None None None None None None None None None 5 START ghana to buy crude oil from iran ghana will ... None None None None None None None None None None 6 START u . s . senate lifts some bans on ... None None None None None None None None None None 7 START eia says distillate stocks unchanged , gasoline off 200 ... None None None None None None None None None None 8 START eia says distillate stocks unchanged in week distillate fuel ... None None None None None None None None None None 9 START recent u . s . oil demand off 2 ... None None None None None None None None None None 10 rows × 1001 columns Choice of Window Size On of the critical variable in co-occurence matrix is window_size . The below illustration has a window size of 2. Figure 8: Illustration of window size A typical window size is chosen between 2-10. However, window size may exceed way over 10 in case of special circumstances, such as having too few data. Increasing window size may increase the accuracy of the model, but it comes at the price of computational cost, and sometimes loss in accuracy due to noise. The author of this paper claims that he observed decrease in model performance of his co-occurrence matrix when he used high window size with large corpus. However, he observed the opposite when high window size was used with smaller corpus. Figure 9: Effect of window size and corpus size Matrix Construction In [55]: def compute_co_occurrence_matrix ( corpus , window_size = 4 ): distinct_words = sorted ( list ( set ([ word for sentence in corpus for word in sentence ]))) num_words = len ( distinct_words ) word2Ind = { word : index for index , word in enumerate ( distinct_words )} M = np . zeros (( num_words , num_words )) for sentence in corpus : for i , word in enumerate ( sentence ): begin = max ( i - window_size , 0 ) end = min ( i + window_size , num_words ) context = sentence [ begin : end + 1 ] context . remove ( sentence [ i ]) current_row = word2Ind [ word ] for token in context : current_col = word2Ind [ token ] M [ current_row , current_col ] += 1 return M , word2Ind In [56]: reuters_corpus = read_corpus ( 'crude' ) M_co_occurrence , word2Ind_co_occurrence = compute_co_occurrence_matrix ( reuters_corpus , window_size = 5 ) In [57]: pd . DataFrame ( M_co_occurrence , index = word2Ind_co_occurrence . keys (), columns = word2Ind_co_occurrence . keys ()) . head ( 10 ) Out[57]: \" \"( \", \"... $ & ' ( ) )\" ... zinc zoete zollinger zone zones zubedei zubeidi zuheir zulia zverev \" 88.0 0.0 1.0 0.0 1.0 2.0 78.0 17.0 7.0 0.0 ... 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 \"( 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \", 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 \"... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 $ 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 & 2.0 0.0 0.0 0.0 0.0 12.0 31.0 8.0 4.0 0.0 ... 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ' 78.0 0.0 0.0 0.0 0.0 31.0 22.0 8.0 5.0 0.0 ... 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 ( 17.0 0.0 0.0 0.0 0.0 8.0 8.0 6.0 220.0 1.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ) 7.0 1.0 0.0 0.0 0.0 4.0 5.0 220.0 2.0 0.0 ... 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 )\" 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 10 rows × 8185 columns Notes: Effect of punctuatoins Be cautious when dealing with punctuations. Although the effect of punctuations in NLP is beyond the scope of this post, please note that punctuations often have their own roles to play in NLP applications. Ex: Parkinson-disease vs Parkinson's disease. Sometimes they may be simply removed, and sometimes they shouldn't be. Dimensional Reduction Dimensional reduction is necessary in most of the machine learning problems. It is used to reduce computational cost of optimization model, and to mitigate the issue of correlated features. For example, column 1 and column 2 are independent, but column 2, 3 and 4 may be correlated with one another by some relationship like: $$col_2 = log{(col_3 + col_4 ) / 2}$$ This kind of correlationship may not be visible to an engineer, and may cause problems when left unmitigated. Dimensional reduction is especially necessary in the case of co-occurence matrix due to the size of the matrix, as it was mentioned above . Recall that co-occurence matrix has a dimension of $V \\times V$, where $V$ is the size of unique vocabulary. Often times vocabulary size easily exceeds tens of thousand, and it is unrealistic to run a machine learning model on such a matrix due to time constraint. Moreover, co-occurrence matrix is a very sparse matrix. Take a look at the above Pandas DataFrame of the co-occurrence matrix. You will notice that most of the values are zero, which doesn't add much value to the matrix. Dimensional reduction will make the matrix more compact to convey \"most\" of the \"useful\" information. sklearn.decomposition.TruncatedSVD will be used for dimensional reduction. Notes: Two algorithms of TruncatedSVD TruncatedSVD has two options of algorithms. \"arpack\" and \"randomized\" . \"arpack\" has an algorithm complexity of $O(m \\times n \\times k)$, and \"randomized\" has $O(m \\times n \\times log(k))$. In theory, \"arpack\" is supposed to be better in terms of accuracy, but \"randomized\" is much faster by an order of magnitude, and claimed to be as nearly accurate as \"arpack\" . The default of Scipy implementation is \"randomized\" . In [15]: def reduce_to_k_dim ( M , n_components = 2 ): svd = TruncatedSVD ( n_components = n_components , n_iter = 10 , random_state = 42 ) M_reduced = svd . fit_transform ( M_co_occurrence ) print ( 'n_components =' , n_components ) print ( 'Explained Variance =' , round ( svd . explained_variance_ratio_ . sum (), 3 )) return M_reduced In [16]: reuters_corpus = read_corpus ( 'crude' ) M_co_occurrence , word2Ind_co_occurrence = compute_co_occurrence_matrix ( reuters_corpus , window_size = 5 ) M_reduced_2 = reduce_to_k_dim ( M_co_occurrence , n_components = 2 ) n_components = 2 Explained Variance = 0.906 In [17]: pd . DataFrame ( M_reduced_2 , columns = [ '$k_ {1} $' , '$k_ {2} $' ]) . head ( 10 ) Out[17]: $k_{1}$ $k_{2}$ 0 861.598711 -92.837976 1 1.523025 -0.235919 2 0.299002 0.054687 3 0.895219 -0.383224 4 1.626508 -0.125964 5 158.617460 -26.523809 6 975.388537 250.237303 7 211.345647 30.294191 8 162.468186 -12.582009 9 1.272724 -0.197958 The original $8185 \\times 8185$ co-occurence matrix was reduced into 2-dimensional matrix of $8185 \\times 2$, using dimensional reduction with n_components=2 . According to the explained_variance_ratio_ , the new reduced matrix captures 90.6% variability of the original data with window_size=5 . This may not be satisfactory, but good enough to obtain a reasonable word vector visualizaiton on a 2D space. We can also try different values of n_components . In [18]: M_reduced_3 = reduce_to_k_dim ( M_co_occurrence , n_components = 3 ) n_components = 3 Explained Variance = 0.923 In [19]: M_reduced_10 = reduce_to_k_dim ( M_co_occurrence , n_components = 10 ) n_components = 10 Explained Variance = 0.972 In [20]: M_reduced_50 = reduce_to_k_dim ( M_co_occurrence , n_components = 50 ) n_components = 50 Explained Variance = 0.993 In [21]: M_reduced_100 = reduce_to_k_dim ( M_co_occurrence , n_components = 100 ) n_components = 100 Explained Variance = 0.996 Notes: explained_variance_ratio_ Performing dimensional reduction inevitably results in loss of some data in the original matrix. It is a natural phenomenon considering how we are reducing $8185 \\times 8185$ matrix all the way down to $8185 \\times 2$ matrix. We can quantify the loss in data using explained_variance_ratio_ . I won't cover the details of this property, but long story short, it's good if explained_variance_ratio_ is close to 100%. Reducing the matrix to high $k$-dimension will result in smaller loss of data at the cost of high computational load, and vice versa. If you are interested in learning a deterministic way to decide the optimal value of $k$, take a look at this paper . Word Vectors Visualization The original word vector had 8185-dimension, but now its reduced down to 2-dimension and 3-dimension, which can be visualized on a 2D and 3D plane. Normalization Rescaling (normalization) needs to be done on rows to make each of them unit-length. Skipping this step will result in your visualization looking unbalanced. In [23]: # normalize M_lengths_2 = np . linalg . norm ( M_reduced_2 , axis = 1 ) M_normalized_2 = M_reduced_2 / M_lengths_2 [:, np . newaxis ] M_lengths_3 = np . linalg . norm ( M_reduced_3 , axis = 1 ) M_normalized_3 = M_reduced_3 / M_lengths_3 [:, np . newaxis ] Visualization In [24]: # Axes3D needs to be imported in case of plotting 3D visualizations from mpl_toolkits.mplot3d import Axes3D In [25]: def plot_embeddings ( M_reduced , word2Ind , words , ax ): dimension = M_reduced . shape [ 1 ] assert ( dimension == 3 or dimension == 2 ) for i , word in enumerate ( words ): index = word2Ind [ word ] embedding = M_reduced [ index ] if dimension == 3 : x , y , z = embedding [ 0 ], embedding [ 1 ], embedding [ 2 ] ax . scatter ( x , y , z , color = 'red' ) ax . text ( x , y , z , word ) else : x , y = embedding [ 0 ], embedding [ 1 ] ax . scatter ( x , y , marker = 'x' , color = 'red' ) ax . text ( x , y , word ) return fig , ax Choice of words to visualize Recall that there are 8185 unique vocabulary in our data. Visualizing all of them on a plot will won't be very informative, because readers won't be able to distinguish between words because they are too densely plotted. In [26]: # choose words to visualize words = [ 'bank' , 'barrels' , 'bpd' , 'ecuador' , 'energy' , 'industry' , 'oil' , 'petroleum' , 'output' , 'produce' , 'occidental' , 'mobil' , 'exxon' , 'electricity' , 'kilowatt' , 'china' , 'paris' , 'saudi' , 'norway' , 'blockading' , 'expert' , 'yen' , 'kuwaiti' , 'kuwait' , 'persian' , 'eia' , 'gulf' , 'bp' , 'uk' , 'gas' , 'europe' , 'allocated' , 'lacks' , 'militarily' , 'discouraged' , 'violations' , 'possibly' ] In [27]: fig = plt . figure () fig . suptitle ( 'Word Vector Visualizations' ) # First subplot ax1 = fig . add_subplot ( 1 , 2 , 1 ) ax1 = plot_embeddings ( M_normalized_2 , word2Ind_co_occurrence , words , ax1 ) # Second subplot ax2 = fig . add_subplot ( 1 , 2 , 2 , projection = '3d' ) ax2 = plot_embeddings ( M_normalized_3 , word2Ind_co_occurrence , words , ax2 ) Dimensionality Analysis on Visualizations 3D visualizations can be viewed from different angles. What will they look like in different angles? Let's take a look. Figure 10: 3D plot - angle 1 Figure 11: 3D plot - angle 2 Figure 12: 3D plot - angle 3 Interesting Observations: First , when viewed from a certain angle, the 3D plot looks exactly like the 2D plot. However, different patterns can be observed when viewed from a different angle. Second , the distance of \"violations\" and \"discouraged\" are different. They are close to each other on Figure 10 , but far away from each other on Figure 11 & 12 . Third , similar pattern was found between \"kilowatt\" and \"electricity\" . As you know, \"kilowatt\" is an unit of \"electricity\" . That is why they are close on Figure 11 & 12 , but are separated in Figure 10 . Observe how \"electricity\" is close, but \"kilowatt\" is not to the cluster of oil-producing entities in Figure 10 . A possible explanation is that \"electricity\" is not oil, but similar to oil in a sense that it is a \"type\" of energy consumed. On the other hand, although \"kilowatt\" is a unit of energy, but it is not a type of energy. Fourth , \"barrels\" and \" bpd \" are always close to one another. They seem very close on all three plots shown above, and indeed they look close on other angles as well. Due to time and space constraint, I can't take a screenshot of every possible angles and put it here, but I observed that they are always close on any angles. This makes sense, considering \"bpd\" stands for \"barrels per day\". Fifth , \"paris\" was group together with \"barrels\" and \"bpd\" . They have nothing in common, and yet they were grouped together. The model failed to project \"paris\" on a right vector space. Sixth , the co-occurrence vector space model was able to capture the cluster of oil producers. \"occidental\" is for Occidental Petroleum Corporation (or Oxy), and \"exxon\" is for Exxon Mobil, the two major oil-producing companies in the US. And \"gulf\" for the Gulf of Mexico, one of the biggest offshore oil-producing region in the world. Seventh , \"eia\" was not inside the cluster of oil producers in most of the angles. This is noteworthy because EIA (U.S. Energy Information Administration) provides energy statistics, such as oil & gas production, consumption, export and export rate. However, it is not a \"producing\" entity. The model was able to differentiate between an entity who \"talks\" about the oil-production, and the entities who actually \"produce\" oil. Eighth , the model was not able to differentiate nations (Kuwait, Norway, China, UK) from the other entities. A well trained Word2Vec model with 300-dimensions is able to distinguish among nations, cities, and companies, but this one couldn't. Warning! Previously I said that a good co-occurrence matrix model has a dimension of 600-800. However, the explained_variance_ratio_ was 92.3%, which is reasonably good, and the 3D visualizations seemed to capture the relationship among words pretty well. This happend because: 1. the purpose of this post was to explain dimensionality If you attempt to feed the co-occurrence matrix of 3-dimensions into a machine learning model, it will NOT perform well. It \"seems\" to work well because it was used only for visualizations. 2. the data had limited scope of topics: crude oil Having limited scope of topics really simplfies the complexity of problem. If the training data had all sorts of articles (Ex: toiles, water bottles, nuclear, desk, paper, insects, milk, gas, school, trash), this will not work well. Conclusion It is known that a well trained Word2Vec model has 300 dimensions. Think of each dimension in Word2Vec vector space as an entity that represents word relationships: man vs woman, objects vs living, humans vs animals, nation vs city, drink vs food, action vs concept, and many more. Assume that that there are 300 of these kinds of relationships among all words in this world, represented by a single dimension per relationship. The 3D visualization from the co-occurrence matrix model was able to capture the cluster of oil-producing entities ( Sixth observation). But it wasn't able to differentiate between nations and companies, because it simply didn't have a dimension that captures that kind of relationship ( Eighth observation). In Figure 10 , the model sensed the negative feelings that \"discouraged\" and \"violations\" conveyed, and put them in a close vector space ( Second observation). But when viewed from a different angle, or to put it better, viewed from a different dimension, the model put them far apart because they do not convey similar meanings ( Figure 11 & 12 ). On the other hand, the model completely failed to distinguish between \"paris\" vs \"barrels\" + \"bpd\" ( Fifth observation). Recall that our explained_variance_ratio_ for 3-dimension was 92.3% above . Some information about \"paris\" could've been lost during dimensional reduction and that might have caused the error in word vector projection on a 3D vector space. Or, we simply did not have sufficient training data. Having more dimensions allows a model to capture more complex relationships among words, and that's precisly why Google's Word2Vec model had 300 dimensions.","tags":"Natural Language Processing","url":"https://aegis4048.github.io/understanding_multi-dimensionality_in_vector_space_modeling","loc":"https://aegis4048.github.io/understanding_multi-dimensionality_in_vector_space_modeling"},{"title":"Transforming Non-Normal Distribution to Normal Distribution","text":"In the field of statistics, the assumption of normality is important because many statistical techniques perform calculations assuming the data is normally distributed. The techniques that assume Gaussian or Gaussian-like distribution are listed below: Techniques That Assume Normality Hypothesis testing through t-test and z-test Analysis of variance (ANOVA) Sequential Gaussian simulation in spatial analysis Control limits in control chart Unfortunately, many real-life data are not normal. Permeability distribution of rock samples is lognormal. Time required to repair a malfunctioning component follows exponential distribution, and reliability analysis for machine performance with respect to time follows Weibull distribution. What should you do if your data fails a normality test, or is not Gaussian-like? You have three options: Use it as it is or fit non-normal distribution Try non-parametric method Transform the data into normal distribution 1. Use it as it is or fit non-normal distribution Altough your data is known to follow normal distribution, it is possible that your data does not look normal when plotted, because there are too few samples. For example, test scores of college students follow a normal distribution. If you know for certain that your data is normally distributed by nature, then according to the Central Limit Theorem, your data will eventually become normal when you obtain a greater number of sample data. This means that you can still use the famous standard deviation method to assign letter grades to students as shown in figure (1) , even if your students' test scores do not look normally distributed. If you increase the number of students that takes your exam, the test score distribution will become more normal according to the Central Limit Theorem. Figure 1: assigning letter grades with standard deviation On the other hand, if you have plenty enough samples to represent the true population, you can fit different types of distributions to better describe your data. Different methods exist for different distributions and maybe you will be able to achieve your goal without using techniques that strictly require Gaussian distribution. The code snippet below fits three different distributions on the sample data: lognormal, normal, and Weibull distributions. Through a visual inspection, it can be observed that the sample data is the best represented by a lognormal distribution . Once we know that the sample data follows lognormal distribution, we can move forward by employing techniques that assume lognormal distribution. In [12]: import numpy as np import matplotlib.pyplot as plt from scipy import stats % matplotlib notebook In [4]: # sample data generation np . random . seed ( 42 ) data = sorted ( stats . lognorm . rvs ( s = 0.5 , loc = 1 , scale = 1000 , size = 1000 )) # fit lognormal distribution shape , loc , scale = stats . lognorm . fit ( data , loc = 0 ) pdf_lognorm = stats . lognorm . pdf ( data , shape , loc , scale ) # fit normal distribution mean , std = stats . norm . fit ( data , loc = 0 ) pdf_norm = stats . norm . pdf ( data , mean , std ) # fit weibull distribution shape , loc , scale = stats . weibull_min . fit ( data , loc = 0 ) pdf_weibull_min = stats . weibull_min . pdf ( data , shape , loc , scale ) In [5]: # visualize fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( data , bins = 'auto' , density = True ) ax . plot ( data , pdf_lognorm , label = 'lognorm' ) ax . plot ( data , pdf_norm , label = 'normal' ) ax . plot ( data , pdf_weibull_min , label = 'Weibull_Min' ) ax . set_xlabel ( 'X values' ) ax . set_ylabel ( 'probability' ) ax . legend (); Notes: Normality test with hypothesis testing Visual inspection is one option to assess the performance of the fitted distributions. The other option is to use hypothesis testing with Q-Q plots to numerically assess the performance of the fitted distribution. For example, if you want to numerically assess how well your data matches Gaussian distribution, you can test your hypothesis through D'Agostino-Pearson normality test, Anderson-Darling Test, or Shapiro-Wilk Test. Normality test with D'Agostino using scipty.stats.normaltest() is covered below . 2. Try non-parametric method There are pros and cons for using non-parametric methods. The biggest pros is that it does not assume anything about the distribution. They are distribution-free . You do not need to know distribution shape, mean, standard devation, skewness, kurtosis, etc... All you need is just a set of sample data that is representative of a population. The fact that it does not assume anything about the distribution has another implication when you have small number of data - there's no need for Central Limit Theorem to be applied. Recall that the Central Limit Theorem states that the data will become more and more Gaussian-distributed as the number of samples increases. Techniques that assume normality of a distribution expect the sample data to follow Central Limit Theorem. Non-parametric methods improves the performance of statistical calculation when there are too few number of samples that the Central Limit Theorem can't be applied. However, it is important that those few samples are reasonably representative of the true population. If they are not, your result will be biased. Non-parametric methods are geared toward hypothesis testing rather than estimation. Disadvantages of non-parametric methods include lack of power compared to more traditional approaches that require prior knowledge of a distribution. If you knew the distribution of your data with 100% certainty, there is no reason to use a non-parametric method. Doing so would be a waste of perfectly good prior knowledge. Another disadvantage is that many non-parametric methods are computation intensive. For example, Boostrapping is a non-parametric resampling method. It can be used to compute confidence interval of statistics, but requires numerical iterations, whereas computing confidence interval with parametric methods does not require iterations. The following table lists non-parametric alternatives to techniques that assume normality of a distribution: Techniques That Assume Normality Non-Parametric Alternatives Confidence Interval with z-test Bootstrapping T-test Mann-Whitney test; Mood's median test; Kruskal-Wallis test ANOVA Mood's median test; Kruskal-Willis test Paired t-test One-sample sign test F-test; Bartlett's test Levene's test Individuals control chart Run Chart Notes Parametric methods are the type of methods that assume a certain shape of a distribution. For example, the following equation is used to calculate the confidence interval of a mean of a distribution: $$\\text{CI of mean} = \\text{sample mean} \\pm (\\text{distribution score} \\times \\text{Standard Error} )$$ The variable in the equation, distribution score , depends on the type of the distribution. If you do not know the distribution shape of your data, it is very difficult to obtain the value of the distribution score. On the other hand, non-parametric methods do not assume anything about a distribution. A non-parametric alternative to calculate confidencer interval of mean is to use Bootstrapping . 3. Transform the data into normal distribution The data is actually normally distributed, but it might need transformation to reveal its normality. For example, lognormal distribution becomes normal distribution after taking a log on it. The two plots below are plotted using the same data, just visualized in different x-axis scale. Observe how lognormal distribution looks normal when log is taken on the x-axis. In [6]: import numpy as np import matplotlib.pyplot as plt from scipy import stats % matplotlib notebook In [7]: # sample data generation np . random . seed ( 42 ) data = sorted ( stats . lognorm . rvs ( s = 0.5 , loc = 1 , scale = 1000 , size = 1000 )) # fit lognormal distribution shape , loc , scale = stats . lognorm . fit ( data , loc = 0 ) pdf_lognorm = stats . lognorm . pdf ( data , shape , loc , scale ) In [9]: # visualize fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) ax1 . hist ( data , bins = 'auto' , density = True ) ax1 . plot ( data , pdf_lognorm ) ax1 . set_ylabel ( 'probability' ) ax1 . set_title ( 'Linear Scale' ) ax2 . hist ( data , bins = 'auto' , density = True ) ax2 . plot ( data , pdf_lognorm ) ax2 . set_xscale ( 'log' ) ax2 . set_title ( 'Log Scale' ); Similar transformations can be done on the sample data to convert non-normal to normal distribution. Lognormal transformation is used to convert rock permeability distributions to normal distribution, and square root transformation is used to analyze biological population growth, such as bacterial colonies per petri dish. These types of transformations - rescaling the distribution by taking exponents or log - are called Power Transformations. Box-Cox transformation is the most popular technique within the family of power transformations. Box-Cox Transformation: Theory Box-Cox Transformation is a type of power transformation to convert non-normal data to normal data by raising the distribution to a power of lambda ($\\lambda$). The algorithm can automatically decide the lambda ($\\lambda$) parameter that best transforms the distribution into normal distribution. Box-Cox transformation is a statistical technique known to have remedial effects on highly skewed data. Essentially it's just raising the distribution to a power of lambda ($\\lambda$) to transform non-normal distribution into normal distribution. The lambda ($\\lambda$) parameter for Box-Cox has a range of -5 < $\\lambda$ < 5 . If the lambda ($\\lambda$) parameter is determined to be 2, then the distribution will be raised to a power of 2 — $Y&#94;2$. The exception to this rule is when the lambda ($\\lambda$) parameter is 0 - log will be taken to the distribution — log($Y$). The below table shows how Box-Cox transformation raises the power of a distribution to different lambda ($\\lambda$) values: Lambda ($\\lambda$) Transformed Distribution ($Y&#94;{'}$) -2 $Y&#94;{'} = \\frac{1}{Y&#94;2}$ -1 $Y&#94;{'} = \\frac{1}{Y&#94;1}$ -0.5 $Y&#94;{'} = \\frac{1}{sqrt(Y)}$ 0 $Y&#94;{'} = log(Y)$ 0.5 $Y&#94;{1} = sqrt(Y)$ 1 $Y&#94;{'} = Y$ 2 $Y&#94;{'} = Y&#94;2$ Although in the table lambda ($\\lambda$) values of only -2 < $\\lambda$ < 2 were displayed, the actual algorithm has a range of -5 < $\\lambda$ < 5 . Also note that using a lambda ($\\lambda$) value of 1 does not do anything to the distribution. If the Box-Cox algorithm spits out $\\lambda = 1$, it probably means that your data is Gaussian-like or Gaussian enough to an extent that there is no need for transformation. All data to be positive and greater than 0 (Y > 0) Box-Cox transformation does not work if data is smaller than 0. This can easily be fixed by adding a constant ($C$) that will make all your data greater than zero. The transformation equation is then: $Y&#94;{'} = (Y + C)&#94;{\\lambda}$ Python Code Implementation The code implementation for Box-Cox transformation is very simple with the help of scipy.stats.boxcox() . from scipy import stats xt, lmbda = stats.boxcox(x) xt is the transformed data, and lmbda is the lambda ($\\lambda$) parameter. More detailed usage & analysis of Box-Cox will be covered in the next section. Box-Cox Transformation: Phone Call Duration - Gamma Distribution The distribution for phone call duration follows Erlang distribution, a member of a family of Gamma distribution. When the shape parameter of Gamma distribution has an integer value, the distribution is the Erlang disribution. Since power transformation is known to work well with Gamma distribution, we can try Box-Cox transformation to turn non-normal data into normal data. The below code snippet demonstrates how a typical Gamma distribution looks like when plotted: In [10]: from scipy import stats import matplotlib.pyplot as plt import numpy as np % matplotlib notebook In [11]: # random variable generation for gamma distribution def generate_gamma_dist ( shape ): dist_gamma = sorted ( stats . gamma . rvs ( shape , loc = 0 , scale = 1000 , size = 5000 )) shape , loc , scale = stats . gamma . fit ( dist_gamma , loc = 0 ) pdf_gamma = stats . gamma . pdf ( dist_gamma , shape , loc , scale ) return dist_gamma , pdf_gamma In [12]: # visualize fig , ax = plt . subplots ( figsize = ( 8 , 4 )) for i in range ( 1 , 5 ): x , y = generate_gamma_dist ( i ) ax . plot ( x , y , label = 'shape parameter = %s ' % i ) ax . set_xlabel ( 'X values' ) ax . set_ylabel ( 'probability' ) ax . set_ylim ( 0 , 0.0004 ) ax . set_xlim ( 0 , 10000 ) ax . set_title ( 'Gamma (Erlang) Distribution' ) ax . legend (); 1. Data Preparation We will use phone calls data from Enigma Public . Enigma Public is a website that processes & hosts various public data and allows people to obtain them through file downloads or API access. The sample data originally comes from the National Response Center (NRC). They receive phone calls from anyone witnessing an oil spill, chemical release or maritime security incident and record that data. For your convenience, I already downloaded the sample data and hosted it on this website. You can access the sample data directly by importing the file through requests . In [2]: import requests import io import pandas as pd In [3]: base_url = 'https://aegis4048.github.io/downloads/notebooks/sample_data/' filename = '08c32c03-9d88-42a9-b8a1-f493a644b919_NRCEventReporting-Calls-2010.csv' data = requests . get ( base_url + filename ) . content df = pd . read_csv ( io . StringIO ( data . decode ( 'utf-8' ))) df . head () Out[3]: seqnos date_time_received date_time_complete calltype responsible_company responsible_org_type responsible_city responsible_state responsible_zip source serialid 0 946479 2010-07-03T21:11:31+00:00 2010-07-03T21:19:57+00:00 INC NaN UNKNOWN NaN XX NaN TELEPHONE 15900 1 946480 2010-07-03T20:59:29+00:00 2010-07-03T21:16:22+00:00 INC CHEVRON PRIVATE ENTERPRISE NaN HI NaN WEB REPORT 15901 2 946481 2010-07-03T21:42:43+00:00 2010-07-03T21:53:07+00:00 INC BP PRIVATE ENTERPRISE NaN LA NaN TELEPHONE 15902 3 946482 2010-07-03T22:22:41+00:00 2010-07-03T22:34:07+00:00 INC CHEVRON PRIVATE ENTERPRISE SAN LUIS OBISPO CA 93401 TELEPHONE 15903 4 946483 2010-07-03T22:46:13+00:00 2010-07-03T22:50:24+00:00 INC NaN UNKNOWN NaN XX NaN TELEPHONE 15904 1.1. Sample Data Processing Since we are interested in the time ellapsed for each phone call, the primary columns of our interest are date_time_received and date_time_complete . However, the raw data is not in a numerical format that can be directly plotted on histogram; we will need to parse & process the time data. I chose .iloc[11000: 12000, :] because it would take too long time to process all ~30,000 rows of the original data. The data is then sorted by the timestamp column. Process DateTime In [4]: import datetime In [5]: def process_time ( row ): call_received = datetime . datetime . strptime ( row [ 'date_time_received' ] . split ( '+' )[ 0 ], '%Y-%m- %d T%H:%M:%S' ) call_ended = datetime . datetime . strptime ( row [ 'date_time_complete' ] . split ( '+' )[ 0 ], '%Y-%m- %d T%H:%M:%S' ) time_ellapsed = call_ended - call_received row [ 'Parsed Call Received' ] = str ( call_received ) row [ 'Parsed Call Ended' ] = str ( call_ended ) row [ 'Time Ellapsed' ] = str ( time_ellapsed ) row [ 'Time Ellapsed (minutes)' ] = round ( time_ellapsed . total_seconds () / 60 , 1 ) return row In [6]: # df was defined above parsed_df = df . iloc [ 11000 : 12000 , :] . apply ( process_time , axis = 1 ) . iloc [:, - 4 :] parsed_df [ 'Parsed Call Received' ] = pd . to_datetime ( parsed_df [ 'Parsed Call Received' ], format = '%Y-%m- %d %H:%M:%S' ) parsed_df [ 'Parsed Call Ended' ] = pd . to_datetime ( parsed_df [ 'Parsed Call Ended' ], format = '%Y-%m- %d %H:%M:%S' ) parsed_df = parsed_df . sort_values ( by = 'Parsed Call Received' ) parsed_df . head () Out[6]: Parsed Call Received Parsed Call Ended Time Ellapsed Time Ellapsed (minutes) 11000 2010-05-21 19:32:09 2010-05-21 19:43:35 0:11:26 11.4 11001 2010-05-21 19:54:40 2010-05-21 19:58:40 0:04:00 4.0 11002 2010-05-21 20:03:14 2010-05-21 20:09:11 0:05:57 6.0 11003 2010-05-21 20:04:26 2010-05-21 20:07:39 0:03:13 3.2 11004 2010-05-21 20:18:38 2010-05-21 20:27:45 0:09:07 9.1 Drop Duplicate Rows The original data does not record the time to a precision of microseconds ( 2010-07-03T21:11:31+00:00 ). Due to the imprecision of the recorded data, there will be rows with duplicate date_time_received and date_time_complete . The data itself is not duplicate, but the data in datetime column is duplicate. Leaving them as they are and plotting them might mess up your plots. Observe the change in the row number of the data frame. It's the indication that there are rows with the same date_time_received values. In [7]: parsed_df . shape Out[7]: (1000, 4) In [8]: new_parsed_df = parsed_df . drop_duplicates ( subset = [ 'Parsed Call Received' ], keep = False ) new_parsed_df . shape Out[8]: (998, 4) 2. Transformatoin It can be observed that the phone call duration data does not follow normal distribution. In [9]: time_duration_orig = new_parsed_df [ 'Time Ellapsed (minutes)' ] . values In [40]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( time_duration_orig , bins = 'auto' , density = True ) ax . set_xlabel ( 'Call Duration (minutes)' ) ax . set_ylabel ( 'probability' ) ax . set_title ( 'Non-normal Distribution of Phone Call Duration' ); 2.1. Box-Cox Transformation The Python code implementation for Box-Cox is actually very simple. The below one-line code is it for transformation. More information about the Box-Cox function can be found in the scipy documentaion . In [10]: time_duration_trans , lmbda = stats . boxcox ( time_duration_orig ) How does Box-Cox determine the best transformation parameter to obtain a distribution that is close to normal? It calculates correlation coefficient for different lambda ($\\lambda$) values, and finds the one that maximizes the correlation coefficient. In our case, we find that the best lambda parameter is $\\lambda = -0.322$ In [13]: print ( 'Best lambda parameter = %s ' % round ( lmbda , 3 )) fig , ax = plt . subplots ( figsize = ( 8 , 4 )) prob = stats . boxcox_normplot ( time_duration_orig , - 20 , 20 , plot = ax ) ax . axvline ( lmbda , color = 'r' ); Best lambda parameter = -0.322 2.2. Visual Inspection by Fitting Gaussian Distribution One can visually inspect how good the transformation was by fitting a Gaussian distribution function. In [14]: # fit Gaussian distribution time_duration_trans . sort () mean , std = stats . norm . fit ( time_duration_trans , loc = 0 ) pdf_norm = stats . norm . pdf ( time_duration_trans , mean , std ) In [44]: # visual inspection fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . hist ( time_duration_trans , bins = 'auto' , density = True ) ax . plot ( time_duration_trans , pdf_norm , label = 'Fitted normal distribution' ) ax . set_xlabel ( 'Call Duration (minutes)' ) ax . set_ylabel ( 'Transformed Probability' ) ax . set_title ( 'Box-Cox Transformed Distribution of Phone Call Duration' ) ax . legend (); Based on the transformed historgram and the respective fitted normal distribuion, it seems that our Box-Cox transformation with $\\lambda = -0.322$ worked well. 2.3. Visual Inspection with Q-Q Plots Visual inspection can be done in a different way with Q-Q plots. The red straight line is the fitted theoretical Gaussian distribution function. If the scatter plot is closer to the red straight line, it means that the data is very close to Gaussian distribution. Deviation from the red line indicates that the data is most likely not Gaussian. Recall that time_duration_orig is the original sample data, and time_duration_trans is the Box-Cox transformed data. In [26]: fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) prob = stats . probplot ( time_duration_orig , dist = stats . norm , plot = ax1 ) prob = stats . probplot ( time_duration_trans , dist = stats . norm , plot = ax2 ) ax1 . set_title ( 'Original Data' ) ax1 . set_ylabel ( 'Call Duration (minutes)' ) ax2 . set_title ( 'Transforamed Data, λ = %s ' % - 0.322 ); ax2 . set_ylabel ( '' ); No significant deviation is observed in Q-Q plots for the transformed data. The transformed data seems to follow Gaussian distribution well. 2.4. Normality Test with Hypothesis Testing Sometimes one might prefer not to evaluate the normality of the transformed data with visual inspection. It is possible to run formal hypothesis testing and check normality in terms of statistical values with scipy.stats.normaltest . It is based on D'Agostino and Pearson's test that combines skew and kurtosis to produce an omnibus test of normality. scipy.stats.normaltest() returns a 2-tuple of the chi-squared statistic, and the associated p-value. Given the null hypothesis that x came from a normal distribution, if the p-value is very small, we reject the null hypothesis. It means that it is unlikely that the data came from a normal distribution. In [15]: k2 , p = stats . normaltest ( time_duration_trans ) print ( ' \\n Chi-squared statistic = %.3f , p = %.3f ' % ( k2 , p )) alpha = 0.05 if p > alpha : print ( ' \\n The transformed data is Gaussian (fails to reject the null hypothesis)' ) else : print ( ' \\n The transformed data does not look Gaussian (reject the null hypothesis)' ) Chi-squared statistic = 2.453, p = 0.293 The transformed data is Gaussian (fails to reject the null hypothesis) The traditional alpha value of 5% was assumed ($\\alpha = 0.05$). Based on the result of the hypothesis testing, it seems that the transformed data does not significantly deviate from a theoretical Gaussian distribution. 3. Back Transformation - Control Chart Analysis One might wonder why we ever want to transform data into something different. What's the point of running analysis on transformed data that significantly deviates from the original data? Let's say that you have a sample data for human's life expectancy, which ranges between 0 and 100. Let's say that the distribution is not Gaussian, so you raised it to a power of 2 to convert it to Gaussian, making the transformed range to be between 0 to 10000. You calculate the mean of the transformed data and find out that the mean is 4,900 years. It is unreasonble to think that average life span of humans is 4,900 years. $$ \\text{Transformed average life span} = 4,900 \\,\\, \\text{years} $$ One must note that the whole point of data transformation is not to transform the data itself, but to use techniques that require a certain form of a distribution and acquire correct statistical values of your interest. This is where Back Transformation comes into play. You raised your sample data to a power of 2, and obtained the mean value of 4,900 years. Since you raised it to a power of 2, you will back transform it by lowering its power by 2. $$ \\text{original average life span} = \\sqrt{\\text{transformed average life span}} = \\sqrt{4,900 \\,\\, \\text{years}} = 70 \\,\\, \\text{years} $$ The concept of back transformation will be illustrated with control chart analysis. 3.1. Control Chart Basics If you don't have a good understanding of what control chart is, I recommend you to read this article . It is well written with clean, illustrative visualizations. The upper and lower control limits (UCL and LCL) in control charts are defined as values that are three standard deviations from a mean ($\\mu \\space \\pm \\space 3 \\sigma$). The control limits can be plotted on control chart with the following code snippet (note that new_parsed_df and time_duration_orig were defined above): In [29]: y = new_parsed_df [ 'Parsed Call Received' ] . values In [30]: mean = np . mean ( time_duration_orig ) std = np . std ( time_duration_orig ) upper_limit = mean + 3 * std lower_limit = mean - 3 * std In [31]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_orig ) ax . axhline ( mean , color = 'C1' ) ax . axhline ( upper_limit , color = 'r' ) ax . axhline ( lower_limit , color = 'r' ); ax . text ( y [ - 200 ], upper_limit + 3 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], lower_limit + 3 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean + 3 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Original' ); A few interesting observations could be drawn from the control chart visualization. Intervals dense number of phone calls are from daytime, and intervals with sparse number of phone calls are made from night time. The peaks seem to happen quite regularly. This makes sense considering how some phone calls take much longer than the others due to special circumstances No phone call duration is smaller than 0, and yet the lower control limit is -10, because the traditional control limit computation assumes normality of data, when phone call duration is not normally distributed. 3.2. Why Is Transformation Necessary? The upper control limit plotted on the above visualization defines any phone calls that take longer than 26 minutes to be an outlier. But, are they really outliers? Some phone calls might take longer than 26 minutes due to some extreme circumstances. Moreover, those \"outliers\" seem to be happening too often to be considred outliers. This is happening because the calculation of control limits through plus/minus three standard deviation ($\\pm \\space 3 \\sigma$) assumes that the data is normally distributed. The standard deviation method fails because the assumption of normality is not valid for the phone call duration distribution. Box-Cox transformation is necessary. In [32]: time_duration_trans , lmbda = stats . boxcox ( time_duration_orig ) In [33]: mean_trans = np . mean ( time_duration_trans ) std_trans = np . std ( time_duration_trans ) upper_limit_trans = mean_trans + 3 * std_trans lower_limit_trans = mean_trans - 3 * std_trans In [34]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_trans ) ax . axhline ( mean_trans , color = 'C1' ) ax . axhline ( upper_limit_trans , color = 'r' ) ax . axhline ( lower_limit_trans , color = 'r' ); ax . text ( y [ - 200 ], upper_limit_trans - 0.15 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], lower_limit_trans + 0.15 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean_trans + 0.1 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Transformed' ); A quick glance at the control chart of the transformed data tells us that the most of the phone calls were actually within the upper and lower control limit boundaries. $\\pm \\space 3 \\sigma$ standard deviation method is now working because the assumption of normality is satisfied. 3.3. Back Transforming Control Limits It is difficult for non-statisticians to understand that we are drawing conclusions from the transformed data. We need to back transform the calculated upper and lower control limits by taking the inverse of the lambda ($\\lambda$) parameter we applied for Box-Cox transformation. scipy.special.inv_boxcox will do the job. In [35]: from scipy.special import inv_boxcox In [36]: back_trans_upper_limits = inv_boxcox ( upper_limit_trans , lmbda ) back_trans_lower_limits = inv_boxcox ( lower_limit_trans , lmbda ) mean = np . mean ( time_duration_orig ) In [37]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . plot ( y , time_duration_orig ) ax . axhline ( mean , color = 'C1' ) ax . axhline ( back_trans_upper_limits , color = 'r' ) ax . axhline ( back_trans_lower_limits , color = 'r' ); ax . text ( y [ - 200 ], back_trans_upper_limits + 3 , 'Upper Control Limit' , color = 'r' ) ax . text ( y [ - 200 ], back_trans_lower_limits + 3 , 'Lower Control Limit' , color = 'r' ) ax . text ( y [ 3 ], mean + 3 , 'Mean' , color = 'C1' ) ax . set_ylabel ( 'Call duration (minutes)' ); ax . set_title ( 'Control Chart for Phone Call Duration - Back Transformed' ); After back-transforming the Box-Cox transformed data, we can now draw a conclusion that all of the phone calls, except for one, made to the National Response Center between 2010-05-22 to 2010-06-01 were within the control limits.","tags":"Statistics","url":"https://aegis4048.github.io/transforming-non-normal-distribution-to-normal-distribution","loc":"https://aegis4048.github.io/transforming-non-normal-distribution-to-normal-distribution"},{"title":"Spatial Simulation 1: Basics of Variograms","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Variogram , and Variogram Excel numerical demo on his Github repo to help yourself better understand the statistical theories and concepts. Let's say that you are a spatial data analyst of a gold mining company, and want to know the distribution of gold percentage over 100m x 100m mining area. To understand the characteritics of the rock formations, you take 100 random rock samples from the mining area, but obviously these 100 data points are not enough to estimate gold percentage over every single spatial locations in the area. So you analyze the available data (100 rock samples from random locations) and simulate full 2D-surface plot for gold percentage over the mining area. This 2D surface simulation from sparse spatial data is a sequential process that involved a series of geostatistical techniques. Steps: Plot experimental variogram Fit variogram model Apply kriging Apply simulation on top of Kriging Run simulation multiple times and perform additioanl data analyses as needed In this post, the concepts, theory, and methodology of plotting a variogram will be covered. Experimental Variogram: Theory Variogram is a measure of dissimilarity over a distance. It shows how two data points are correlated from a spatial perspective, and provides useful insights when trying to estimate the value of an unknown location using collected sample data from other locations. Tobler's first law of geography states that \"everything is related to everything else, but near things are more related than distant things.\" Variogram shows the correlation between two spatial data points over distances. For example, terrains 1 km apart from each other are more likely to be similar than terrains 100 km apart from each other. Oil wells 500 ft apart from each other are more likely to show similar reservoir characteristics than oil wells 5000 ft apart from each other. Variogram is a function of variance over distance. It has the following equation and plot: $$\\gamma(h) = \\frac{1}{2N(h)}\\sum_{\\alpha =1}&#94;{N(h)}\\left ( z(u_{\\alpha })-z(u_{\\alpha} + h) \\right)&#94;2$$ Variables Explained $\\gamma(h)$ = a measure of dissimilarity vs distance. It is a spatial variance between two data points separated by the distance, $h$. $N(h)$ = number of all data point pairs separated by the distance, $h$. $h$ = lag distance. Separation between two data points. $u_{\\alpha }$ = data point on 2D or 3D space at the location, $\\alpha$. $u_{a} + h$ = data point separated from $u_{\\alpha }$ by the distance, $h$. $z(u_{\\alpha })$ = numerical value of data point, $u_{\\alpha }$ $z(u_{\\alpha} + h)$ = numerical value of data point, $u_{\\alpha} + h$ $\\sigma&#94;2$ = sill. Variance at lag distance, $h$, in which spatial data pairs lose correlation. Observation 1: $z(u_{\\alpha })$ - $z(u_{\\alpha} + h)$ There are two data points on the image: $z(u_{\\alpha })$ and $z(u_{\\alpha } + h)$. These two points are separated by the lag distance, $h$. The equation for variogram observes the difference between these two data points: $$z(u_{\\alpha })-z(u_{\\alpha} + h)$$ Observation 2: $N(h)$ $N(h)$ accounts for all data point pairs that are separated by lag distance $h$. Although only horizontal separation is shown in the image, separation between two data points can be horizontal, vertical, or diagonal. Variogram will calculate the difference between all pairs of data points, $z(u_{\\alpha })-z(u_{\\alpha} + h)$, that are separated lag distance, $h$. $$\\sum_{\\alpha =1}&#94;{N(h)}\\left ( z(u_{\\alpha })-z(u_{\\alpha} + h) \\right)&#94;2$$ Observation 3: $\\gamma (h)$ $\\gamma (h)$ denotes for variability of spatial data points at a lag distance, $h$. Recall that variogram accounts for all pairs separated by distance, $h$. It may seem very simple, but one little dot on a variogram plot is actually obtained after iterating for all pairs separated by $h$. $\\underline{ h = 1m }$ $\\underline{ h = 2m }$ $\\underline{ h = 3m }$ Observe how there were less data pairs connected by red lines for $h = 3m$. As the $h$ increases, there will be fewer number of pairs that are separated by $h$ due to spatial limitation. Observation 4: Sill ($\\sigma&#94;2$) Sill ($\\sigma&#94;2$) is the variance in which spatial data pairs lose correlation. As the distance between two data points increases, it will be less likely that those two data points are related to one another. You may assume that the oil wells separated by 100 ft exibit similar geologic characteristics, but you can't assume the same for a well in Texas and a well in California. Variogram works the similar way. Notes Spatial variance may never reach the sill if there is a trend. Ex: Area trend between well variability Observation 5: Range ($a$) Range is a distance in which the spatial variability reaches the sill ($\\sigma&#94;2$). Let's say that you are an exploration engineer for drilling a new oil well. You have drilled wells A, B, C, D that are each 100ft, 200ft, 300ft, and 400ft apart from the zone you want to drill a next new well, and want to know if you can use the data from the previously drilled wells. The geostatisticians in your team report that the geologic formation in the region has a range of 350 ft. This means that the rocks in the region lose geologic correlation with one another if they are more than 350 ft apart — you can't use data from well D because it is 400 ft apart. Observation 6: Nugget Effect ($c_{0}$) The nugget effect refers to the nonzero intercept of the variogram and is an overall estimate of error caused by measurement inaccuracy and environmental variability occurring at fine enough scales to be unresolved by the sampling interval. At distance $h = 0$, we would expect the spatial variance between pairs will be zero, but some variables seem to change in an abrupt manner in very short distance. The nugget effect is like the random noise. It's just the small scale variability that you can't estimate with your large scale variability model. However, if there is no expectation of high degree of discontinuity at distances shorter than the minimum data spacing, experts tend to ignore nugget effect ub geologic engineering. Summary In variogram, low variance ($\\gamma$) represents stronger correlation among data pairs. Spatial data pairs lose correlation with one another when variance ($\\gamma$) at lag distance ($h$) reaches the sill ($\\sigma&#94;2$). If there are variance poitns that exceeds the sill, it indicates the presence of trend, and needs to be detrended before variogram modeling. More information about trend will be discussed later. Experimental Variogram: Search Template Parameters Calculating variogram is challenging because real-life data are not as clean as the 2-D grid sample images shown above. Real-life data are often sparse data that are irregularly spaced. The sparse data you will get in real-life will have very few, or even no data point pairs that are EXACTLY $h$ distance apart from each other. Furthermore, the data points will not always be orthogonal or pararell to each other — there will be diagonalities. regular Spacing irregular Spacing So how do we get pairs separated by lag distance, $h$? We need to consider distance, tolerance, azimuth direction, azimuth tolerance, dip direction, dip tolerance, bandwith in horizontal plane, and bandwidth in vertical plane — through a set of guidelines called Variogram Search Template . variogram Search Template Choice of Azimuth (Directionality) ellipsoidal growth in orthogonal directions, 3D Natural process does not lead to omnidirectionality. Typically there is a direction of major continuity, such as statigraphic surface, and a direction minimum continuity such as perpendicular layers. The choice of azimuth is carefully decided after combining knowledge of geologists and geologic understanding of the region from previously sampled data. There are three orthogonal directions — horizontal major, horizontal minor, and vertical. The \"vertical\" directional is assumed to be the direction orthogonal to the horizontal plane; the vertical direction doesn't have to correspond to the Z-axis. The three mutually orthogonal directions grow in ellipsoidal shape, with the horizontal major axis constituting the longer radius the ellipse. Azimuth decides the direction of horizontal major axis. In typical geometry, an angle ($\\theta$) is measured from the positive X-axis, but in variogram, azimuth is measured from the positive Y-axis. Notes According to an article written by Jared Deutsch , in the absence of strong geologic evidence, a neutral isotropic model can be constructed to assist in determining a principle direction (in later code implementation, isotropy is established by setting azi_tol=90 . You are allowing for $\\pm$90 degrees of azimuth tolerance). Using ordinary kriging, a neutral model would be constructed with an isotropic, long range, high nugget effect variogram. You will check if you can observe any directionality in this neutral model, and combine it with other geologic knowledge to assist in determinng the principle direction. Choice of Azimuth Tolerance Azimuth tolerance should be chosen such that maximum number of pairs are found in the search template and exclude unreasonable associations. A common choice of azimuth tolerance is 22.5°. However, it can be changed to make a decision about whether to increase precision, or stability. Reducing angle tolerance will give precise variogram ( figure 1 ), and increasing angle tolerance will give stable variogram ( figure 2 ). figure 1: smaller azimuth tol -> precise figure 2: bigger azimuth tol -> stable Choice of Lag Distance A variogram should span less than the maximum length of the field. For example, if the field A has a dimension of 100km x 100km, the maximum lag distance ($h$) of the calculated variogram should be less than 50 km. Calculating longer lags results in pairing samples from the edges of the field with each other. Due to spatial limitation of the field (recall that field A is only 100km long), there will be fewer pairs that are 80, 90, 100km apart than pairs that are 5, 10, 20km apart from each other. These variogram points will be much less informed than shorter distance pairs, with fewer pairs supporting the calculation. Observe how the figure 4 shows misleading information about the region. The figure tells us that the correlation becomes stronger for pairs separated by $h > 50$ as their distance increases. This is inconsistent with natural process — we expect the spatial correlation among pairs to decrease as they are further apart from each other. figure 3: sample Data figure 4: total lag = field length figure 5: total lag = field length / 2 Increasing the number of lag distance will result in fewer lag bins, which means that there will be fewer points on the calculated variogram ( figure 6 ). There will be a trade-off between stability and precision, and an engineer must carefully choose the parameters that is the best representative of the geology of the region. figure 6: stable, but imprecise figure 7: precise, but unstable Choice of Lag Tolerance Lag tolerance is usually half of the lag distance ( figure 8 ). Choosing lag tolerance smaller than 1/2 lag distance will result in missing out data pairs that are not within the lag tolerance ( figure 9 ). Choosing lag tolerance bigger than 1/2 lag distance will result in overlapping of data pairs ( figure 10 ). figure 8: lag tol. = 1/2 lag dist. figure 9: lag tol. < 1/2 lag dist. figure 10: lag tol. > 1/2 lag dist. Although the lag tolerance is usually half of the lag distance, in cases of erratic variograms, we may choose to overlap calculations by setting lag tolerance that is greater than half of the lag distance to increase stability in a variogram. Overlapping calculations has an effect of smoothing out and reducing noise in the calculated variogram ( figure 12 ). Smoothing out the calculated variogram maybe helpful in fitting a variogram model later. However, be careful not to smooth out too much, as it will result in imprecise variogram model that is not representative of the regional geology. A decision between stability and precision must be made. figure 11: noisy figure 12: smooth Choice of Bandwidth Just like azimuth tolerance, bandwidth should be chosen such that maximum number of pairs are found in the search template and exclude unreasonable associations. According to Jared Deutsch , bandwidths are infrequently used as they seldom improve the stability of the calculaed variogram. Instead, a carefully chosen set of angle tolerances (azimuth and dip) are applied. Experimental Variogram: Python Implementation In [ ]: In [ ]:","tags":"Geostatistics","url":"https://aegis4048.github.io/spatial-simulation-1-basics-of-variograms","loc":"https://aegis4048.github.io/spatial-simulation-1-basics-of-variograms"},{"title":"Parse PDF Files While Retaining Structure with Tabula-py","text":"If you've ever tried to do anything with data provided to you in PDFs, you know how painful it is — it's hard to copy-and-paste rows of data out of PDF files. It's especially hard if you want to retain the formats of the data in PDF file while extracting text. Most of the open source PDF parsers available are good at extracting text. But when it comes to retaining the the file's structure, eh, not really. Try tabula-py to extract data into a CSV or Excel spreadsheet using a simple, easy-to-use interface. One look is worth a thousand words. Take a look at the demo screenshot. Installations This installation tutorial assumes that you are using Windows. However, according to the offical tabula-py documentation , it was confirmed that tabula-py works on macOS and Ubuntu. 1. Download Java Tabula-py is a wrapper for tabula-java, which translates Python commands to Java commands. As the name \"tabula-java\" suggests, it requires Java. You can download Java here . 2. Set environment PATH variable (Windows) One thing that I don't like about Windows is that it's difficult to use a new program I downloaded in a console environment like Python or CMD window. But oh well, if you are a Windows user, you have to go through this extra step to allow Python to use Java. If you are a macOS or Ubuntu user, you probably don't need this step. Find where Java is installed, and go to Control Panel > System and Security > System > Advanced system settings > Advanced > Environment Variables... to set environment PATH variable for Java. Make sure you have Java\\jdk1.8.0_201\\bin and Java\\jre1.8.0_201\\bin in the environment path variable. Then, type java -version on CMD window. If you successfully installed Java and configured the environment variable, you should see something like this: java -version java version \"1.8.0_201\" Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) If you don't see something like this, it means that you didn't properly configure environment PATH variable for Java. 3. Re-start Your Command Prompt Any program invoked from the command prompt will be given the environment variables that was at the time the command prompt was invoked. If you launched your Python console or Jupyter Notebook before you updated your environment PATH variable, you need to re-start again. Otherwise the change in the environment variable will not be reflected. If you are experiencing FileNotFoundError or 'java' is not recognized as an internal or external command, operable program or batch file inside Jupyter or Python console, it's the issue of environment variable. Either you set it wrong, or your command prompt is not reflecting the change you made in the environment variable. To check if the change in the environment variable was reflected, run the following code in Jupyter or Python console: import os s = os.environ[\"PATH\"].split(';') for item in s: print(item) Something like these must be in the output if everything is working fine: C:\\Program Files\\Java\\jdk1.8.0_201\\bin C:\\Program Files\\Java\\jre1.8.0_201\\bin 4. Install Tabula-py This is the last step: pip install tabula-py Make sure that you install tabula-py , not tabula . Failing to do so will result in AttributeError: module 'tabula' has no attribute 'read_pdf' , as discussed in this thread . More detailed instructions are provided in the github repo of tabula-py Tabula Web Application Tabula supports web application to parse PDF files. You do not need this to use tabula-py, but from my personal experience I strongly recommend you to use this tool because it really helps you debugging issues when using tabula-py. For example, I was tring to parse 100s of PDF files at once, and for some reason tabula-py would return an NoneType object instead of pd.DataFrame object (by default, tabula-py extracts tables in dataframe) for one PDF file. There was nothing wrong with my codes, and yet it would just not parse the file. So I tried opening it on the tabula web-app, and realized that it was actually a scanned PDF file and that tabula is unable to parse scanned PDFs. Long story short, if it can be parsed with tabula web-app, you can replicate it with tabula-py. If tabula web-app can't, you should probably look for a different tool. Installations If you already configured the environment PATH variable for Java, all you need to do is downloading the .zip file here and running tabula.exe . That's it. Tabula has really nice web UI that allows you to parse tables from PDFs by just clicking buttons. Note The web-app will automatically open in your browser with 127.0.0.1:8080 local host. If port 8080 is already being used by another process, you will need to shut it down. But normally you don't have to worry about this. Screenshots This is what you will see when you launch tabula.exe . Browse... the PDF file you want to parse, and import . You can either use Autodetect Tables or drag your mouse to choose the area of your interest. If the PDF file has a complicated structure, it is usually better to manually choose the area of your interest. Also, note the option Repeat to All Pages . Selecting this option will apply the area you chose for all pages. Here's the output. More explanation about Lattice and Stream options will be discussed in detail later. Template JSON Files Tabula web-app accepts the user's drag & click as input and translates it into Java arguments that are actually used behind the scenes to parse PDF files. The translated Java arguments are accessible to users in a JSON format. Select the area you want to parse, and click Save Selections as Template . Then, Download the translated Java arguments in a text JSON file. These arguments are useful when coding arguments for tabula.read_pdf() later. template.json { \"page\": 2, \"extraction_method\": \"guess\", \"x1\": 24.785995330810547, \"x2\": 589.3559953308105, \"y1\": 390.5325, \"y2\": 695.0025, \"width\": 564.57, \"height\": 304.47 } Running Tabula-py Tabula-py enables you to extract tables from PDFs into DataFrame and JSON. It can also extract tables from PDFs and save files as CSV, TSV or JSON. Some basic code examples are as follows: import tabula # Read pdf into DataFrame df = tabula.read_pdf(\"test.pdf\", options) # Read remote pdf into DataFrame df2 = tabula.read_pdf(\"https://github.com/tabulapdf/tabula-java/raw/master/src/test/resources/technology/tabula/arabic.pdf\") # convert PDF into CSV tabula.convert_into(\"test.pdf\", \"output.csv\", output_format=\"csv\") # convert all PDFs in a directory tabula.convert_into_by_batch(\"input_directory\", output_format='csv') Area Selection You can select portions of PDFs you want to analyze by setting area (top,left,bottom,right) option in tabula.read_pdf() . This is equivalent to dragging your mouse and setting the area of your interest in tabula web-app as it was mentioned above. Default is the entire page. Also note that you can choose the page, or pages you want to parse with pages option. The sample PDF file can be downloaded from here . In [1]: import tabula import pandas as pd In [37]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df Out[37]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014\\r06:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 12/13/2014\\r09:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 12/13/2014\\r11:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 12/13/2014\\r14:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 12/13/2014\\r16:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 12/13/2014\\r17:30 12/13/2014\\r18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 12/13/2014\\r18:00 12/13/2014\\r18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 12/13/2014\\r18:30 12/13/2014\\r23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 12/13/2014\\r23:30 12/14/2014\\r01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 12/14/2014\\r01:30 12/14/2014\\r03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 12/14/2014\\r03:30 12/14/2014\\r04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 12/14/2014\\r04:30 12/14/2014\\r06:00 1.5 SURF-CMT CEMENT SURFACE\\rCASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Alternatively, you can set area with percentage scale by setting relative_area=True . For this specific PDF file, the below area=(50, 5, 92, 100), relative_area=True option is equivalent to area=(406, 24, 695, 589) above. In [38]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 50 , 5 , 92 , 100 ), relative_area = True ) df Out[38]: Start Date End Date Dur (hr) Activity Activity Detail Operation Com 0 2/13/2014\\r6:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 2/13/2014\\r9:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 2/13/2014\\r1:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 2/13/2014\\r4:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 2/13/2014\\r6:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 2/13/2014\\r7:30 12/13/2014\\r18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 2/13/2014\\r8:00 12/13/2014\\r18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 2/13/2014\\r8:30 12/13/2014\\r23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 2/13/2014\\r3:30 12/14/2014\\r01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 2/14/2014\\r1:30 12/14/2014\\r03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 2/14/2014\\r3:30 12/14/2014\\r04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 2/14/2014\\r4:30 12/14/2014\\r06:00 1.5 SURF-CMT CEMENT SURFACE\\rCASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Notes on Escape Characters When used as lattice mode, tabula replaces abnormally large spacing between texts and newline within a cell with \\r . This can be fixed with a simple regex manipulation. In [41]: clean_df = df . replace ( ' \\r ' , ' ' , regex = True ) clean_df Out[41]: Start Date End Date Dur (hr) Activity Activity Detail Operation Com 0 2/13/2014 6:00 12/13/2014 09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 2/13/2014 9:00 12/13/2014 11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 2/13/2014 1:00 12/13/2014 14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 2/13/2014 4:00 12/13/2014 16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 2/13/2014 6:00 12/13/2014 17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 5 2/13/2014 7:30 12/13/2014 18:00 0.5 PLAN DRLG CSG Make up 13 3/8 Gemco PDC drillable float shoe;... 6 2/13/2014 8:00 12/13/2014 18:30 0.5 PLAN PERS SFTY HJSM with Morning tour crew, Pipe Pro casing c... 7 2/13/2014 8:30 12/13/2014 23:30 5.0 PLAN DRLG CSG Make up 13 /8\" PDC drillable float collar onto... 8 2/13/2014 3:30 12/14/2014 01:30 2.0 SURF-CIRC CIRCULATE CIRC HJSM on Hoisting personal; Make up Swedge in ... 9 2/14/2014 1:30 12/14/2014 03:30 2.0 PLAN DRLG CSG Run 13 3/8\"J-55 54.5 BTC f/ 1,639' to 1,819';... 10 2/14/2014 3:30 12/14/2014 04:30 1.0 SURF-CIRC CIRCULATE CIRC Circulate Bttms up while Rigging down csg crew... 11 2/14/2014 4:30 12/14/2014 06:00 1.5 SURF-CMT CEMENT SURFACE CASING CMT HJSM w/ Basic Cementer, H&P rig crew & PNR; D... Lattice Mode vs Stream Mode Tabula supports two primary modes of table extraction — Lattice mode and Stream mode. Lattice Mode lattice=True forces PDFs to be extracted using lattice-mode extraction. It recognizes each cells based on ruling lines, or borders of each cell. Stream Mode stream=True forces PDFs to be extracted using stream-mode extraction. This mode is used when there are no ruling lines to differentiate one cell from the other. Instead, it uses spacings among each cells to recognize each cell. PDF File 1 : Lattice mode recommended PDF file 2 : Stream mode recommended How would it look like if PDF File 1 and PDF file 2 are each extracted in both stream mode and lattice mode? In [51]: # PDF File 1: lattice mode file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head () Out[51]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014\\r06:00 12/13/2014\\r09:00 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 12/13/2014\\r09:00 12/13/2014\\r11:00 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 2 12/13/2014\\r11:00 12/13/2014\\r14:00 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 3 12/13/2014\\r14:00 12/13/2014\\r16:00 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 4 12/13/2014\\r16:00 12/13/2014\\r17:30 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... In [57]: # PDF File 1: stream mode file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , stream = True , guess = False , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head ( 11 ) Out[57]: Start Date End Date (hr) Activity Activity Detail Operation Com 0 12/13/2014 12/13/2014 3.0 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 1 06:00 09:00 NaN NaN NaN NaN SPP 2300, motor diff 650, 800 GPM, torque 18k. 2 NaN NaN NaN NaN NaN NaN (T.D. Surface @ 09:00 12-13-14) 3 12/13/2014 12/13/2014 2.0 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 4 09:00 11:00 NaN NaN NaN NaN NaN 5 12/13/2014 12/13/2014 3.0 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 6 11:00 14:00 NaN NaN NaN NaN Hole taking correct fill 7 12/13/2014 12/13/2014 2.0 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... 8 14:00 16:00 NaN NaN NaN NaN ext. 9 12/13/2014 12/13/2014 1.5 PLAN DRLG CSG PTJSA / R/U Pipe Pros.Csg. tools / PTJSA on ru... 10 16:00 17:30 NaN NaN NaN NaN csg. In [62]: # PDF File 2: lattice mode file = 'pdf_parsing/stream-railroad-pages-1-4.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 1 , area = ( 209 , 12.5 , 387.3 , 386 )) df Out[62]: WELL INFORMATION In [64]: # PDF File 2: stream mode file = 'pdf_parsing/stream-railroad-pages-1-4.pdf' df = tabula . read_pdf ( file , stream = True , guess = False , pages = 1 , area = ( 209 , 12.5 , 387.3 , 386 )) df Out[64]: Unnamed: 0 WELL INFORMATION 0 API No.: 42-003-46352 County: A 1 Well No.:22H RRC Distri 2 Lease Name: UNIVERSITY \"7-43\" Field Name 3 RRC Lease No.: 40532 Field No.: 4 Location: Section: 35, Block: 7, Survey: UN... NaN 5 Latitude: Longitude: 6 This well is located 17.2 miles in a SE 7 direction from ANDREWS, NaN 8 which is the nearest town in the county. NaN Observe how lattice mode extraction for PDF file 2 was able to extract only \"WELL INFORMATION\" string. This is not an error. Recall that lattice mode identifies cells by ruling lines. Notes About guess option According to the offical documentation , guess is known to make a conflict between stream option. If you feel something strange with your result, try setting guess=False . For example, for PDF File 1 , if stream mode is used without setting guess=False , it would look like this: In [66]: # PDF File 1: stream mode, guess=True file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , stream = True , pages = 2 , area = ( 406 , 24 , 695 , 589 )) df . head ( 11 ) Out[66]: Report #:3 Daily Operation:12/13/2014 06:00 - 12/14/2014 06:00 Unnamed: 2 Unnamed: 3 Unnamed: 4 Unnamed: 5 Unnamed: 6 0 Job Category NaN Primary Job Type NaN NaN AFE Number NaN 1 ORIG DRILLING NaN ODR NaN NaN 033402 NaN 2 Days From Spud (days) Days on Location (days) End Depth (ftKB) End Depth (TVD) (ftKB) Dens Last Mud (lb/gal) Rig NaN NaN 3 1 3 1,859.0 1,858.5 8.60 H & P, 637 NaN NaN 4 Operations Summary NaN NaN NaN NaN NaN NaN 5 Drld. Surface f/1600' to 1859' T.D. @ 09:00... NaN NaN NaN NaN NaN NaN 6 S/M, R/U csg running equip & Run 45 jts. of... NaN NaN NaN NaN NaN NaN 7 Surface Float shoe @ 1,857.5' NaN NaN NaN NaN NaN Surface 8 Float collar @ 1,817.9' NaN NaN NaN NaN NaN NaN 9 Remarks NaN NaN NaN NaN NaN NaN 10 Rig (H&P 637), Well (University 7-43 # 22H) NaN NaN NaN NaN NaN NaN Pandas Option Pandas arguments can be passed into tabula.read_pdf() as a dictionary object. In [74]: file = 'pdf_parsing/lattice-timelog-multiple-pages.pdf' df = tabula . read_pdf ( file , lattice = True , pages = 2 , area = ( 406 , 24 , 695 , 589 ), pandas_options = { 'header' : None }) df . head () Out[74]: 0 1 2 3 4 5 6 0 Start Date End Date (hr) Activity Activity Detail Operation Com 1 12/13/2014\\r06:00 12/13/2014\\r09:00 3 SURF-DRILL DRILL SURFACE DRL Rotate from 1600' to 1859' (259' @ 8 fph). WOB... 2 12/13/2014\\r09:00 12/13/2014\\r11:00 2 SURF-CIRC CIRCULATE CIRC Pump 2- 50 bbl hi vis sweep; Circulate to surface 3 12/13/2014\\r11:00 12/13/2014\\r14:00 3 SURF-TRIP TOOH TRIP TOOH (Slick off bottom) f/1859' to 108' (SLM)... 4 12/13/2014\\r14:00 12/13/2014\\r16:00 2 PLAN EQUIP BHA PJSA - Break bit & L/D directional BHA, clean ... More Documentation Further instructions about tabula-py can be found on its official github repo .","tags":"Others","url":"https://aegis4048.github.io/parse-pdf-files-while-retaining-structure-with-tabula-py","loc":"https://aegis4048.github.io/parse-pdf-files-while-retaining-structure-with-tabula-py"},{"title":"Creating a Jupyter Notebook-Powered Data Science Blog with Pelican","text":"What powers this blog, Pythonic Excursions? - Pelican. - Me Pelican is a static site genertor, written in Python. It is a Python library used to auto-generate HTML elements that are used to run websites. Pelican-powered blogs are light and easy to host with no scaling concerns. It pre-generates HTML files and responds with the existing files during a typical HTTP request-response cycle. So, why should you use Pelican? It's GREAT for Blogging You can write your content directly with the editor of your choice in reStructuredText or Markdown formats. Select a favorite theme of your choice from a collection of Pelican-themes , and write articles. The CSS and Javascript contained in the theme will handle the rest and output your article nice and clean. One look is worth a thousand words. Take a look at this markdown file that is used to render this article through Github Pages by Jake VanderPlas . His blog is made with Pelican, after modifying some codes in Octopress theme (you can also write your articles in other formats, such as Jupyter Notebook, which powers this blog). Minimal Learning Curves Going through the official documenations, user-made tutorials, or YouTube videos can be painful. Using Pelican will minimize wasting your time dealing with the learning curves. One thing that makes it very easy to learn & modify is that there already are lots blogs that run on Pelican, and their source codes are open to public. Pythonic Excursions -- source code , Aegis-Jupyter Theme by Me onCrash = 'reboot();' -- source code , Elegant Theme by Talha Mansoor Pythonic Perambulations -- source code , Adapted Octopress Theme by Jake VanderPlas ... and many more If you don't want to learn Pelican from scratch, you can download these open source repos and start from there. You will only need to learn how to tweak some settings to meet your needs. Completely Static Output Is Easy To Host Anywhere The output of Pelican is all HTML. You don't have to worry about configuring a complicated database and optimizing connections. Let's take a look at how Pelican works. Most Pelican blogs have the following directory tree. blog content articles article_1.md article_2.md article_3.md figures images ... output category images figures index.html archives.html article_1.html article_2.html article_3.html plugins themes custom_theme static templates Makefile pelicanconf.py publishconf.py output directory is the folder where Pelican stores the auto-generated HTML files, and those existing files are returned to the user who sent an HTTP request to view your website. The other directories are tools and templates used to generate the HTML files in the output folder. You do not need to configure a SQL database, or execute any codes on the server. All outputs are completely static. Can Pelican Be Used In Dynamic Websites Too? Yes, it can. Although Pelican is a static site generator, that does not mean that you can't have dynamic backend features on your website. You can pre-generate the output HTML files with Pelican, and just wrap it around with the backend framework of your choice. Let's say that you are developing a web-app with Django, and you want part of your website to be a static blog. You have a Pelican-generated output HTML file called article_1.html . In Django, you can render your Pelican-generated HTML file using a basic Class-Based-View like this: views.py from django.views.generic import TemplateView class PelicanView(TemplateView): template_name = 'article_1.html' urls.py from django.urls import re_path from your_awesome_app import views app_name = 'your_awesome_app' urlpatterns = [ re_path('&#94;$', views.PelicanView.as_view(), name='pelican'), ] And that's all it takes to integrate Pelican with Django. Part of your website can be static pages where it doesn't need to execute any code on a server, but the other part of your website can be dynamic pages where you can send queries to your server. Of course, the methodology to combine Pelican with dynamic backend will differ for each backend framework of your choice, but you get the idea. Here is the point: Pelican is a static site generator, but that does not mean that Pelican can't be used in dynamic websites. And Pelican is GREAT for blogging. Introducing Aegis-Jupyter Theme Aegis-Jupyter theme is a custom Pelican theme I made to easily host & maintain a Jupyter Notebook powered data science blog. I borrowed some CSS design of the articles from Jake VanderPlas , and improved the rendering of Jupyter Notebook files by adding custom CSS & JS codes. Every articles you see in archives page is rendered using Jupyter Notebook .ipynb files, even this very article you are reading right now! There are several reason's you why you might wanna consider using Aegis-Jupyter theme. Jupyter-Notebook-Based Articles First and foremost, your articles are be rendered by Jupyter Notebook. The question of \"Why would you want to use Aegis-Jupyter theme?\" is synonymous to \"Why would you want to use Jupyter Notebook?\" - it allows you to create and share documents that contain live code, equations, visualizations and narrative text. You don't have to go through the hassel of writing Python input codes in HTML, save the output visualizations in jpg or png files, and then render it on a browser using an image tag like this: &ltimg src=\"your_awesome_visualization.png\"> No, don't do this. This is bad. You don't want to be keep doing this for every single output of your code block. This is too much work. Simply write codes in Jupyter, save it, and render your article. Aegis-Jupyter theme was built for that purpose. Mobile Device Friendly The theme renders very nicely on all resolutions, screenwidth, and mobile devices. Try viewing this website on your phone. If you are on PC, try stretching & collapsing the browser size and see how it responsively re-aligns itself. Google Analytics Support If you own any kind of website, not just a data science blog, at some point in your life you would be wondering about the behaviors of the viewers. How many people visit my website every week? How many of them are unique visitors? From what region do I get the most number of visitors? On average, how many minutes do people stay on my website? Which post was the most popular? From what social media platform do I get the most number of visitors from? These kinds of questions can be answered by leveraging the power of Google Analytics, FOR FREE . All you need to do is to create a Google Analytics account, get a tracking ID, and put that on publishconf.py file. For example, if your Google Analytics tracking ID is UA-1XXXXXXXX-1 , then you set GOOGLE_ANALYTICS variable liks this: publishconf.py GOOGLE_ANALYTICS = \"UA-1XXXXXXXX-1\" That's it. Aegis-Jupyter theme will take care of the rest. More detailed tutorials on how to create Google Analytics account and tracking ID will come later. Easy to Manage Your Articles Meta properties of your article can easily be managed my changing attributes in markdown files. The below markdown is the actual .md file that renders this article . non-parametric-confidence-interval-with-bootstrap.md Title: Non-Parametric Confidence Interval with Bootstrap Tags: non-parametric, confidence-interval, bootstrap(stats), statistics Date: 2019-01-04 09:00 Slug: non-parametric-confidence-interval-with-bootstrap Subtitle: Keywords: Featured_Image: images/featured_images/bootstrap.png Social_Media_Description: Bootstrapping can calculate uncertainty in any confidence interval of any kind of distribution. It's great because it is distribution-free. Summary: {% notebook downloads/notebooks/Non-ParametricConfidenceIntervalswithBootstrap.ipynb cells[1:2] %} {% notebook downloads/notebooks/Non-ParametricConfidenceIntervalswithBootstrap.ipynb cells[:] %} The below screenshot is the preview of the article on the landing page of this blog. Observe how each attribute in the markdown file is used to render the output preview page. You can declare additional attributes as much as you want. Share Your Posts on Social Media Aegis-Jupyter theme leverages the power of Open Graph Meta Tags and renders the preview of your website nicely when shared on social media. You can set a preview image by declaring Featured_Image and set preview descriptions by declaring Social_Media_Description for each article in its respective markdown files. If you do not specify Featured_Image attribute in the markdown file, a default featured image will show up when shared on social media. Default featured image can be set up in pelicanconf.py file. This is what I have for my blog: pelicanconf.py FEATURED_IMAGE = SITEURL + '/theme/img/logo_icon_background.png' Search Box Most static websites do not support search box functionality out of the box. However, Pelican supports Tipue Search , a jQuery site search plugin. Talha Mansoor made a pelican plugin that allows Pelican to leverage the power of Tipue Search, and Aegis-Jupyter integrated it to work with articles written in Jupyter Notebook. Take a look at it with your own eyes by scrolling up and actually using the search box in this blog! Disqus Comment Box Being able to communicate with the audiences is a quintessential component of a blog. Create an account in Disqus and get your Disqus Website Name here . Then, declare DISQUS_SITENAME variable in publishconf.py . That's all it takes to have a comment box feature for your blog. Aegis-Jupyter will handle the rest. And, of course, IT'S FREE publishconf.py DISQUS_SITENAME = \"pythonic-excursions\" In [ ]:","tags":"Others","url":"https://aegis4048.github.io/creating-a-jupyternotebook-powered-data-science-blog-with-pelican","loc":"https://aegis4048.github.io/creating-a-jupyternotebook-powered-data-science-blog-with-pelican"},{"title":"Non-Parametric Confidence Interval with Bootstrap","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Bootstrap , and Boostrap Excel numerical demo on his Github repo to help yourself better understand the statistical theories and concepts. Bootstrap is a non-parametric statistical technique to resample from known samples to estimate uncertainty in summary statistics. When there are small, limited number of samples, it gives a more accurate forecast model than directly obtaining a forecast model from the limited sample pool (assuming that the sample set of data is reasonable representation of the population). It is non-parametric because it does not require any prior knowledge of the distribution (shape, mean, standard devation, etc..). Advantages of Bootstrap One great thing about Bootstrapping is that it is distribution-free . You do not need to know distribution shape, mean, standard devation, skewness, kurtosis, etc... All you need is just a set of sample data that is representative of a population. The fact that Bootstrapping does not depend on a type of distribution leads to another great advantage - It can calculate uncertainty in any confidence interval of any kind of distribution . For example, the analytical solution to calculate a confidence interval in any statistics of a distribution is as follows: CI of mean = stats of interest $\\pm$ $($distribution score $\\times$ Standard Error $)$ There are three problems with analytically solving for confidence interval of a statistic. First, the variable in the equation, distribution score , depends on the type of the distribution. If you do not know the distribution shape of your population, it is very difficult to calculate the confidence interval of a statistic. Second, not all statistics have a formula to calculate its Standard Error . For example, there exists an equation to calculate the standard error of a mean: Standard Error = $\\sigma_{sample} \\ \\mathbin{/} \\ \\sqrt{N}$ But there is no equation to calculate the standard error of a median. If you want to obtain confidence intervals for other statistics (ex: skewness, kurtosis, IQR, etc...), it will be very difficult to do so, simply because there are no equations for them. Third, some statistics have analytical solutions for its standard error calculation, but it is so convoluted that Bootstrapping is simpler. A classic example is obtaining a CI for the correlation coefficient given a sample from a bivariate normal distribution. Bootstrapping calculates confidence intervals for summary statistics numerically, not analytically , and this is why it can calculate ANY summary stats for ANY distribution. Methodology One goal of inferential statistics is to determine the value of a parameter of an entire population. It is typically too expensive or even impossible to measure this directly. So we use statistical sampling. We sample a population, measure a statistic of this sample, and then use this statistic to say something about the corresponding parameter of the population. Bootstrapping is a type of resampling method to save time and money taking measurements. From a sample pool of size N, it picks a random value N times with replacement , and create M number of new Bootstrapped-sample pools. The term with replacement here means that you put back the sample you drew to the original sample pool after adding it to a new Bootstrapped-sample pool. Think of it this way: you randomly choose a file from a folder in your PC, and you copy and paste the randomly-chosen file into a new folder. You do not cut and paste the file, but you copy and paste the file into a new folder. You will have M number of folders (M is an arbitrary number of your choice), each containing N number of files. Bootstrapping resamples the original sample pool to generate multiple smaller population of the true population. Each Bootstrap simulation is done by selecting a random value from the sample pool. For example, lets assume that you have the following sample pool of integers: Sample Integers = [12, 433, 533, 14, 65, 42, 64] From the sample pool of size N=7, you choose a random value N=7 times, and create a new sample pool of size N=7. In Bootstrap, each newly created sample pool is called a realization . You generate many of these realizations, and use them to calculate uncertainties in summary stats. Realization 1 = [12, 533, 533, 533, 12, 14, 42] Realization 2 = [65, 14, 14, 65, 433, 64, 14] Realization 3 = [433, 64, 533, 14, 14, 64, 12] Realization 4 = [14, 65, 65, 433, 533, 42, 12] Notice the duplicate data in the realizations (Ex: 533, 533, 533). Duplicates in realizations exist because each data in realization is randomly chosen from the original sample pool with replacement . Warning! It is extremly important that the N size for each Bootstrap realization matches the N size of the original sample pool. We use Bootstrap to numerically estimate the confidence interval (CI). It's an alternative tool to analytically solve for CI. Observing how CI is analytically calculated may help one to understand why the value of N is important. Let's take the CI of a mean for example. Recall that the CI of a mean represents how far a sample mean can deviate from the true population mean. In case of a Gaussian, or Gaussian-like distribution (ex: student-t), the equation to analytically solve for confidence interval of a mean is as follows: CI of mean = sample mean $\\pm$ $($z-score $\\times$ Standard Error $)$ Standard Error = $\\sigma_{sample} \\ \\mathbin{/} \\ \\sqrt{N}$ where $N$ is the number of measured samples. If you increase the number of samples, the standard error of a mean decreases. This logically makes sense, because the more samples you have, the more accurate the estimation of the true population mean becomes. The size of each Bootstrap realization, N, works the similar way, except that the random sample in each realization is not from the true population, but from a measured sample pool. Increasing the N-value will falsely make you to calculate smaller confidence interval. It can be observed that the CI obtained by using a wrong N-value for Bootstrap generates narrower CI. As a result, the CI of the sample mean does not cover the true population mean, returning a misleading estimation. In summary, Bootstrapping is used for three reasons: Bootstrap can obtain confidence interval in any statistics. Bootstrap does not assume anything about a distribution. Bootstrap helps when there are too few number of samples. Imports In [2]: import pandas as pd import numpy as np import scipy.stats import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec % matplotlib notebook 1.A. Confidence Intervals in Summary Stats: US Male Height - Gaussian Distribution Bootstrap simulation can be run to obtain confidence intervals in various population parameters: mean, stdev, variance, min, or max. In this example, we will work with the height distribution of the US Male population, which tends to be Gaussian. However, the fact that the distribution Gaussian is totally unrelated to Bootstrap simulation, because it does not assume anything about the distribution. Bootstrapping can give us confidence intervals in any summary statistics like the following: By 95% chance, the following statistics will fall within the range of: Mean : 75.2 ~ 86.2, with 80.0 being the average Standard Deviation : 2.3 ~ 3.4 with 2.9 being the average Min : 54.3 ~ 57.2, with 55.2 being the average Max : 77.8 ~ 82.4, with 79.8 being the average Skew : -0.053 ~ 0.323, with 0.023 being the average 1.A.0. Bootstrap Scripts Bootstrap Simulator In [3]: def bootstrap_simulation ( sample_data , num_realizations ): n = sample_data . shape [ 0 ] boot = [] for i in range ( num_realizations ): real = np . random . choice ( sample_data . values . flatten (), size = n ) boot . append ( real ) columns = [ 'Real ' + str ( i + 1 ) for i in range ( num_realizations )] return pd . DataFrame ( boot , index = columns ) . T Summary Statistics Calculator In [4]: def calc_sum_stats ( boot_df ): sum_stats = boot_df . describe () . T [[ 'mean' , 'std' , 'min' , 'max' ]] sum_stats [ 'median' ] = boot_df . median () sum_stats [ 'skew' ] = boot_df . skew () sum_stats [ 'kurtosis' ] = boot_df . kurtosis () sum_stats [ 'IQR' ] = boot_df . quantile ( 0.75 ) - boot_df . quantile ( 0.25 ) return sum_stats . T Visualization Script In [5]: def visualize_distribution ( dataframe , ax_ ): dataframe = dataframe . apply ( lambda x : x . sort_values () . values ) for col , label in zip ( dataframe , dataframe . columns ): fit = scipy . stats . norm . pdf ( dataframe [ col ], np . mean ( dataframe [ col ]), np . std ( dataframe [ col ])) ax_ . plot ( dataframe [ col ], fit ) ax_ . set_ylabel ( 'Probability' ) Generate Confidence Intervals In [6]: def calc_bounds ( conf_level ): assert ( conf_level < 1 ), \"Confidence level must be smaller than 1\" margin = ( 1 - conf_level ) / 2 upper = conf_level + margin lower = margin return margin , upper , lower def calc_confidence_interval ( df_sum_stats , conf_level ): margin , upper , lower = calc_bounds ( conf_level ) conf_int_df = df_sum_stats . T . describe ( percentiles = [ lower , 0.5 , upper ]) . iloc [ 4 : 7 , :] . T conf_int_df . columns = [ 'P' + str ( round ( lower * 100 , 1 )), 'P50' , 'P' + str ( round ( upper * 100 , 1 ))] return conf_int_df def print_confidence_interval ( conf_df , conf_level ): print ( 'By {}% c hance, the following statistics will fall within the range of: \\n ' . format ( round ( conf_level * 100 , 1 ))) margin , upper , lower = calc_bounds ( conf_level ) upper_str = 'P' + str ( round ( upper * 100 , 1 )) lower_str = 'P' + str ( round ( lower * 100 , 1 )) for stat in conf_df . T . columns : lower_bound = round ( conf_df [ lower_str ] . T [ stat ], 1 ) upper_bound = round ( conf_df [ upper_str ] . T [ stat ], 1 ) mean = round ( conf_df [ 'P50' ] . T [ stat ], 1 ) print ( \" {0:<10} : {1:>10} ~ {2:>10} , AVG = {3:>5} \" . format ( stat , lower_bound , upper_bound , mean )) 1.A.1 Sample Data Description 100 samples of US male height data is provided in my Github Repo - sample_data/US_Male_Height.csv . Summary statistics of the sample data can be calculated. Your goal is to calculate the confidence intervals for the summary stats. In [7]: # height data height_data = pd . read_csv ( 'sample_data/US_Male_Height.csv' ) height_data . index = [ 'Male ' + str ( i + 1 ) for i in range ( height_data . shape [ 0 ])] height_data . round ( 1 ) . T Out[7]: Male 1 Male 2 Male 3 Male 4 Male 5 Male 6 Male 7 Male 8 Male 9 Male 10 ... Male 91 Male 92 Male 93 Male 94 Male 95 Male 96 Male 97 Male 98 Male 99 Male 100 Height (in) 70.8 72.8 72.5 67.3 72.7 73.6 65.0 67.1 70.8 70.6 ... 71.7 66.4 72.9 74.5 73.5 70.5 73.1 63.6 68.7 73.0 1 rows × 100 columns In [8]: height_summary_stats = calc_sum_stats ( height_data ) height_summary_stats Out[8]: Height (in) mean 69.881971 std 3.169548 min 63.143732 max 77.762886 median 69.894434 skew -0.059779 kurtosis -0.700743 IQR 5.154145 Visualization In [9]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Height (inches)' ); fig . suptitle ( 'Original Sample Data Distribution: Gaussian Distribution' ) visualize_distribution ( height_data , ax ); Based on the distribution plot of the original sample data, we can observe that the distribution indeed looks Gaussian. However, the fact that it looks like Gaussian does not matter at all when Bootstrapping, because Bootstrapping does not assume anything about the distribution. 1.A.2 Resampling From the Sample Data Each Bootstrap resampling (realization) can be done in one-line with numpy.random.choice() . Each realization is an array of size N, where N is the length of the original sample data. There are M number of realizations, where M is an arbitrary number of your choice. Results In [10]: M = 100 # number of realizations - arbitrary bootstrap_data = bootstrap_simulation ( height_data , M ) bootstrap_data . round ( 1 ) . head ( 10 ) Out[10]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 0 72.7 67.9 65.0 69.2 70.4 64.9 70.3 66.3 67.6 72.2 ... 74.1 66.3 73.0 68.5 65.3 72.5 72.7 69.2 66.4 72.3 1 68.4 70.5 65.3 64.5 71.8 69.2 70.5 71.6 65.3 67.9 ... 72.5 68.6 66.1 71.7 67.3 74.1 67.9 71.3 72.9 65.0 2 71.3 74.1 72.8 72.9 68.3 67.9 73.1 65.0 73.6 72.8 ... 69.5 72.5 72.5 73.3 69.2 74.1 73.0 65.5 67.9 63.1 3 72.5 73.0 71.4 68.5 73.3 70.5 70.5 70.6 68.5 69.0 ... 64.5 69.2 66.0 69.5 72.5 70.3 67.9 68.3 73.6 73.5 4 67.2 73.5 73.6 67.2 64.5 72.9 72.8 66.4 69.2 66.8 ... 66.3 73.6 71.3 73.1 71.6 72.2 64.9 69.0 71.7 70.2 5 69.1 66.0 65.5 69.1 71.7 70.6 66.0 73.0 72.2 69.9 ... 73.0 66.3 69.0 67.9 69.4 69.9 69.5 68.7 72.4 67.3 6 72.2 68.5 72.9 63.1 73.6 73.1 70.8 75.5 69.9 70.6 ... 68.4 65.0 68.5 68.8 67.2 72.2 65.5 70.6 72.2 66.8 7 73.1 72.5 69.0 72.5 71.6 68.7 73.5 66.2 71.6 74.4 ... 73.6 68.5 72.2 73.1 72.3 72.1 66.8 77.8 72.8 69.5 8 67.3 69.5 74.5 66.8 69.1 65.0 69.9 70.6 65.0 73.1 ... 67.1 72.8 70.5 70.8 73.6 72.5 71.8 67.9 67.2 70.6 9 66.3 72.9 65.5 72.5 72.4 70.6 73.1 69.5 67.2 68.7 ... 71.6 69.2 65.0 71.3 71.4 69.1 73.3 70.2 66.1 67.6 10 rows × 100 columns In [11]: boot_sum_stats = calc_sum_stats ( bootstrap_data ) boot_sum_stats . round ( 1 ) Out[11]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 mean 69.4 70.0 69.9 70.1 70.0 69.5 70.2 70.2 69.7 70.5 ... 69.7 69.9 69.7 69.9 70.1 70.0 70.0 69.5 70.1 69.4 std 3.1 3.1 3.2 3.3 3.3 3.1 3.1 3.2 2.9 3.0 ... 3.1 3.3 2.8 3.0 3.2 2.8 3.2 3.2 3.2 3.3 min 63.1 63.6 64.1 63.1 63.1 63.1 63.1 63.1 63.6 63.1 ... 63.1 63.1 63.1 63.6 63.6 64.5 64.1 63.1 63.1 63.1 max 75.5 77.8 76.1 77.8 76.1 76.1 76.1 77.8 77.8 77.8 ... 75.5 77.8 77.8 75.5 77.8 76.1 77.8 77.8 77.8 76.1 median 69.1 70.3 70.5 70.4 70.9 69.2 70.5 70.6 69.5 70.7 ... 69.9 69.5 69.5 69.9 69.9 69.9 70.4 69.2 70.6 69.1 skew -0.1 -0.0 -0.2 -0.0 -0.4 -0.0 -0.3 -0.3 0.2 -0.2 ... -0.4 -0.0 -0.0 -0.3 -0.1 0.1 0.2 -0.1 -0.2 -0.0 kurtosis -1.1 -0.8 -1.1 -0.4 -0.9 -0.7 -0.9 -0.6 -0.4 -0.5 ... -0.9 -0.7 -0.3 -0.9 -0.8 -0.9 -0.6 -0.7 -0.8 -1.0 IQR 5.4 5.2 5.9 4.2 5.2 4.9 5.5 5.0 4.9 4.2 ... 5.2 5.4 4.9 4.7 4.8 4.4 5.1 4.8 5.3 5.7 8 rows × 100 columns Visualize In [13]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Height (inches)' ); fig . suptitle ( 'Distribution of Bootstrap-Simulated Data: Gaussian' ) visualize_distribution ( bootstrap_data , ax ); Each line in the plot represents one Bootstrap realization. There are 100 realizations, each having 100 random samples. 1.A.3 Uncertainty Models in Summary Statistics with Blox Plots In [16]: f = plt . figure () plt . suptitle ( 'Uncertainty Models for Various Statistics: US Male Height - Gaussian' ) gs = gridspec . GridSpec ( 2 , 4 ) ax1 = plt . subplot ( gs [ 0 , 0 : 4 ]) ax2 = plt . subplot ( gs [ 1 , 0 ]) ax3 = plt . subplot ( gs [ 1 , 1 ]) ax4 = plt . subplot ( gs [ 1 , 2 ]) ax5 = plt . subplot ( gs [ 1 , 3 ]) boot_sum_stats . T [[ 'mean' , 'min' , 'max' , 'median' ]] . boxplot ( ax = ax1 ) boot_sum_stats . T [[ 'std' ]] . boxplot ( ax = ax2 ) boot_sum_stats . T [[ 'IQR' ]] . boxplot ( ax = ax3 ) boot_sum_stats . T [[ 'skew' ]] . boxplot ( ax = ax4 ) boot_sum_stats . T [[ 'kurtosis' ]] . boxplot ( ax = ax5 ) ax5 . set_ylim ([ - 3 , 3 ]); 1.A.4 Confidence Interval in Summary Statistics Confidence intervals of summary statistics usually have a confidence level of 90%, 95%, or 99%. In this case, we will choose 95% confidence level . In [17]: confidence_level = 0.95 conf_int = calc_confidence_interval ( boot_sum_stats , confidence_level ) conf_int . round ( 1 ) Out[17]: P2.5 P50 P97.5 mean 69.4 69.9 70.5 std 2.8 3.2 3.4 min 63.1 63.1 64.5 max 75.4 77.8 77.8 median 69.1 70.0 71.1 skew -0.5 -0.1 0.3 kurtosis -1.1 -0.7 -0.1 IQR 4.0 4.9 5.8 In [18]: print_confidence_interval ( conf_int , confidence_level ) By 95.0% chance, the following statistics will fall within the range of: mean : 69.4 ~ 70.5 , AVG = 69.9 std : 2.8 ~ 3.4 , AVG = 3.2 min : 63.1 ~ 64.5 , AVG = 63.1 max : 75.4 ~ 77.8 , AVG = 77.8 median : 69.1 ~ 71.1 , AVG = 70.0 skew : -0.5 ~ 0.3 , AVG = -0.1 kurtosis : -1.1 ~ -0.1 , AVG = -0.7 IQR : 4.0 ~ 5.8 , AVG = 4.9 1.B. Confidence Intervals in Summary Stats: Rock Permeability - Lognormal Distribution It was previously stated that Bootstrapping does not assume anything about the distribution. Is that really true? The previous example of the US Male Height distribution was a Gaussian distribution. But what if the distribution of our interest is not Gaussian? In this example, rock pearmeability, which has a lognormal distribution , will be used to show that Bootstrap does not depend on the type of the distribution. 1.B.0. Bootstrap Scripts The sample scripts used for US Male Height example will be used for Bootstrap simulation. Same scripts can be used for both Gaussian and lognormal distribution because Bootstrapping does not assume anything about the distribution. 1.B.1. Sample Data Description 105 samples of permeability data is provided in Github Repo - sample_data/PoroPermSampleData.xlsx . Permeability data is taken at many times at different depth of a wellbore. Summary statistics of the sample data can be calculated. Your goal is to calculate the confidence intervals for the summary stats. In [19]: # permeability data perm_depth_data = pd . read_excel ( 'sample_data/PoroPermSampleData.xlsx' , sheet_name = 'Sheet1' )[[ 'Depth' , 'Permeability (mD)' ]] perm_data = perm_depth_data [ 'Permeability (mD)' ] . to_frame () # visualize fig = plt . figure () ax = plt . axes () ax . plot ( perm_depth_data [ 'Permeability (mD)' ], perm_depth_data [ 'Depth' ]); ax . invert_yaxis () ax . set_title ( 'Permeability Along A Wellbore' ) ax . set_xlabel ( 'Permeability (mD)' ) ax . set_ylabel ( 'Depth (ft)' ); In [20]: perm_summary_stats = calc_sum_stats ( perm_data ) perm_summary_stats Out[20]: Permeability (mD) mean 161.008972 std 80.900128 min 43.534147 max 573.461883 median 144.329837 skew 1.625086 kurtosis 5.498080 IQR 102.580432 Visualization In [21]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) ax . set_xlabel ( 'Permeability (mD)' ) fig . suptitle ( 'Original Sample Data Distribution: Lognormal Distribution' ) visualize_distribution ( perm_data , ax ); Based on the distribution of the original sample data, we can observe that the distribution looks lognormal. The uncertainty in summary statistics can be calculated using Bootstrap the same way it was done for the US Male Height (Gaussian) distribution, because Bootstrap does not depend on the shape of the distribution. Warning! Outlier removal on rock permeability cannot be done directly, as this is a lognormal distribution. Recall that the typical outlier removal method assumes the distribution to be Gaussian. If you want to detect outliers for non-Gaussian distributions, you have to first transform the distribution into Gaussian. 1.B.2 Resampling From the Sample Data Each Bootstrap resampling (realization) can be done in one-line with numpy.random.choice() . Each realization is an array of size N, where N is the length of the original sample data. There are M number of realizations, where M is an arbitrary number of your choice. Results In [22]: M = 100 # number of realizations - arbitrary boot_perm_data = bootstrap_simulation ( perm_data , M ) boot_perm_data . round ( 1 ) . head ( 10 ) Out[22]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 0 61.9 258.6 138.8 61.9 285.3 156.1 179.7 125.9 58.8 89.6 ... 151.0 227.4 59.1 573.5 258.6 56.3 240.6 89.6 132.7 182.6 1 170.5 61.0 143.7 214.1 264.2 244.1 144.7 160.5 83.9 258.6 ... 58.8 279.8 244.1 92.1 213.7 160.5 240.6 146.0 141.8 138.8 2 143.7 86.8 117.6 92.7 83.9 104.0 187.9 138.8 162.3 132.1 ... 258.4 380.1 89.6 89.6 123.3 77.5 102.7 193.1 133.2 234.5 3 166.9 151.0 240.6 265.5 183.1 65.6 59.1 305.1 103.5 131.6 ... 214.9 128.9 210.8 108.6 193.1 125.9 77.5 151.5 112.3 58.8 4 161.0 146.0 89.6 84.9 129.1 43.5 170.5 97.7 190.9 197.8 ... 56.3 85.0 53.4 79.4 58.8 92.7 102.7 190.9 126.3 161.0 5 104.0 132.1 129.1 144.4 184.8 263.5 151.0 170.5 162.9 311.6 ... 61.0 156.1 170.5 264.2 244.1 85.0 112.3 117.6 224.4 265.5 6 305.1 77.5 213.7 84.9 240.6 58.8 224.4 234.5 128.9 193.1 ... 66.9 138.8 240.6 66.9 166.9 84.7 305.1 80.4 53.4 264.2 7 286.8 171.4 92.1 84.9 116.9 245.7 141.8 135.8 206.6 116.9 ... 162.3 244.1 187.9 151.0 84.9 85.0 573.5 170.5 83.3 117.6 8 142.7 187.9 131.6 117.6 244.1 214.1 182.6 134.7 132.7 132.7 ... 123.3 104.0 65.6 86.8 84.9 193.1 56.3 136.9 156.1 311.6 9 58.8 132.1 380.1 136.9 65.6 244.1 134.7 77.8 321.1 79.4 ... 128.9 83.9 182.6 132.0 117.6 234.5 227.4 187.9 80.4 138.8 10 rows × 100 columns In [23]: boot_perm_sum_stats = calc_sum_stats ( boot_perm_data ) boot_perm_sum_stats . round ( 1 ) Out[23]: Real 1 Real 2 Real 3 Real 4 Real 5 Real 6 Real 7 Real 8 Real 9 Real 10 ... Real 91 Real 92 Real 93 Real 94 Real 95 Real 96 Real 97 Real 98 Real 99 Real 100 mean 159.5 152.6 146.9 155.7 160.3 161.7 161.5 164.4 146.6 162.7 ... 143.9 150.0 166.7 155.6 155.2 151.5 164.7 171.3 143.8 148.1 std 80.0 64.1 72.6 77.2 72.1 98.0 88.0 90.7 65.3 73.3 ... 78.4 68.0 64.7 78.0 68.8 74.8 106.0 96.3 63.1 62.0 min 56.3 43.5 43.5 43.5 53.4 43.5 43.5 43.5 43.5 43.5 ... 43.5 43.5 53.4 43.5 43.5 53.4 53.4 43.5 43.5 43.5 max 573.5 305.1 380.1 573.5 380.1 573.5 573.5 573.5 321.1 321.1 ... 573.5 380.1 380.1 573.5 380.1 321.1 573.5 573.5 380.1 380.1 median 143.7 138.8 132.1 144.4 138.8 143.7 142.7 138.8 136.9 145.6 ... 132.0 133.2 151.0 141.8 138.8 133.2 133.2 144.7 132.7 138.8 skew 1.8 0.6 1.1 1.7 0.7 1.6 2.2 2.0 0.6 0.4 ... 2.1 0.8 0.6 1.8 0.7 0.6 1.9 2.2 0.9 0.8 kurtosis 6.1 -0.5 1.0 6.9 -0.3 4.3 7.7 6.4 -0.2 -0.9 ... 8.1 0.5 0.3 6.7 0.2 -0.7 4.6 7.0 1.0 1.1 IQR 79.3 80.8 92.7 113.0 102.4 129.2 102.4 86.7 95.2 114.0 ... 77.3 98.2 78.7 102.6 86.7 112.7 132.3 79.2 82.1 80.8 8 rows × 100 columns Visualize In [29]: fig , ax = plt . subplots ( figsize = ( 8 , 4 )) fig . suptitle ( 'Distribution of Bootstrap-Simulated Data: Lognormal' ) ax . set_xlabel ( 'Permeability (mD)' ) visualize_distribution ( boot_perm_data , ax ); 1.B.3 Uncertainty Models in Summary Statistics with Blox Plots In [25]: f = plt . figure () plt . suptitle ( 'Uncertainty Models for Various Statistics: Rock Permeability - Lognormal' ) gs = gridspec . GridSpec ( 2 , 4 ) ax1 = plt . subplot ( gs [ 0 , 0 : 4 ]) ax2 = plt . subplot ( gs [ 1 , 0 ]) ax3 = plt . subplot ( gs [ 1 , 1 ]) ax4 = plt . subplot ( gs [ 1 , 2 ]) ax5 = plt . subplot ( gs [ 1 , 3 ]) boot_perm_sum_stats . T [[ 'mean' , 'min' , 'max' , 'median' ]] . boxplot ( ax = ax1 ) boot_perm_sum_stats . T [[ 'std' ]] . boxplot ( ax = ax2 ) boot_perm_sum_stats . T [[ 'IQR' ]] . boxplot ( ax = ax3 ) boot_perm_sum_stats . T [[ 'skew' ]] . boxplot ( ax = ax4 ) boot_perm_sum_stats . T [[ 'kurtosis' ]] . boxplot ( ax = ax5 ) ax4 . set_ylim ([ - 3 , 3 ]) ax5 . set_ylim ([ - 10 , 10 ]); Observe the positive skewness in the boxplot summary statistics. This is consistent with the left-justified lognormal distribution of the permeability plot. 1.B.4 Confidence Interval in Summary Statistics Confidence intervals of summary statistics usually have a confidence level of 90%, 95%, or 99%. In this case, we will choose 90% confidence level . In [26]: confidence_level = 0.9 conf_int_perm = calc_confidence_interval ( boot_perm_sum_stats , confidence_level ) conf_int_perm . round ( 1 ) Out[26]: P5.0 P50 P95.0 mean 146.1 160.0 171.3 std 64.4 77.4 96.4 min 43.5 43.5 54.3 max 321.1 573.5 573.5 median 132.7 144.3 156.1 skew 0.4 1.4 2.2 kurtosis -0.6 4.0 8.6 IQR 78.4 98.1 120.9 In [27]: print_confidence_interval ( conf_int_perm , confidence_level ) By 90.0% chance, the following statistics will fall within the range of: mean : 146.1 ~ 171.3 , AVG = 160.0 std : 64.4 ~ 96.4 , AVG = 77.4 min : 43.5 ~ 54.3 , AVG = 43.5 max : 321.1 ~ 573.5 , AVG = 573.5 median : 132.7 ~ 156.1 , AVG = 144.3 skew : 0.4 ~ 2.2 , AVG = 1.4 kurtosis : -0.6 ~ 8.6 , AVG = 4.0 IQR : 78.4 ~ 120.9 , AVG = 98.1","tags":"Statistics","url":"https://aegis4048.github.io/non-parametric-confidence-interval-with-bootstrap","loc":"https://aegis4048.github.io/non-parametric-confidence-interval-with-bootstrap"},{"title":"Uncertainty Modeling with Monte-Carlo Simulation","text":"The code snippet assumes Anaconda 5.2.0 version of Python virtual environment Acknowledgement I would like to acknowledge Micahel Pyrcz , Associate Professor at the University of Texas at Austin in the Petroleum and Geosystems Engineering, for developing course materials that helped me write this article. Check out his Youtube Lecture on Monte-Carlo Simulation to help yourself better understand the statistical theories and concepts. Monte Carlo Simulation is a random sampling method to model uncertainty of a population estimation. When given only population parameters (mean, standard deviation, degrees of freedom, etc..), but not the sample data itself, it generates random samples based on the distribution parameters to create a sample pool that is representative of the true population. Uncertainty models can be created from the newly generated sample pool. Based on historical data, expertise in the field, or past experience, you might know the typical values of population mean, standard deviation and degrees of freedom. While these parameters are useful for developing a model, they do not tell you the uncertainties in a population. In a financial market, you might know the distribution of possible values through the mean and standard deviation of returns. By using a range of possible values, instead of a single guess, you can create a more realistic picture of what might happen in the future. Let's assume that your consultant recommended you a certain investment program that has a mean return rate of 10% and a standard deviation of 1% However, You do not have an access to the actual sample data that is used to obtain the mean, and standard deviation . You made 100 investments through this program, but your 100 investments had an average rate of return of 3%. Did the consultant lie to you, or is it one of the possible corner cases that you can have if you are unlucky? What is the P10, P50, P90 value of this investment program? What are the the most plausible range of rate of return? Does your 3% rate of return fall within that range ? In order to answer these questions, you need sample data that is representative of the population. Monte-Carlo simulation takes population parameters as arguments, and generates series of random samples to investigate a range of possible outcomes . Methodology Monte-Carlo simulation is one of the random sampling method that generates a new set of random samples from statistic parameters of a population. It assumes a certain distribution shape, and population parameters as input and returns a random sample based on the distribution shape and parameters. The most simple examples are as follows: Excel Gaussian: NORM.INV(RAND(), mean, stdev) Lognormal: LOGNORM.INV(RAND(), mean, stdev) Chi-Square: CHISQ.INV(RAND(), degree_freedom) F-distribution: F_INV(RAND(), degree_freedom_numerator, degree_freedom_denominator) Python Gaussian: np.random.normal(mean, stdev) Lognormal: np.random.lognormal(mean, stdev) Chi-Square: np.random.chisquare(degree_freedom) F-distribution: np.random.f(degree_freedom_numerator, degree_freedom_denominator) These examples are the most simple cases of generating random samples vis Monte-Carlo simulation. Random samples can be generated as many times as desired. Based on the N-number of random samples generated, you can draw a CDF or boxplot to model uncertainty in prediction. Warning! In order to use Monte-Carlo simulation, you must know the distribution shape (normal, lognormal, chi-square, etc..) and distribution parameters (mean, standard deviation, degrees of freedom, etc..) of the data. If you do not have enough samples to draw an uncertainty model, or do not know the distribution shape and parameters, Bootstrap simulation may address your issue. Random samples of interest can can be created via an applied form of Monte-Carlo simulation. For example, the Casino Dice Roll Example simulates a game 1,000 times for a single player, and calculates a player's final fund at the end. The final fund of a single player is one random Monte-Carlo sample. The process is repeated 100 times to account for 100 players' final fund, and now we have 100 random Monte-Carlo samples. Total Thickness of Two Formations Example generates two sets of Monte-Carlo formation samples N times (where N is arbitrary number of your choice) to account for Formation A, and Formation B. The two sets of Monte-Carlo formation data are then added together to obtain Monte-Carlo data for total thickness. 1. Casino Dice Roll Example How do casinos earn money? The answer is simple - the longer you play, the bigger the chance of you losing money. Let's assume an imaginary dice roll game between a casino house and a player. The rules are simple. Dice Roll Game Rules There is an imaginary dice that rolls between 1 to 100. If a player rolls between 1 to 51, the house wins. If a player rolls between 52 to 100, the player wins. A player can bet as many times as he wants. With the above rules, the house has 2% higher chance of winning over a player . As a financial analyst of the house, upper management wants you to create a Dice Roll game profit forecast model. Question : If a certain game is configured so that the house has 2% higher chance of winning over a player , what is the expected profit forecast model for the game? Monte-Carlo simulation can be used to simulate the possible outcomes of dice roll game, and generate a forecast model. 1.0 Game Simulator Scripts Imports In [2]: import random import scipy import matplotlib.pyplot as plt import pandas as pd import numpy as np % matplotlib notebook Dice Roll Simulation In [3]: def rolldice (): dice = random . randint ( 1 , 100 ) if dice <= 51 : # Player loses return False elif dice > 51 & dice <= 100 : # Player wins return True Single Game Simulation In [4]: def play ( total_funds , wager_amount , total_plays , final_fund ): play_num = [] # x-axis of the plot funds = [] # y-axis of the plot play = 1 while play <= total_plays : if rolldice (): # Player wins total_funds = total_funds + wager_amount # updates current total funds play_num . append ( play ) funds . append ( total_funds ) else : # Player loses total_funds = total_funds - wager_amount play_num . append ( play ) funds . append ( total_funds ) play = play + 1 final_fund . append ( funds [ - 1 ]) # final_fund contains the ending fund of all players return final_fund , play_num , funds Results Visualization In [5]: def simulate_visualize ( init_money , bet , num_bet , num_players = 1 ): # simulates and generates a plot f , ax = plt . subplots () count = 1 ending_fund_all_players = [] while count <= num_players : ending_fund_all_players , num_play , funds_record = play ( init_money , bet , num_bet , ending_fund_all_players ) ax . plot ( num_play , funds_record ) count += 1 ax . set_title ( str ( num_players ) + ' Player(s): ' + 'Change in Total Fund with Each Game' ) ax . set_ylabel ( 'Player \\' s Fund ($)' ) ax . set_xlabel ( 'Number of Bets' ) return ending_fund_all_players In [6]: def simulate ( init_money , bet , num_bet , num_players = 1 ): # simulates, but does not plot count = 1 ending_fund_all_players = [] while count <= num_players : ending_fund_all_players , num_play , funds_record = play ( init_money , bet , num_bet , ending_fund_all_players ) count += 1 return ending_fund_all_players 1.1 Monte-Carlo Simulation: 1 Player Let's say than an imaginary player, 'Eric', visits the house and wants to play the Dice Roll Game. A Monte-Carlo simulation can be run to simulate the result of Eric's game. The simulation will be run with the following conditions: Eric starts with \\$10,000 Eric bets \\$100 each time Eric plays the game 1,000 times In [148]: simulate_visualize ( init_money = 10000 , bet = 100 , num_bet = 1000 , num_players = 1 ) plt . axhline ( 10000 , color = \"red\" , linewidth = 3 ) plt . text ( 780 , 10200 , 'Starting Money $10,000' , color = 'red' ); Eric started with 10,000 dollars. To your surprise, Eric actually ended up earning money from the house by 2,500 dollars after 1,000 games . According to the configuration of the game, the house has 2% higher chance of winning over Eric. Therefore, with such a high number of games, like a thousand, the house was supposed to earn money from the player. But it was not the case here. Was the configuration of the game wrong, or was Eric just really lucky? 1.1 Monte-Carlo Simulation: 100 Players Eric earned $2,500 dollars after running 1,000 games. However, if hundred other players play the Dice Roll game for thousand times each, would the result be different? From the house's perspective, what is the expected profit from the Dice Roll game? To get more accurate estimation of the expected profit, multiple Monte-Carlo simulation will be run. In this case, hundred. The simulation will be run with the following conditions: Hundred players each start with \\$10,000 Hundred players bet \\$100 each time Hundred players play the game 1,000 times In [7]: simulate_visualize ( init_money = 10000 , bet = 100 , num_bet = 1000 , num_players = 100 ) plt . axhline ( 10000 , color = \"white\" , linewidth = 3 ) plt . text ( 100 , 10400 , 'Starting Money $10,000' , color = 'white' , weight = 'bold' ); As it can be shown on the plots, Eric's earning 2,500 dollars after 1,000 games was a plausible outcome. There was even a player who eanred ended up with 16,500 dollars, which means that he earned 6,500 dollars ! However, this does not mean that the house will earn negative profit. The plot clearly indicates overall trend in the house earning money over the players as the number of bets increases. 1.3 Uncertainty Modeling The previous simulation results represent the outcome of 100 players each playing 1,000 games . One hundred Monte-Carlo simulations were run, and now we have one hundred samples of 1,000 game simulations data. To obtain more accurate uncertainty model for the Dice Roll game, further simulations will be run for 1,000 players each playing 100, 1,000, 10,000, and 100,000 games . In [6]: df = pd . DataFrame () for num_games in [ 100 , 1000 , 5000 , 10000 ]: result = simulate ( init_money = 10000 , bet = 100 , num_bet = num_games , num_players = 1000 ) col_name = str ( num_games ) + ' Games ($)' df [ col_name ] = result In [7]: df . index . name = 'Player Number' df . head ( 10 ) Out[7]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) Player Number 0 8400 7000 5800 -15600 1 8600 8000 16000 -34800 2 9600 7600 -400 5000 3 9400 10400 -6600 -11200 4 9400 10600 -400 0 5 8600 7200 -200 -19600 6 10800 7800 5600 -14000 7 9800 12400 -4000 -6200 8 10600 7600 24600 -9400 9 7400 7400 1800 -19200 In [10]: ax = df . boxplot ( grid = False ) ax . set_title ( 'Uncertainty Model for Dice Roll Game Profit: 1000 Players' ) ax . set_ylabel ( 'Player \\' s Fund ($)' ) ax . axhline ( 10000 , color = \"red\" , linewidth = 3 ); ax . text ( 3.5 , 11500 , 'Starting Money $10,000' , color = 'red' ); The generated box plot is the forecast model for the Dice Roll game profit generation. It tells you the most likely range of profit expected for N number of games played for each player. Based on the box plot uncertainty model, you can confirm that the longer you play, the bigger chance of you losing money. Although some lucky players may double, or even triple their money at the casino, far bigger population of the players will end up losing money to the casino. Recall that the Dice Roll game was configured so that the Casino has 2% higher chance of winning the game over a player. Summary: A player starts with 10,000 dollars and bets 100 dollar for each game. If a player plays 100 games, he will most likely end up between 12,500 to 6800 dollars If a player plays 1000 games, he will most likely end up between 15,800 to $-$360 dollars If a player plays 5,000 games, he will most likely end up between 19,200 to $-$18,900 dollars If a player plays 10,000 games, he will most likely end up between 15,200 to $-$36,000 dollars 1.4 Outlier Removal and Mean of the Prediction The uncertainty model generated by Monte-Carlo simulations gives you a range of possible outcome. But what if you want a single value of the outcome? One simple way to address this question is to just calculate the average of the simulated data. Means of simulated data BEFORE outlier removal In [192]: raw_mean = pd . DataFrame ( df . describe () . T [ 'mean' ]) . T raw_mean . rename ( index = { 'mean' : 'original mean' }, inplace = True ) raw_mean Out[192]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) original mean 9812.4 7930.8 214.0 -9865.2 But as it can be observed in the boxplot, the simulated data contains outliers (circled points). One might want to remove these outliers before calculating the average of the data to improve accuracy. The traditional IQR outlier detection method can be implemented. IQR = P75 - P25 Lower Fence = P25 - 1.5 $\\times$ IQR Upper Fence = P75 + 1.5 $\\times$ IQR In [1]: def get_outlier_params ( orig_data ): iqr_params = orig_data . describe () . T [[ '25%' , '75%' ]] iqr_params [ 'IQR' ] = iqr_params [ '75%' ] - iqr_params [ '25%' ] iqr_params [ 'Lower Fence' ] = iqr_params [ '25%' ] - 1.5 * iqr_params [ 'IQR' ] iqr_params [ 'Upper Fence' ] = iqr_params [ '75%' ] + 1.5 * iqr_params [ 'IQR' ] return iqr_params In [194]: iqr_params = get_outlier_params ( df ) iqr_params Out[194]: 25% 75% IQR Lower Fence Upper Fence 100 Games ($) 9200.0 10600.0 1400.0 7100.0 12700.0 1000 Games ($) 6000.0 10200.0 4200.0 -300.0 16500.0 5000 Games ($) -4450.0 5200.0 9650.0 -18925.0 19675.0 10000 Games ($) -16600.0 -3150.0 13450.0 -36775.0 17025.0 Means of simulated data AFTER outlier removal In [195]: def remove_outliers ( outlier_params , data ): outlier_removed_df = pd . DataFrame () for column in data . columns : outlier_removed_df [ column ] = data [ column ] . apply ( lambda x : x if x > outlier_params [ 'Lower Fence' ][ column ] else np . nan ) outlier_removed_df [ column ] = data [ column ] . apply ( lambda x : x if x < outlier_params [ 'Upper Fence' ][ column ] else np . nan ) return outlier_removed_df In [196]: new_df = remove_outliers ( iqr_params , df ) new_mean = pd . DataFrame ( new_df . describe () . round ( 1 ) . T [ 'mean' ]) . T new_mean . rename ( index = { 'mean' : 'outlier-removed mean' }, inplace = True ) pd . concat ([ raw_mean , new_mean ]) Out[196]: 100 Games ($) 1000 Games ($) 5000 Games ($) 10000 Games ($) original mean 9812.4 7930.8 214.0 -9865.2 outlier-removed mean 9800.2 7892.8 172.7 -9950.1 Based on the simulated mean of each players Dice Roll game result, it can be observed that a player will lose ~20,000 dollars if he plays the 10,000 games , betting 100 dollars each game. 2. Oil Field Example: Total Thickness of Two Formations Your company is about to drill into two formations: formation A and formation B . From the previous experiences within the asset, you know the the distribution of each formation's thickness (which is rarely the case...). In order to develop production / facility plans, you need to draw an uncertainty model for the total thickness of formation A + formation B . 2.0.1 Assumptions Before Monte-Carlo simulation is run to develop the uncertainty model, a few assumptions will be made. The formation thickness in the asset has Gaussian distribution Formation A has a mean value of 10 ft, and standard deviation of 2 ft. Formation B has a mean value of 24 ft, and standard deviation of 4 ft. The mean and standard deviation were calculated from large enough samples, and their values are reliable. We are not given any sample data set. We are only given mean and standard deviations. In [18]: assumptions = pd . DataFrame ( data = [[ 10 , 24 ],[ 2 , 4 ]], columns = [ 'Formation A (ft)' , 'Formation B (ft)' ], index = [ 'mean' , 'stdev' ]) assumptions Out[18]: Formation A (ft) Formation B (ft) mean 10 24 stdev 2 4 Recall that Monte-Carlo simulation requires the distribution shape and distribution parameters of the population. If we know the distribution shape, but do not have large enough samples to estimate reasonable values for the mean and the standard deviation of the population, Monte-Carlo simulation for Gaussian distribution may return inaccurate results. This can't really be helped since we just don't have enough samples. Furthurmore, if we have reasonably large enough samples, but do not know the distribution shape, Monte-Carlo simulation cannot be run . Recall that when generating random samples, it assumes a certain form of a distribution. (Ex: numpy.random.normal() , numpy.random.lognormal() , numpy.random.chiquare() ). Notes If Monte-Carlo simulation cannot be run because the distribution shape is unknown, non-parametric Bootstrap simulation can be used to generate random samples. 2.0.2 Why Use Monte-Carlo Simulation? One might ask why Monte-Carlo simulation is needed for this task. Why can't we just add the provided means of the two formations and use it for our thickness model? Total Thickness = Form. A Mean Thickness + Form. B Mean Thickness Total Thickness = 10 ft + 24 ft = 34 ft However, this simple forecast model does not give any information about the uncertainty in the total thickness of the formation. That is, we only know the overall mean thickness, but nothing about the possible range of thickness of the formations. Ideally we want to formulate something like the following: The total formation thickness will fall within the range of 27 ~ 41 ft by 80% chance, with 34 ft being the mean of the distribution. When we are given only the estimated mean and standard deviation of the population, uncertainty model cannot be formulated without some kind of random sampling method. Monte-Carlo simulation can be used to generate a pool of random samples. 2.1 Monte-Carlo Simulation for Gaussian Distribution Steps Using the provided mean and standard deviation, generate a random Gaussian distribution of Formation A and B thickness. Recall that we assumed the thickness distribution to be Gaussian. Generate random thickness values N times. Add the randomly generated thickness values for Formation A and B. Generate visualizations (CDF, boxplot, etc...) The distribution is Gaussian, and therefore np.random.normal() will be used to generate random normal distribution of formation thickness. If the distribution was assumed to be non-Gaussian, other function will be used to create random samples. For more information, check the numpy documentation of random sampling for various distributions . In [19]: mean_A = assumptions [ 'Formation A (ft)' ][ 'mean' ] mean_B = assumptions [ 'Formation B (ft)' ][ 'mean' ] std_A = assumptions [ 'Formation A (ft)' ][ 'stdev' ] std_B = assumptions [ 'Formation B (ft)' ][ 'stdev' ] iteration = 1000 monte_A = np . random . normal ( mean_A , std_A , iteration ) monte_B = np . random . normal ( mean_B , std_B , iteration ) total_thic = monte_A + monte_B df_thic = pd . DataFrame ([ monte_A , monte_B , total_thic ], index = [ 'Formation A (ft)' , 'Formation B (ft)' , 'Total Thickness (ft)' ]) . T df_thic . index . name = 'Iteration' df_thic . round ( 1 ) . head ( 10 ) Out[19]: Formation A (ft) Formation B (ft) Total Thickness (ft) Iteration 0 7.3 29.4 36.6 1 9.4 28.7 38.1 2 7.7 18.5 26.1 3 11.0 33.1 44.1 4 8.1 21.8 29.9 5 10.0 23.2 33.2 6 10.2 26.5 36.7 7 10.8 25.5 36.3 8 10.8 22.7 33.4 9 10.1 23.1 33.3 Visualizations Cumulative probablity function (CDF) and boxplot can be used to visualize the simulation result. In [33]: def visualize_distribution ( dataframe , ax_ ): dataframe = dataframe . apply ( lambda x : x . sort_values () . values ) for col , label in zip ( dataframe , dataframe . columns ): fit = scipy . stats . norm . pdf ( dataframe [ col ], np . mean ( dataframe [ col ]), np . std ( dataframe [ col ])) ax_ . plot ( dataframe [ col ], fit ) ax_ . set_ylabel ( 'Probability' ) In [34]: fig , ( ax1 , ax2 ) = plt . subplots ( 1 , 2 , figsize = ( 8 , 4 )) fig . suptitle ( 'Uncertainty Models for Total Formation Thickness' ) visualize_distribution ( df_thic [ 'Total Thickness (ft)' ] . to_frame (), ax1 ) ax1 . set_title ( 'Probability Distribution Function' ) ax1 . set_ylabel ( 'Probability' ) ax1 . set_xlabel ( 'Total Thickness (ft)' ) ax2 . boxplot ( df_thic [ 'Total Thickness (ft)' ]) ax2 . set_title ( 'Boxplot' ) ax2 . set_ylabel ( 'Total Thickness (ft)' ); ax2 . set_xticklabels ([]); Business Decision on P10, P50, and P90 Statistics Many of the business decisions are made on P10, P50, and P90 values. When reporting your statistical analysis to the management, you want to provide them the most likely range of outcome. In [36]: pd . DataFrame ( df_thic [ 'Total Thickness (ft)' ] . describe ( percentiles = [ 0.1 , 0.9 ])) . T . iloc [:, 4 : 7 ] . round ( 1 ) Out[36]: 10% 50% 90% Total Thickness (ft) 28.6 34.2 39.9 Based on the obtained P10, P50, and P90 values, the following forcast can be constructed: The total formation thickness will fall within the range of 28.6 ~ 39.9 ft by 80% chance, with 34.2 ft being the mean of the distribution.","tags":"Statistics","url":"https://aegis4048.github.io/uncertainty-modeling-with-monte-carlo-simulation","loc":"https://aegis4048.github.io/uncertainty-modeling-with-monte-carlo-simulation"}]};