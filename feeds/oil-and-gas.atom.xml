<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pythonic Excursions - Oil and Gas</title><link href="https://aegis4048.github.io/" rel="alternate"></link><link href="https://aegis4048.github.io/feeds/oil-and-gas.atom.xml" rel="self"></link><id>https://aegis4048.github.io/</id><updated>2023-02-10T00:00:00-08:00</updated><subtitle>Stories about Python and Data Science</subtitle><entry><title>How Do Old DUC Wells Become "Dead" DUCs?</title><link href="https://aegis4048.github.io/how_do_old_duc_wells_become_dead_ducs" rel="alternate"></link><published>2023-02-10T00:00:00-08:00</published><updated>2023-02-10T00:00:00-08:00</updated><author><name>ERIC KIM</name></author><id>tag:aegis4048.github.io,2023-02-10:/how_do_old_duc_wells_become_dead_ducs</id><summary type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color â€¦&lt;/style&gt;</summary><content type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color: #B22B31;
}
.ansi-red-intense-bg {
  background-color: #B22B31;
}
.ansi-green-fg {
  color: #00A250;
}
.ansi-green-bg {
  background-color: #00A250;
}
.ansi-green-intense-fg {
  color: #007427;
}
.ansi-green-intense-bg {
  background-color: #007427;
}
.ansi-yellow-fg {
  color: #DDB62B;
}
.ansi-yellow-bg {
  background-color: #DDB62B;
}
.ansi-yellow-intense-fg {
  color: #B27D12;
}
.ansi-yellow-intense-bg {
  background-color: #B27D12;
}
.ansi-blue-fg {
  color: #208FFB;
}
.ansi-blue-bg {
  background-color: #208FFB;
}
.ansi-blue-intense-fg {
  color: #0065CA;
}
.ansi-blue-intense-bg {
  background-color: #0065CA;
}
.ansi-magenta-fg {
  color: #D160C4;
}
.ansi-magenta-bg {
  background-color: #D160C4;
}
.ansi-magenta-intense-fg {
  color: #A03196;
}
.ansi-magenta-intense-bg {
  background-color: #A03196;
}
.ansi-cyan-fg {
  color: #60C6C8;
}
.ansi-cyan-bg {
  background-color: #60C6C8;
}
.ansi-cyan-intense-fg {
  color: #258F8F;
}
.ansi-cyan-intense-bg {
  background-color: #258F8F;
}
.ansi-white-fg {
  color: #C5C1B4;
}
.ansi-white-bg {
  background-color: #C5C1B4;
}
.ansi-white-intense-fg {
  color: #A1A6B2;
}
.ansi-white-intense-bg {
  background-color: #A1A6B2;
}
.ansi-default-inverse-fg {
  color: #FFFFFF;
}
.ansi-default-inverse-bg {
  background-color: #000000;
}
.ansi-bold {
  font-weight: bold;
}
.ansi-underline {
  text-decoration: underline;
}
/* The following styles are deprecated an will be removed in a future version */
.ansibold {
  font-weight: bold;
}
.ansi-inverse {
  outline: 0.5px dotted;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  position: relative;
  overflow: visible;
}
div.cell:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: transparent;
}
div.cell.jupyter-soft-selected {
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected,
div.cell.selected.jupyter-soft-selected {
  border-color: #ababab;
}
div.cell.selected:before,
div.cell.selected.jupyter-soft-selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #42A5F5;
}
@media print {
  div.cell.selected,
  div.cell.selected.jupyter-soft-selected {
    border-color: transparent;
  }
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
}
.edit_mode div.cell.selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #66BB6A;
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell &gt; div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area &gt; div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area &gt; div.highlight &gt; pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the &lt;head&gt; if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  /* Note that this should set vertical padding only, since CodeMirror assumes
       that horizontal padding will be set on CodeMirror pre */
  padding: 0.4em 0;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only,
    use .CodeMirror-lines for vertical */
  padding: 0 0.4em;
  border: 0;
  border-radius: 0;
}
.CodeMirror-cursor {
  border-left: 1.4px solid black;
}
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .CodeMirror-cursor {
    border-left: 2px solid black;
  }
}
@media screen and (min-width: 4320px) {
  .CodeMirror-cursor {
    border-left: 4px solid black;
  }
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev &lt;Maniac@SoftwareManiacs.Org&gt;
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area 
div.output_area 
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
div.output_area .mglyph &gt; img {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 1px 0 1px 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}



.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}






.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul:not(.list-inline),
.rendered_html ol:not(.list-inline) {
  padding-left: 2em;
}








.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}





.rendered_html pre,




.rendered_html tr,
.rendered_html th,


.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
.rendered_html * + table {
  margin-top: 1em;
}

.rendered_html * + p {
  margin-top: 1em;
}

.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,

.rendered_html img.unconfined,


.rendered_html * + .alert {
  margin-top: 1em;
}
[dir="rtl"] 
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell &gt; div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered 
.text_cell.rendered .rendered_html tr,
.text_cell.rendered .rendered_html th,
.text_cell.rendered 
.text_cell.unrendered .text_cell_render {
  display: none;
}
.text_cell .dropzone .input_area {
  border: 2px dashed #bababa;
  margin: -1px;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
&lt;/style&gt;
&lt;style type="text/css"&gt;pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */&lt;/style&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;blockquote class="quote" style="font-family: unset; font-size: unset; font-style: unset;"&gt;
  This article is a contiuation from the previous article, &lt;a href="https://aegis4048.github.io/duc_wells_and_their_economic_complications" target="_blank"&gt;DUC Wells and Their Economic Complications.&lt;/a&gt;
&lt;/blockquote&gt;&lt;p&gt;The empirical evidence shows that 95% of the wells in the US are completed within 2 years after drilling. Failing to drill within that time may give birth to what we call the "Dead" DUCs - the wells that will never be completed. The speculations as to why those old DUCs are never completed include lost leases and reservoir pressure depletion. However, the study I conducted shows intriguing characteristics that contradict the conventional wisdom that the gap time between drilling and completion has negative impact reservoir conditions, and that it may discourage operators from drilling their old DUCs. In fact, longer gap time seemed to even positively affect production rates for DUC wells under 250~400 days old since drilled.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="toc_container"&gt;
&lt;p class="toc_title"&gt;Contents&lt;/p&gt;
&lt;ul class="toc_list"&gt;
&lt;li&gt;&lt;a href="#Sample data description"&gt;&lt;span class="toc_label"&gt;0&lt;/span&gt;Sample data description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Key takeaways"&gt;&lt;span class="toc_label"&gt;1&lt;/span&gt;Key takeaways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Complications with old DUC wells"&gt;&lt;span class="toc_label"&gt;2&lt;/span&gt;Complications with old DUC wells&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Reasons for dead DUCs: Lost leases"&gt;&lt;span class="toc_label"&gt;2.1&lt;/span&gt;Reasons for dead DUCs: Lost leases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Reasons for dead DUCs: Reservoir conditions...?"&gt;&lt;span class="toc_label"&gt;2.2&lt;/span&gt;Reasons for dead DUCs: Reservoir conditions...?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Reasons for dead DUCs: Conclusion"&gt;&lt;span class="toc_label"&gt;2.3&lt;/span&gt;Reasons for dead DUCs: Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Sample data description"&gt;&lt;/div&gt;&lt;h2 id="0.-Sample-data-description"&gt;0. Sample data description&lt;a class="anchor-link" href="#0.-Sample-data-description"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The main data source used for this article is the &lt;a href="https://www.enverus.com/" target="_blank"&gt;Enverus&lt;/a&gt; Drilling Info application. Within Drilling Info's data base, I selected wells in the seven major basins in the US, defined by the US Energy Information Adminitration's (EIA) &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;Drilling Productivity Report&lt;/a&gt; (DPR): Anadarko, Appalachia, Bakken, Eagle Ford, Haynesville, Niobrara, and Permian.&lt;/p&gt;
&lt;div class="row full_screen_margin_80 mobile_responsive_plot_full_width" id="fig-1" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DPR-basins.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 1: 7 major basins in the US, Source: EIA&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The DPR provides which county and state they used to define each major basins. For your convenience, I compiled a text file (&lt;a href="https://aegis4048.github.io/downloads/notebooks/sample_data/Basins_Boundaries.txt" target="_blank"&gt;Basins_Boundaries.txt&lt;/a&gt;) that has the list of state and counties that can be easily pasted into Drilling Info's filter tab. Pulling all wells in the specified counties and states gives this &lt;a class="ico xls" href="https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx" target="_blank"&gt;Excel file&lt;/a&gt; &lt;strong&gt;(EUR_vs_Lag.xlsx).&lt;/strong&gt; Unfortunately Enverus Drilling Info is a commerical software and not everyone will be able to use it.&lt;/p&gt;
&lt;div class="row full_screen_margin_70 mobile_responsive_plot_full_width" id="fig-2" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/drilling_info_paste.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 2: Pasting the Eagle Ford basin's state and county data into Drilling Info for query&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Key takeaways"&gt;&lt;/div&gt;&lt;h2 id="1.-Key-takeaways"&gt;1. Key takeaways&lt;a class="anchor-link" href="#1.-Key-takeaways"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;div class="highlights" id="key1"&gt;
&lt;div class="highlights-title"&gt;1. 95% of the DUCs in the US are completed within 2 years. DUCs older than that have high chance of becoming "Dead" DUCs&lt;/div&gt;
&lt;div class="highlights-content"&gt;The probability of completion falls drastically after two years, and the operators may risk a chance of losing their drilling investment.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key2"&gt;
&lt;div class="highlights-title"&gt;2. Dead DUC wells are born from lost leases&lt;/div&gt;
&lt;div class="highlights-content"&gt;A lessee who fails to actively use their lease risks losing their rights. This often results in the operator having to incur additional costs to re-lease the land, which can make the investment in completing the well unviable. As a result, the well may never be completed.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key3"&gt;
&lt;div class="highlights-title"&gt;3. Gap time between drilling and completion has negligible impact on reservoir conditions&lt;/div&gt;
&lt;div class="highlights-content"&gt;The study conducted in this article suggests that the gap time does not have enough impact on EUR or first-year production to discourage operators from completing their old DUCs.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key4"&gt;
&lt;div class="highlights-title"&gt;4. DUC wells with 250~400 days of gap time showed the best EUR and first-year production rates&lt;/div&gt;
&lt;div class="highlights-content"&gt;Contrary to what people would normally think, that gap time would deplete the reservoir pressure over time and result in lower production, the gap time seems to have positive effects production for DUC wells under 250~400 days, and then decrease production afterwards.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Complications with old DUC wells"&gt;&lt;/div&gt;&lt;h2 id="2.-Complications-with-old-DUC-wells"&gt;2. Complications with old DUC wells&lt;a class="anchor-link" href="#2.-Complications-with-old-DUC-wells"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DUC wells are a form of oilfield working capital. They are essentially a long-term, partially funded storage of hydrocarbons "under" the ground instead of "on" the ground. An operator drills a well but decides to complete it later when its convenient for him for various reasons. For example he contracted rig crews to drill 50 wells, but the oil price suddenly crashed while drilling the 27th well, which makes completing the well and producing from it much less lucrative compared to the high oil price days. Revoking a rig contract can be expensive. He has no choice but to let the rig crews keep drilling through the 50th well. But he does have a choice of when he wants to complete the drilled wells - he chooses to leave the drilled wells uncompleted and plans to frack them when the oil price recovers... but is this really a smart move?&lt;/p&gt;
&lt;p&gt;&lt;u class="bold"&gt;If a well remains in DUC stage for too long, it no longer functions as a working oilfield capital.&lt;/u&gt; Analyst John Freeman from Raymond James &amp; Associates Inc. said that that 95% of the drilled wells have been completed within 2 years, and that DUCs older than 2 years have low chance of ever being completed and considered &lt;em&gt;out-of-the-system&lt;/em&gt; (a.k.a. &lt;em&gt;Dead DUCs&lt;/em&gt;). Comparing with the Enverus data of wells in the seven DPR regions supports this claim to be reasonably true (I say "reasonably" because the average lag time between completion and drilling varies from basins to basins).&lt;/p&gt;
&lt;p&gt;I compiled the &lt;a class="ico xls" href="https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx" target="_blank"&gt;Spud and completion dates and EUR data (aggregated by region)&lt;/a&gt; &lt;strong&gt;(EUR_vs_Lag.xlsx)&lt;/strong&gt; from the Enverus Drilling Info, and restricted it to horizontal wells that have &lt;em&gt;Completion Date&lt;/em&gt; field populated. This means that I'm excluding wells that are never completed (I do this because there are many uncompleted wells drilled since 2014 or before that will never be completed. Including these wells will skew the resulting statistics). Visualizing the data for each basin with 95% box plot generates the following figure:&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-3" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Days Till Completion After Drilled.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 3: The numeric annotations above each box plot whisker represent 95% upper limit.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (3)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store the completion &amp; drilling date difference data of 7 basins
# data restricted to wells that has "Completion Date" column populated
# source: DrillingInfo App of Enverus

lags = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']
    lags.append(df_cur['Lag'].values)

flattened = []
temp = [list(lag) for lag in lags]
for item in temp:
    flattened += item

lags.append(flattened)
basins.append('All Regions')

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4.5))

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c', 'lightgrey']

cutoff = 95

for i, basin_lag in enumerate(lags):
    i = i + 1
    x = np.random.normal(i, 0.06, size=len(basin_lag))    
    ax.scatter(x, basin_lag, color=colors[i - 1], alpha=0.005)
    _cutoff = int(np.percentile(basin_lag, cutoff))
    ax.text(i, _cutoff + 150, str(_cutoff) + ' days', fontsize=10, ha='center', va='center', color='k')

lw = 1
caps = ax.boxplot(lags, sym='', whis=[0, cutoff], showfliers=True,
                     boxprops=dict(linewidth=lw, color='#4e98c3'),
                     whiskerprops=dict(linewidth=lw, color='#4e98c3', linestyle='--'), vert=True,
                     capprops=dict(linewidth=lw, color='k'),
                     medianprops=dict(linewidth=lw, color='#ad203e'));

n = 0.12
for cap in caps['caps']:
    cap.set(xdata=cap.get_xdata() + (-n, +n))

ax.set_xticklabels(basins, rotation=20)
ax.set_ylim(-70, 2000)
ax.set_ylabel('Lag (Days)')

ax.yaxis.set_major_locator(plt.MaxNLocator(6))
ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Days Till Completion After Drilled: 95\% Boxplot')  + ",  Jan 2014 - June 2022", fontsize=12, pad=10, 
             x=0.35, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.3), xycoords='axes fraction', fontsize=10)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax.transAxes, color='white', alpha=0.5)

ax.axvline(x=7.5, color='k', linestyle='--', linewidth=1, alpha=0.7)

fig.set_facecolor("white")
fig.tight_layout()    
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Different basins have different average lag time between drilling and completion. &lt;a href="#fig-3"&gt;Figure 3&lt;/a&gt; shows that 95% of the wells in Anadarko were completed within 307 days after drilled and the wells in Appalachia within 944 days. Taking the weighted average for all DPR regions shows that &lt;strong&gt;95% wells in the US are completed within 556 days after drilling.&lt;/strong&gt; In the other words, if a well is not completed within that time, it has less than 5% chance of ever being completed. The expensive drilling cost the operator paid would be wasted.&lt;/p&gt;
&lt;p&gt;The natural question we wonder is this - "Why does the probability of completion falls with old DUCs?" The possible causes for this phenomenon can be speculated as the following: logistical issues vs. mechanical problems.&lt;/p&gt;
&lt;div id="Limitations with the EIA data"&gt;&lt;/div&gt;
&lt;div class="alert alert-info"&gt;
&lt;h4&gt;Notes: Limitations with the EIA data&lt;/h4&gt;
&lt;p&gt;While the EIA publishes the number of DUC well estimations and the counties they used for each basin, the EIA doesn't publish what wells are used for their statistics - a.k.a. the well API numbers. According to this &lt;a href="https://www.eia.gov/petroleum/drilling/pdf/duc_supplement.pdf" target="_blank"&gt;supplementary document&lt;/a&gt;, they applied their own historical correlations on top of the Enverus database to make their DUC count estimations. I attempted to match the EIA DUC count with the Enverus data by tweaking filters on Drilling Info (ex: setting &lt;i&gt;Well Status = DUC or Drilled&lt;/i&gt; and selecting &lt;i&gt;Completion Date&lt;/i&gt; column with no entries), only to find out that it's not possible until I know exactly what kind of correlations the EIA used to make their estimations. This makes me doubt the legitimacy of the plots like &lt;a href="https://www.ogj.com/general-interest/economics-markets/article/14207996/rystad-live-us-duc-well-inventory-lowest-since-2013" target="_blank"&gt;this&lt;/a&gt; since EIA doesn't publish well API numbers and spud dates and it's not possible to match the EIA wells with the Enverus wells.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;It would be interesting to see the percentage of live DUCs vs. Dead DUCs (older than 2 years), had the EIA also published the well API numbers they used to compile their DPR report.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Reasons for dead DUCs: Lost leases"&gt;&lt;/div&gt;&lt;h3 id="2.1.-Reasons-for-dead-DUCs:-Lost-leases"&gt;2.1. Reasons for dead DUCs: Lost leases&lt;a class="anchor-link" href="#2.1.-Reasons-for-dead-DUCs:-Lost-leases"&gt;Â¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The &lt;a href="https://glossary.slb.com/en/terms/p/primary_term" target="_blank"&gt;primary term of an oil &amp; gas lease&lt;/a&gt; is a period of time (usually a few years) in which a lessee has an option to drill an oil or gas well, without having to complete and produce. However, the lessee may lose his lease rights if he isn't drilling, producing, or performing any other operations within the 90-day grace period after the first term expiration day. In simple words, &lt;i&gt;"You can't hold onto your lease unless you are doing something with it"&lt;/i&gt;.&lt;/p&gt;
&lt;p&gt;The primary term can be extended into the &lt;a href="https://glossary.slb.com/en/terms/s/secondary_term" target="_blank"&gt;secondary term&lt;/a&gt; withouta the need to drill a new well or completing and producing from a well if the lessee "commences operations for the drilling of a well on leased lands." However, there is often disagreement over what constitutes "commencing operations" between lessees, lessors, and litigants. The courts generally consider both an objective standard (i.e., whether the operator was diligent in pursuing completion) and a subjective standard (i.e., whether the operator acted in good faith) to determine if DUC operations extend the primary term.&lt;/p&gt;
&lt;p&gt;Failing to extend the primary term will result in lost lease, and will require additional dollars to re-lease the land to complete any DUC wells in it. Naturally this reduces profit from the completion and production investments, which contributes to the birth of &lt;em&gt;dead DUCs&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Reasons for dead DUCs: Reservoir conditions...?"&gt;&lt;/div&gt;&lt;h3 id="2.2.-Reasons-for-dead-DUCs:-Reservoir-conditions...?"&gt;2.2. Reasons for dead DUCs: Reservoir conditions...?&lt;a class="anchor-link" href="#2.2.-Reasons-for-dead-DUCs:-Reservoir-conditions...?"&gt;Â¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;During my research on the causes of dead DUC wells, I found that many people attribute them to reservoir conditions (e.g. declining pressure) and other technical issues (e.g. wellbore integrity). However, after analyzing the Enverus database for seven DPR regions, I found that the time gap between drilling and completion has a negligible effect on production volume and rate, not significant enough to deter operators from completing their old DUCs.&lt;/p&gt;
&lt;p&gt;To determine if the time lag has a significant impact on production, I will use two measures: EUR, which assesses if the lag time affects the total recoverable volume over the well's lifetime, and first-year BOE, which evaluates if it affects the initial production rate. I will restrict my analysis to hydrocarbon wells and horizontal wells only, excluding any injection wells, dry holes, cores, etc.&lt;/p&gt;
&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;div id="Comparison with EUR"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Comparison with EUR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The Enverus Drilling Info employs automated algorithms to calculate and update oil and gas EURs. Although these auto-fitted EURs may not be entirely accurate when inspected on a single well-by-well basis, they provide valuable insights for large-scale basin analysis. The oil EUR and gas EUR are combined by converting the gas EUR from MCFD to BOE using a conversion factor of 6. The EUR vs. lag scatter plot (&lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;) shows that the average of each bin remains arguably constant, with some exceptions at the far right due to a lack of data. This suggests that the lag time between drilling and completion has limited impact on total recoverable hydrocarbon volumes, which should not discourage operators from completing their old DUC wells.&lt;/p&gt;
&lt;div class="row" id="fig-4" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Total EUR vs Days Till Completion.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 4: Each dot represents one well's EUR in the basin. Note that the Permian has the most number of wells and Haynesville has the least. The wells are binned by 100 lag days. Each vertical band of dots represents wells completed, for example, between 100 ~ 200 days after drilled. The blue line plot represents the average of wells in each 100-day bins. Note that the credibility of this average line plot falls with the increasing lag days due to lack of data on high-lag-day-bins.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (4)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
from scipy import stats

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

x_max = {
    'Anadarko': 1000,
    'Appalachia' : 1500,
    'Bakken' : 1500,
    'Eagle Ford' : 1500,
    'Haynesville' : 1000,
    'Niobrara' : 1500,
    'Permian' : 1500,
}
y_max = {
    'Anadarko': 3000,
    'Appalachia' : 8000,
    'Bakken' : 3000,
    'Eagle Ford' : 3000,
    'Haynesville' : 8000,
    'Niobrara' : 2000,
    'Permian' : 5000,
}
EURs = ['EUR (Full) BOE', 'EUR Oil (Full)', 'EUR Gas (Full)']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                 # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])] 

    df_cur = df_cur.dropna(subset=EURs) 
    df_cur[EURs] = df_cur[EURs].div(1000).round(0)
    df_cur = df_cur[df_cur['EUR (Full) BOE'] &lt; y_max[basin]]
    dfs.append(df_cur)

############################################# Plot ##############################################

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

axis_tick_fontsize = 13
title_fontsize = 19
markersize = 20
y_label_fontsize = 15

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c']

for i, (ax, df, basin) in enumerate (zip(axes, dfs, basins)):

    df_cur = dfs[i]

    stepsize= 100
    bins = np.arange(0, x_max[basins[i]] + stepsize, stepsize)

    temp = []
    for b in bins[: -1]:
        aa = df_cur[df_cur['Lag'].between(b, b + stepsize)]['EUR (Full) BOE']
        temp.append(aa)

    for j, item in enumerate(temp):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.1, label='One Well EUR')

    ymin = 0 - 0.05 * y_max[basin]
    ax.set_ylim(ymin, y_max[basin])

    means = [np.mean(item) for item in temp]
    ax.plot([i + 1 for i in range(len(means))], means, linestyle='-', marker='o', markersize=8, alpha=0.7, 
            label='Average EUR of wells, binned by 100 lag days')

    ax.set_title(basin, fontsize=title_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)

    ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)
    if i == 4 or i == 6:
        ax.set_xlabel('Lag (Days)', fontsize=y_label_fontsize)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())

    if basin == 'Appalachia' or basin == 'Haynesville' or basin == 'Niobrara':
        ax.yaxis.set_major_locator(plt.MaxNLocator(5))
    elif basin == 'Permian':
        ax.yaxis.set_major_locator(plt.MaxNLocator(6))
    else:
        ax.yaxis.set_major_locator(plt.MaxNLocator(7))

    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)

    ax.set_xticklabels([str(int(item)) + '00' for item in ax.get_xticks()], rotation=30, fontsize=axis_tick_fontsize)

    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0]], [l0[0]], fontsize=14, ncol=2, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])

    h1, l1 = ax.get_legend_handles_labels()
    fig.legend([h1[-1]], [l1[-1]], loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.195), bbox_transform=fig.transFigure, fontsize=16)

    ax.set_facecolor('#eeeeee')
    ax.grid(axis='y', alpha=0.5)
    ax.set_axisbelow(True)
    ax.text(0.15, 0.88, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('Total EUR vs. Days Till Completion')  + ",  Jan 2014 - June 2022", fontsize=20, x=0.28, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.05, 0.173), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Comparison with the first 12 month production"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Comparison with the first 12 month production&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;While the EUR shows &lt;i&gt;"how much total"&lt;/i&gt; oil and gas can be produced throughout the entire life of a well, the first 12 month production shows &lt;i&gt;"how fast"&lt;/i&gt; they can be extracted. Usually a high rate (fast) is desirable as it reduces operating costs and extends the lifespan of a well. Each well has an economic limit, beyond which it becomes unprofitable if the cost of operations exceeds the revenue generated from the hydrocarbons produced. High production rate shifts this economic limit to the right on the time axis of a production decline curve, thus extending the life of the well.&lt;/p&gt;
&lt;p&gt;The first 12-month production is particularly significant for horizontal wells, as they produce a significant portion of their lifetime oil and gas production, accounting for 37% and 25% respectively, in the first 12 months of production (&lt;a href="https://nondoc.com/2017/07/12/horizontal-wells-first-three-years/" target="_blank"&gt;source&lt;/a&gt;). This is of particular relevance in the current oil and gas industry, where 94% of newly drilled wells are horizontal.&lt;/p&gt;
&lt;p&gt;Visualizing the wells with the first 12 month production vs. lag scatter plot generates &lt;a href="#fig-5"&gt;Figure 5&lt;/a&gt;, which confirms the observations and conclusions drawn from &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;: the lag time between drilling and completion does not affect the first 12 month production enough to make operators shy away from completing their old DUCs.&lt;/p&gt;
&lt;div class="row" id="fig-5" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/First 12 month Production vs Days Till Completion.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 5: Same as Figure 4 except that the line plot represents average of the first 12 month production of each 100-day bin.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (5)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
from scipy import stats

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

x_max = {
    'Anadarko': 1000,
    'Appalachia' : 1500,
    'Bakken' : 1500,
    'Eagle Ford' : 1500,
    'Haynesville' : 1000,
    'Niobrara' : 1500,
    'Permian' : 1500,
}
y_max = {
    'Anadarko': 1000,
    'Appalachia' : 2000,
    'Bakken' : 500,
    'Eagle Ford' : 1000,
    'Haynesville' : 1500,
    'Niobrara' : 500,
    'Permian' : 1000,
}
EURs = ['EUR (Full) BOE', 'EUR Oil (Full)', 'EUR Gas (Full)', 'First 12 BOE']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                 # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])] 

    df_cur = df_cur.dropna(subset=EURs) 
    df_cur[EURs] = df_cur[EURs].div(1000).round(0)
    dfs.append(df_cur)

############################################# Plot ##############################################

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

axis_tick_fontsize = 13
title_fontsize = 19
markersize = 20
y_label_fontsize = 15

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c']

for i, (ax, df, basin) in enumerate (zip(axes, dfs, basins)):

    df_cur = dfs[i]

    stepsize= 100
    bins = np.arange(0, x_max[basins[i]] + stepsize, stepsize)

    temp = []
    for b in bins[: -1]:
        aa = df_cur[df_cur['Lag'].between(b, b + stepsize)]['First 12 BOE']
        temp.append(aa)

    for j, item in enumerate(temp):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.1, label='One Well First 12mo Prod.')

    ymin = 0 - 0.05 * y_max[basin]
    ax.set_ylim(ymin, y_max[basin])

    means = [np.mean(item) for item in temp]
    ax.plot([i + 1 for i in range(len(means))], means, linestyle='-', marker='o', markersize=8, alpha=0.7, color='k',
            label='AVG 1st 12mo Prod. of wells, binned by 100 lag days')

    ax.set_title(basin, fontsize=title_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)

    ax.set_ylabel('First 12mo Prod. (MBOE)', fontsize=y_label_fontsize)
    if i == 4 or i == 6:
        ax.set_xlabel('Lag (Days)', fontsize=y_label_fontsize)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())

    if basin == 'Appalachia':
        ax.yaxis.set_major_locator(plt.MaxNLocator(5))
    else:
        ax.yaxis.set_major_locator(plt.MaxNLocator(6))

    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)

    ax.set_xticklabels([str(int(item)) + '00' for item in ax.get_xticks()], rotation=30, fontsize=axis_tick_fontsize)

    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0]], [l0[0]], fontsize=14, ncol=2, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])

    h1, l1 = ax.get_legend_handles_labels()
    fig.legend([h1[-1]], [l1[-1]], loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.195), bbox_transform=fig.transFigure, fontsize=16)

    ax.set_facecolor('#eeeeee')
    ax.grid(axis='y', alpha=0.5)
    ax.set_axisbelow(True)
    ax.text(0.15, 0.88, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('First 12 month Production vs. Days Till Completion')  + ",  Jan 2014 - June 2022", fontsize=20, x=0.35, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.058, 0.173), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Noteworthy pattern with lag days"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Noteworthy pattern on lag time vs. production&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The plot of lag vs. EUR (or the first 12 months of production) in our study exhibits intriguing characteristics that contradict conventional wisdom, which assumes that older DUCs have inferior reservoir conditions compared to newly drilled wells. However, our analysis shows that this assumption is only true for wells with lag days exceeding 400. As seen in &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; below, which is a zoomed in version of &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt; above, binned by 50 days instead of 100 days, the average EUR for wells in Anadarko and Haynesville increases with the increasing lag days until it reaches 250 lag days, after which it slightly decreases. A closer examination of the other basins in &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt; reveals similar trends, with the EUR increasing until 250~400 lag days and then gradually decreasing.&lt;/p&gt;
&lt;p&gt;The findings of this study challenge the conventional notion that older DUC wells would exhibit decreased reservoir pressure compared to newly drilled wells. Interestingly, the results indicate the opposite trend for DUC wells with an age less than 400 days.&lt;/p&gt;
&lt;p&gt;The reasons behind this unexpected outcome are not clear. Further investigation is needed to fully understand the impact of increasing lag days on production. It is possible that the wells completed within the 250-400 lag day period possess favorable attributes that contribute to their high production or that improved perforation and production techniques tend to be utilized for those wells. Further research is required to validate these speculations.&lt;/p&gt;
&lt;div class="row" id="fig-6" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Total EUR vs Days Till Completion Zoomed In.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 6: Similar to Figure 4, but this time it's binned by 50-day instead of 100-day and zoomed-in on both x- and y-axis. The EUR seems to increase with the increasing lag days between drilling and completion until ~250 lag days&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (6)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
from scipy import stats

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Haynesville'])

################################### DUC Wells Count per Basin #####################################

x_max = {
    'Anadarko': 1000,
    'Haynesville' : 1000,
}
y_max = {
    'Anadarko': 1500,
    'Haynesville' : 4000,
}
EURs = ['EUR (Full) BOE', 'EUR Oil (Full)', 'EUR Gas (Full)']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                 # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])] 

    df_cur = df_cur.dropna(subset=EURs) 
    df_cur[EURs] = df_cur[EURs].div(1000).round(0)
    df_cur = df_cur[df_cur['EUR (Full) BOE'] &lt; y_max[basin]]
    dfs.append(df_cur)

############################################# Plot ##############################################

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

fig = plt.figure(figsize=(16, 8.5))
gs = gridspec.GridSpec(2, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
axes = [ax1,ax2]

axis_tick_fontsize = 14
title_fontsize = 19
markersize = 20
y_label_fontsize = 16
legend_annot_fontsize = 18

colors = ['grey', '#c6b4ee']

for i, (ax, df, basin) in enumerate (zip(axes, dfs, basins)):

    df_cur = dfs[i]

    stepsize= 50
    bins = np.arange(0, x_max[basins[i]] + stepsize, stepsize)

    temp = []
    for b in bins[: -1]:
        aa = df_cur[df_cur['Lag'].between(b, b + stepsize)]['EUR (Full) BOE']
        temp.append(aa)

    for j, item in enumerate(temp):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.1, label='One Well EUR')

    ymin = 0 - 0.05 * y_max[basin]
    ax.set_ylim(ymin, y_max[basin])

    means = [np.mean(item) for item in temp]
    ax.plot([i + 1 for i in range(len(means))], means, linestyle='-', marker='o', markersize=8, alpha=0.7, 
            label='Average EUR of wells, binned by 100 lag days')

    ax.set_title(basin, fontsize=title_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)

    ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)
    ax.set_xlabel('Lag (Days)', fontsize=y_label_fontsize + 1)
    ax.yaxis.set_major_formatter(ticker.EngFormatter())

    if basin == 'Haynesville':
        ax.yaxis.set_major_locator(plt.MaxNLocator(5))
    else:
        ax.yaxis.set_major_locator(plt.MaxNLocator(6))

    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)

    ax.set_xticklabels([str(int(item)) + '00' for item in ax.get_xticks()], rotation=30, fontsize=axis_tick_fontsize)

    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0]], [l0[0]], fontsize=13, ncol=2, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])

    h1, l1 = ax.get_legend_handles_labels()
    fig.legend([h1[-1]], [l1[-1]], loc='lower left', ncol=2,
               bbox_to_anchor=(0.315, 0.35), bbox_transform=fig.transFigure, fontsize=legend_annot_fontsize)

    ax.set_facecolor('#eeeeee')
    ax.grid(axis='y', alpha=0.5)
    ax.set_axisbelow(True)
    ax.text(0.17, 0.88, 'aegis4048.github.io', fontsize=14, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.86
fig.suptitle(setbold('Total EUR vs. Days Till Completion Zoomed In')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.31, y=1.05)
ax.annotate('', xy=(0.005, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.01, 0.16), 
            xycoords='figure fraction', fontsize=legend_annot_fontsize)

fig.set_facecolor("white")   
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Reasons for dead DUCs: Conclusion"&gt;&lt;/div&gt;&lt;h3 id="2.3.-Reasons-for-dead-DUCs:-Conclusion"&gt;2.3. Reasons for dead DUCs: Conclusion&lt;a class="anchor-link" href="#2.3.-Reasons-for-dead-DUCs:-Conclusion"&gt;Â¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The empirical evidence shows that wells older than 2 years have a low likelihood of completion and become dead DUCs. Our analysis of seven DPR regions revealed that 95% of wells in the US are completed within 556 days of drilling, with the probability of completion rapidly declining after that. The speculations as to why those old DUCs are never completed include lost leases and reservoir pressure depletion, in which the latter has been challenged by our study; we found that the decline in EUR and first 12-month production due to increasing time gap between drilling and completion is not substantial enough to discourage operators from completing these wells. In fact, our findings showed that EUR and production actually increase with increasing lag time, up to 250-400 days, which was surprising.&lt;/p&gt;
&lt;p&gt;In conclusion, our study suggests that the underlying cause of dead DUCs is not technical problems like reservoir pressure depletion, but logistical issues such as lost leases. Further more, wells completed rougly 1 year after drilling seems to show the best EUR and first year production rates.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: 'center'," +
        "    displayIndent: '0em'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['$','$'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
        "    } " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="oil-and-gas"></category><category term="oil"></category><category term="gas"></category><category term="DUC"></category><category term="drilling"></category><category term="horizontals"></category><category term="verticals"></category><category term="completion"></category><category term="production"></category><category term="recent-trend"></category><category term="energy-shortage"></category><category term="EIA"></category><category term="DrillingInfo"></category><category term="Enverus"></category><category term="DPR"></category><category term="dead-duc"></category></entry><entry><title>DUC Wells and Their Economic Complications</title><link href="https://aegis4048.github.io/duc_wells_and_their_economic_complications" rel="alternate"></link><published>2023-02-09T00:00:00-08:00</published><updated>2023-02-09T00:00:00-08:00</updated><author><name>ERIC KIM</name></author><id>tag:aegis4048.github.io,2023-02-09:/duc_wells_and_their_economic_complications</id><summary type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color â€¦&lt;/style&gt;</summary><content type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color: #B22B31;
}
.ansi-red-intense-bg {
  background-color: #B22B31;
}
.ansi-green-fg {
  color: #00A250;
}
.ansi-green-bg {
  background-color: #00A250;
}
.ansi-green-intense-fg {
  color: #007427;
}
.ansi-green-intense-bg {
  background-color: #007427;
}
.ansi-yellow-fg {
  color: #DDB62B;
}
.ansi-yellow-bg {
  background-color: #DDB62B;
}
.ansi-yellow-intense-fg {
  color: #B27D12;
}
.ansi-yellow-intense-bg {
  background-color: #B27D12;
}
.ansi-blue-fg {
  color: #208FFB;
}
.ansi-blue-bg {
  background-color: #208FFB;
}
.ansi-blue-intense-fg {
  color: #0065CA;
}
.ansi-blue-intense-bg {
  background-color: #0065CA;
}
.ansi-magenta-fg {
  color: #D160C4;
}
.ansi-magenta-bg {
  background-color: #D160C4;
}
.ansi-magenta-intense-fg {
  color: #A03196;
}
.ansi-magenta-intense-bg {
  background-color: #A03196;
}
.ansi-cyan-fg {
  color: #60C6C8;
}
.ansi-cyan-bg {
  background-color: #60C6C8;
}
.ansi-cyan-intense-fg {
  color: #258F8F;
}
.ansi-cyan-intense-bg {
  background-color: #258F8F;
}
.ansi-white-fg {
  color: #C5C1B4;
}
.ansi-white-bg {
  background-color: #C5C1B4;
}
.ansi-white-intense-fg {
  color: #A1A6B2;
}
.ansi-white-intense-bg {
  background-color: #A1A6B2;
}
.ansi-default-inverse-fg {
  color: #FFFFFF;
}
.ansi-default-inverse-bg {
  background-color: #000000;
}
.ansi-bold {
  font-weight: bold;
}
.ansi-underline {
  text-decoration: underline;
}
/* The following styles are deprecated an will be removed in a future version */
.ansibold {
  font-weight: bold;
}
.ansi-inverse {
  outline: 0.5px dotted;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  position: relative;
  overflow: visible;
}
div.cell:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: transparent;
}
div.cell.jupyter-soft-selected {
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected,
div.cell.selected.jupyter-soft-selected {
  border-color: #ababab;
}
div.cell.selected:before,
div.cell.selected.jupyter-soft-selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #42A5F5;
}
@media print {
  div.cell.selected,
  div.cell.selected.jupyter-soft-selected {
    border-color: transparent;
  }
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
}
.edit_mode div.cell.selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #66BB6A;
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell &gt; div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area &gt; div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area &gt; div.highlight &gt; pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the &lt;head&gt; if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  /* Note that this should set vertical padding only, since CodeMirror assumes
       that horizontal padding will be set on CodeMirror pre */
  padding: 0.4em 0;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only,
    use .CodeMirror-lines for vertical */
  padding: 0 0.4em;
  border: 0;
  border-radius: 0;
}
.CodeMirror-cursor {
  border-left: 1.4px solid black;
}
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .CodeMirror-cursor {
    border-left: 2px solid black;
  }
}
@media screen and (min-width: 4320px) {
  .CodeMirror-cursor {
    border-left: 4px solid black;
  }
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev &lt;Maniac@SoftwareManiacs.Org&gt;
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area 
div.output_area 
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
div.output_area .mglyph &gt; img {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 1px 0 1px 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}



.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}






.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul:not(.list-inline),
.rendered_html ol:not(.list-inline) {
  padding-left: 2em;
}








.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}





.rendered_html pre,




.rendered_html tr,
.rendered_html th,


.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
.rendered_html * + table {
  margin-top: 1em;
}

.rendered_html * + p {
  margin-top: 1em;
}

.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,

.rendered_html img.unconfined,


.rendered_html * + .alert {
  margin-top: 1em;
}
[dir="rtl"] 
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell &gt; div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered 
.text_cell.rendered .rendered_html tr,
.text_cell.rendered .rendered_html th,
.text_cell.rendered 
.text_cell.unrendered .text_cell_render {
  display: none;
}
.text_cell .dropzone .input_area {
  border: 2px dashed #bababa;
  margin: -1px;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
&lt;/style&gt;
&lt;style type="text/css"&gt;pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */&lt;/style&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Once a well is drilled, it must be completed to produce. However, operators may choose not to immediately complete a well for various reasons:&lt;/p&gt;
&lt;ol class="rounded-list" style="margin-bottom: 30px !important; margin-top: 30px! important;"&gt;
&lt;li&gt;&lt;p&gt;Availability of fracking crews&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Drilling contracts that are too expensive to revoke&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Constraints on capital spending&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Commodity prices&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many others&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Whatever the reasons may be, this in-transit time between drilling and completion stages creates an inventory of DUC wells. The term, &lt;strong&gt;DUC wells&lt;/strong&gt;, have a literal definition - &lt;strong&gt;Drilled but Uncompleted wells&lt;/strong&gt;. They essentially serve as a secodary form of hydrocarbon storage underground, instead of surface storage facilities. The wells can be turned on line for production for cheap; the costs of drilling have been paid, and completion won't be as costly as new drilling. This unique characteristic of DUC wells allows the operators to make strategic decisions during the time of financial crisis (ex: 2020 COVID crash); they complete the existing DUC wells and take profits instead of drilling new wells. However, this profit taking process inevitably leads to the reduction in size of DUC well inventories, which gave rise to the concerns regarding potential energy supply shortage due to the depletion of DUC wells around early 2022.&lt;/p&gt;
&lt;p&gt;In this article I attempt to help the readers to understand what it means to have DUC well inventories, why they exist, and the economic impact they have on the US energy industry.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="toc_container"&gt;
&lt;p class="toc_title"&gt;Contents&lt;/p&gt;
&lt;ul class="toc_list"&gt;
&lt;li&gt;&lt;a href="#Sample data description"&gt;&lt;span class="toc_label"&gt;0&lt;/span&gt;Sample data description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Key takeaways"&gt;&lt;span class="toc_label"&gt;1&lt;/span&gt;Key takeaways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#How are DUC wells created?"&gt;&lt;span class="toc_label"&gt;2&lt;/span&gt;How are DUC wells created?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#DUC wells and Economic Complications"&gt;&lt;span class="toc_label"&gt;3&lt;/span&gt;DUC wells and Economic Complications&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Potential depletion of DUC wells and enegy supply shortage"&gt;&lt;span class="toc_label"&gt;3.1&lt;/span&gt;Potential depletion of DUC wells and enegy supply shortage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Recent trend: more production with less drilling"&gt;&lt;span class="toc_label"&gt;3.2&lt;/span&gt;Recent trend: more production with less drilling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;&lt;a href="#Continued discussion: Dead DUC wells"&gt;&lt;span class="toc_label"&gt;4&lt;/span&gt;Continued discussion: "Dead DUC Wells"&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Sample data description"&gt;&lt;/div&gt;&lt;h2 id="0.-Sample-data-description"&gt;0. Sample data description&lt;a class="anchor-link" href="#0.-Sample-data-description"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The main data source I use for this article is the &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;Drilling Productivity Report&lt;/a&gt; (DPR) from the US Energy Information Administration (EIA), and some supplemental data from the &lt;a href="https://www.enverus.com/" target="_blank"&gt;Enverus&lt;/a&gt; Drilling Info application since 2014. While the DPR data is readily available to the public as its provided by the US government, Enverus' Drilling Info data is not because its a commerical software.&lt;/p&gt;
&lt;p&gt;The DPR data covers the 7 major oil and gas basins in the US: Anadarko, Appalachia, Bakken, Eagle Ford, Haynesville, Niobrara, and Permian.&lt;/p&gt;
&lt;div class="row full_screen_margin_80 mobile_responsive_plot_full_width" id="fig-1" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DPR-basins.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 1: 7 major basins in the US, Source: EIA&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;I downloaded the &lt;a class="ico xls" href="https://www.eia.gov/petroleum/drilling/xls/dpr-data.xlsx" target="_blank"&gt;Report data (aggregated by region)&lt;/a&gt; &lt;strong&gt;(dpr-data.xlsx)&lt;/strong&gt; and the &lt;a class="ico xls" href="https://www.eia.gov/petroleum/drilling/xls/duc-data.xlsx"&gt;DUC data (aggregated by region)&lt;/a&gt; &lt;strong&gt;(duc-data.xlsx)&lt;/strong&gt;, which can be found in the &lt;i&gt;"Contents"&lt;/i&gt; tab in the right side of this &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;page&lt;/a&gt;. Visualizing the DPR data for each basin generates the below figure:&lt;/p&gt;
&lt;div class="row" id="fig-2" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DUC &amp; Newly Drilled Wells and Production by Basins, Jan 2014 - Dec 2022.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 2: Quick glance at the EIA DPR data for each basin. Note that the Permian basin has different y-axis scale for DUC &amp; newly drilled wells count.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (2)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import warnings
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs_year = df.groupby([df.index.year, 'Basin'])['DUC'].mean()
df_DUCs_year = df_DUCs_year.unstack().fillna(0)
df_DUCs_year = round(df_DUCs_year, 0)

df_drilled_year = df.groupby([df.index.year, 'Basin'])['Drilled'].sum()
df_drilled_year = df_drilled_year.unstack().fillna(0)
df_drilled_year['Total Drilled'] = df_drilled_year.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod_year = df2_total_gas_prod_year.unstack().fillna(0)
df2_total_gas_prod_year['Total Gas (BCFD)'] = df2_total_gas_prod_year.T.apply(lambda x: sum(x))
df2_total_gas_prod_year = df2_total_gas_prod_year / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod_year = df2_total_oil_prod_year.unstack().fillna(0)
df2_total_oil_prod_year['Total (MMBBLD)'] = df2_total_oil_prod_year.T.apply(lambda x: sum(x))
df2_total_oil_prod_year = df2_total_oil_prod_year / 1000000

############################################# Plot ##############################################

# changing datetime index to str is necessary to overlay lineplot on top of barplot
df_drilled_year.index = [str(item) for item in df_drilled_year.index]
df2_total_gas_prod_year.index = [str(item) for item in df2_total_gas_prod_year.index]
df2_total_oil_prod_year.index = [str(item) for item in df2_total_oil_prod_year.index]

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

axis_fontsize = 15
axis_tick_fontsize = 11
title_fontsize = 18
figure_title_fontsize = 20
label_fontsize = 13
legend_fontsize = 16
markersize = 9
y_label_fontsize = 15

gas_prod_color = 'red'
oil_prod_color = 'green'
drilled_color = 'k'

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

for i, (ax, basin) in enumerate(zip(axes, basins)):

    df_DUCs_year.plot.bar(alpha=1, y=basin, ax=ax, legend=None, width=0.9, edgecolor='k', linewidth=0.1, label='DUC Count', color=barcolor_dict[basin])

    ax1 = ax.twinx()
    df_drilled_year.plot(y=basin, ax=ax1, linestyle='-', legend=None, marker='o', color=drilled_color, markersize=markersize, label='New Drilled Wells')

    ax2 = ax.twinx()
    df2_total_oil_prod_year.plot(y=basin, ax=ax2, linestyle='-', marker='o', color='green', markersize=markersize, label='Oil Prod Total', legend=None)
    ax2.set_ylim(0, 70)

    ax3 = ax.twinx()
    df2_total_gas_prod_year.plot(y=basin, ax=ax3, linestyle='-', marker='o', color='red', markersize=markersize, label='Gas Prod Total', legend=None)
    ax3.set_ylim(0, 500)

    ax.set_facecolor('#eeeeee')
    ax.set_axisbelow(True)
    ax.grid(axis='y')
    ax.set_xticklabels([str(dt).split('-')[0] for dt in df_DUCs_year.index])
    ax.tick_params(axis='x', labelrotation=45, labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax1.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.set_title(basin, fontsize=title_fontsize)

    if i % 2 == 0 and i != 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
        ax2.set_yticks([])
        ax3.set_yticks([])        
    else:
        ax1.set_ylabel('Drilled Wells Count (k)', fontsize=axis_fontsize)

        ax2.tick_params(axis='y', colors='green')
        ax2.spines['right'].set_position(('outward', 50))
        ax2.spines['right'].set_color('green')
        ax2.set_ylabel('Total Oil Prod. (MMBBLD)', color='green', fontsize= axis_fontsize)

        ax3.tick_params(axis='y', colors='red')
        ax3.spines['right'].set_position(('outward', 100))
        ax3.spines['right'].set_color('red')
        ax3.set_ylabel('Total Gas Prod. (BCFD)', color='red', fontsize= axis_fontsize) 

    if i == 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
    #else:
        #ax1.set_yticks([])
        #ax2.set_yticks([])
        #ax3.set_yticks([])

    if i == 4 or i == 6:
        ax.set_xlabel('Spud Date', fontsize=y_label_fontsize)
    else:
        ax.set_xlabel('')

    if basin == 'Permian':
        pass
        ax.set_ylim(0, 5000)
        ax1.set_ylim(0, 15000)

    else:
        ax.set_ylim(0, 1400)
        ax1.set_ylim(0, 7000)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax1.yaxis.set_major_formatter(ticker.EngFormatter())        

    ax.spines.top.set_visible(False)
    ax1.spines.top.set_visible(False)
    ax2.spines.top.set_visible(False)
    ax3.spines.top.set_visible(False)

    #ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    #ax1.yaxis.get_major_ticks()[-1].gridline.set_visible(False)

    h0, l0 = ax.get_legend_handles_labels()
    h1, l1 = ax1.get_legend_handles_labels()
    h2, l2 = ax2.get_legend_handles_labels()
    h3, l3 = ax3.get_legend_handles_labels()
    ax.legend(h0, l0, loc='upper left', ncol=2, fontsize=13, framealpha=0.5)

    fig.legend(h3 + h2 + h1, l3 + l2 + l1, loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.165), bbox_transform=fig.transFigure, fontsize=legend_fontsize)

    for c in ax.containers:
        ax.bar_label(c, label_type='center', color='white', weight='bold', fontsize=label_fontsize)

    ax.text(0.16, 0.80, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)        

fig.tight_layout()

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('DUC &amp; Newly Drilled Wells Count and Production')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.328, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(0.05, 0.145), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;For the Enverus data, I synchronized the wells from the EIA database with the Drilling Info database by matching their states and counties. The &lt;i&gt;"RegionCounties"&lt;/i&gt; tab in the &lt;strong&gt;dpr-data.xlsx&lt;/strong&gt; shows how EIA decides which states and counties belong to which basins. If you have Driling Info subscription and would like to follow the steps I've taken, you can download this &lt;a href="https://aegis4048.github.io/downloads/notebooks/sample_data/Basins_Boundaries.txt" target="_blank"&gt;text file&lt;/a&gt; I created, and paste its state and county data into Drilling Info's &lt;i&gt;"Paste Filter Selections"&lt;/i&gt; as shown below. You will need to do this 7 times for each basins.&lt;/p&gt;
&lt;div class="row full_screen_margin_70 mobile_responsive_plot_full_width" id="fig-3" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/drilling_info_paste.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 3: Pasting the Eagle Ford basin's state and county data into Drilling Info for query&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Key takeaways"&gt;&lt;/div&gt;&lt;h2 id="1.-Key-takeaways"&gt;1. Key takeaways&lt;a class="anchor-link" href="#1.-Key-takeaways"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;div class="highlights" id="key1"&gt;
&lt;div class="highlights-title"&gt;1. DUCs are accumulated when drilling activity exceeds completion, and vice versa&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key2"&gt;
&lt;div class="highlights-title"&gt;2. DUCs are created due to the following reasons:&lt;/div&gt;
&lt;div class="highlights-content"&gt;(1) Cost efficiency with batch-fracking or batch-drilling (2) Drilling contracts that are too expensive to revoke (3) Constraitns on capital spending and (4) Lack of infrastructure.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key3"&gt;
&lt;div class="highlights-title"&gt;3. DUC wells function as a working oilfield capital&lt;/div&gt;
&lt;div class="highlights-content"&gt;DUCs can quickly be turned on line for production for cheap because the cost of drilling has already been paid. Completing DUC wells is essentially a profit-taking process, so long as there are DUCs left to complete.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key4"&gt;
&lt;div class="highlights-title"&gt;4. Depletion of DUC wells may cause energy shortage problems&lt;/div&gt;
&lt;div class="highlights-content"&gt;The recent COVID crash left operators with scarce capitals to spend. They chose to complete the existing DUC wells for profit instead of drilling new wells, which resulted in fast depletion of DUCs in the US. Prolonged profit-taking process from DUCs without new drilling may result in energy shortage problems when the operators run out of DUC wells to complete.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key5"&gt;
&lt;div class="highlights-title"&gt;5. Modern day industry is producing more hydrocarbons with less drilling activities&lt;/div&gt;
&lt;div class="highlights-content"&gt;This is due to the fact horizontal wells produce 2.5 to 7 times more than verticals, and that modern day drilling is composed of 91% horizontals and 9% verticals.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key6"&gt;
&lt;div class="highlights-title"&gt;6. Gap time between drilling and completion should not be a contributing factor to the birth of "Dead" DUCs&lt;/div&gt;
&lt;div class="highlights-content"&gt;The impact of gap time is not significant enough to render operators to shy away from completing their old DUCs. This is discussed in more detail in my next article.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="How are DUC wells created?"&gt;&lt;/div&gt;&lt;h2 id="2.-How-are-DUC-wells-created?"&gt;2. How are DUC wells created?&lt;a class="anchor-link" href="#2.-How-are-DUC-wells-created?"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The formation of DUC wells in the oil and gas industry is caused by a variety of factors. The most straightforward reason is that they occur when operators drill more wells than they complete, and vice versa, whether by choice or not. If they drill more wells than they complete, DUC wells accumulate. If they complete more wells than they drill, DUC wells deplete. This trend can be observed in &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;, which showcases three distinct periods where the US DUC well counts in the seven DPR regions experienced rapid increases and decreases as a result of imbalanced drilling and completion activities.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-4" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/US Major Basins Completion &amp; Drilling Activities.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 4: The line plots depict three distinct periods of significant fluctuations in DUC well inventories, with [1] and [3] representing instances of rapid depletion due to low completion rates, and [2] reflecting a period of accumulation resulting from high drilling activities.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (4)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4))

ax2 = ax.twinx()

ax.plot(df_drilled.index, df_drilled['Total Drilled'], color='k', label='Newly Drilled')
ax.plot(df_completed.index, df_completed['Total Completed'], label='Completed')
ax2.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')


ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'], 
                where=(df_drilled.index &gt;= '2016-03-1') &amp; (df_drilled.index &lt;= '2017-1-1'), color='red', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'], 
                where=(df_drilled.index &gt;= '2018-08-01') &amp; (df_drilled.index &lt;= '2019-3-1'), color='green', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'], 
                where=(df_drilled.index &gt;= '2020-07-1') &amp; (df_drilled.index &lt;= '2022-8-1'), color='red', alpha=0.4)

ax.axvline(x=df_drilled.index[26], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[35], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[26], df_drilled.index[35], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[55], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[61], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[55], df_drilled.index[61], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[78], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[102], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[78], df_drilled.index[102], facecolor='lightgrey', alpha=0.3)

ax.set_ylim(0, 2500)
ax2.set_ylim(0, 10000)

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[5].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax2.spines.top.set_visible(False)

h1, l1 = ax.get_legend_handles_labels()
h2, l2 = ax2.get_legend_handles_labels()
ax.legend(h1 + h2, l1 + l2, fontsize=10, ncol=3, loc='upper left', framealpha=1)

ax.set_ylabel('Drilled &amp; Completed Wells', fontsize=11)
ax2.set_ylabel('DUC Wells', fontsize=11)

ax.arrow(df_drilled.index[71], 1500, 60, -270, head_width=40, head_length=60, fc='k', ec='k')
ax.text(0.58, 0.62, 'Covid Crash', fontsize=9, transform=ax.transAxes, color='k')

ax.text(0.295, 0.05, '[1]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.53, 0.05, '[2]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.805, 0.05, '[3]', fontsize=9, transform=ax.transAxes, color='k')

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('US Major Basins Completion &amp; Drilling Activities')  + ",  Jan 2014 - Dec 2022", fontsize=12, pad=10, x=0.4, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.11, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=10)
ax.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax.transAxes, color='grey', alpha=0.5)

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Here I list more detailed reasons as to why operators may choose to not complete their well.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cost efficiency with batch-fracking or batch-drilling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As an efficient operator, it is ideal to avoid engaging a fracturing fleet until all logistical requirements have been thoroughly understood and procured and a substantial number of wells have been collected for prolonged, uninterrupted operations. This can be achieved either by maintaining a consistent inventory of wells waiting to be completed or by alternating the company's focus in the region between drilling a series of wells and then completing them all. If there are 10 wells in one location and it takes 10 days to drill each well, the first drilled well will stay idle for at least 90 days before it can be completed. This lag can result in the formation of additional DUC wells in the event of an unforeseen circumstance that renders fracturing unfeasible or undesirable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Drilling contracts that are too expensive to revoke&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Often times the drilling contracts between an operator and a service company entails drilling a batch of wells and expensive contract revokation fee. If the oil price suddenly drops while drilling the contracted batch of wells, the operator may choose not to complete the drilled wells while letting the rig crews keep drilling new wells due to the existing contract. This was the most apparent in the recent COVID crash, which took place around March of 2020. Taking a close look at &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt; around March of 2020 (slightly to the left of [3]), one can observe that there higher drilling than completion activities, which temporarily boosted the number of DUCs until July of 2020 (start of [3]). This happened because there were rig contracts that were still in effect few months after the COVID crash. However, this phenomena did not last long once those contracts expired or have been fulfilled, thus rapidly depleting the number of DUCs until late 2022.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints on capital spending&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The operator may choose not to finish their wells due to restrictions on the company's capital expenditures or adverse market circumstances, opting instead to wait for better economics. However, as shown in &lt;a href="https://aegis4048.github.io/how_do_old_duc_wells_become_dead_ducs#2.-Complications-with-old-DUC-wells" target="blank"&gt;Section 2: Complications with old DUC wells&lt;/a&gt; of my next article, this approach may not always be advisable, as DUC wells older than two years have a low probability, less than 5%, of being completed due to issues such as lost leases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lack of infrastructure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An operator may leave a well uncompleted if there is no nearby pipeline to transport the produced gas after a pad site is cleared and a well is drilled. However, unexpected issues during pipeline construction may result in the well remaining as a DUC well for an extended period until resolved.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="DUC wells and Economic Complications"&gt;&lt;/div&gt;&lt;h2 id="3.-DUC-wells-and-economic-complications"&gt;3. DUC wells and economic complications&lt;a class="anchor-link" href="#3.-DUC-wells-and-economic-complications"&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DUC wells are a form of hydrocarbon storage under the ground instead of on the surface storage facilities. The operators invest on drilling first and take profits later when its desirable. This unique characteristics of DUCs create economic complications for the oil and gas industry due to the following reasons:&lt;/p&gt;
&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Timing:&lt;/strong&gt; DUC wells are partially completed sources of supply that can be brought to market more quickly and at a lower cost than a newly drilled well. However, completing DUC wells at the right time to balance the market demand for energy can be challenging.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p p="" style="display: inline"&gt;&lt;strong&gt;Market fluctuations:&lt;/strong&gt; DUC wells are often used to keep up with demand during times of high energy demand. However, during periods of declining oil prices, completing DUC wells may not be economically viable, leading to a buildup of uncompleted wells. This has been the most apparent between late 2018 to early 2019; WTI crude dropped from &lt;/p&gt;&lt;p style="display: inline"&gt;$&lt;/p&gt;86 to &lt;p style="display: inline"&gt;$&lt;/p&gt;&lt;p style="display: inline"&gt;54. This accumulation of DUCs due to oil price drop can be observed in &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;'s highlighted area [2].&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rig contracts:&lt;/strong&gt; In times of declining oil prices, operators may continue to drill wells due to rig contracts, but not complete these wells and bring them into production. This can result in a buildup of DUC wells that may not be economically viable to complete in the future (due to reasons like lost leases).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Profit-taking:&lt;/strong&gt; Completing DUC wells is essentially a profit-taking process done on wells with substantial investment already made. However, if the timing of completion is not aligned with market demand or if capital is not available, the profit-taking process may not yield the expected results.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Capital management:&lt;/strong&gt; The inventory levels of DUC wells are closely linked to the availability of industry capital. When capital is abundant, producers tend to increase drilling relative to completions, leading to a rise in DUC inventory. On the other hand, when capital is scarce, producers prioritize well completion over new drilling, which can lead to a depletion of DUC wells.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Potential depletion of DUC wells and enegy supply shortage"&gt;&lt;/div&gt;&lt;h3 id="3.1.-Potential-depletion-of-DUC-wells-and-enegy-supply-shortage"&gt;3.1. Potential depletion of DUC wells and enegy supply shortage&lt;a class="anchor-link" href="#3.1.-Potential-depletion-of-DUC-wells-and-enegy-supply-shortage"&gt;Â¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The COVID-19 pandemic resulted in a reduction of available capital for the oil and gas industry. To conserve cash, many operators prioritized well completion over new drilling, enabling them to maintain production with less capital. However, this strategy of profit-taking cannot be sustained in the long-term and resulted in a rapid decrease of DUC wells in the US, raising concerns about the potential depletion of DUCs and energy supply shortages.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-5"&gt;Figure 5&lt;/a&gt; demonstrates the swift depletion rate of DUCs since July 2020. If this rate continued, the US oil and gas industry would have exhausted its DUC wells by the end of 2023, potentially leading to an energy shortage. Fortunately, drilling activity caught up with completion activities by mid-2022, resulting in a stable level of DUC wells now.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-5" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Depletion of DUC wells and energy supply.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 5: Rapid depletion of US DUC wells since July 2020. Prolonged depletion of DUC wells may result in potential shortage with energy supply if the operators don't drill more wells.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (5)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker
from sklearn import linear_model
import datetime

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA-old.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data-old.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

# current year (2022) prediction parameter
num_month_2022 = 6 # number of months in data set for current year
pred_factor = 12 / num_month_2022 

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod = df2_total_gas_prod.unstack().fillna(0)
df2_total_gas_prod['Total Gas (BCFD)'] = df2_total_gas_prod.T.apply(lambda x: sum(x))
df2_total_gas_prod = df2_total_gas_prod / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod = df2_total_oil_prod.unstack().fillna(0)
df2_total_oil_prod['Total Oil (MBBLD)'] = df2_total_oil_prod.T.apply(lambda x: sum(x))
df2_total_oil_prod = df2_total_oil_prod / 1000

############################################# Plot ##############################################

axis_label_fontsize = 12
title_fontsize = 13
legend_fontsize = 11

fig, axes = plt.subplots(2, 1, figsize=(9, 6.5))

ax1 = axes[0]
ax2 = axes[1]
ax3 = ax2.twinx()

n = 16

# extends the right-end of the x-axis
ext = 38
x_extender = df_DUCs.index.union(df_DUCs.index.shift(n + ext)[-(n + ext):])
x_extender_y = [1 for item in x_extender]

ax1.plot(x_extender, x_extender_y, alpha=0)
ax2.plot(x_extender, x_extender_y, alpha=0)

ax1.axvspan(x_extender[-ext-1], x_extender[-1], facecolor='lightgrey', alpha=0.5)
ax2.axvspan(x_extender[-ext-1], x_extender[-1], facecolor='lightgrey', alpha=0.5)

################################### DUC Wells Linear Regression ###################################

X_pred_plot = df_DUCs.index.union(df_DUCs.index.shift(n)[-n:])
X_pred = X_pred_plot.to_julian_date().values.reshape(-1, 1)

X = df_DUCs.index.to_julian_date().values.reshape(-1, 1)
y = df_DUCs['Total DUCs'].values

fit_begin = 79
fit_end = -3
plot_begin = 90

ols = linear_model.LinearRegression()
model = ols.fit(X[fit_begin: fit_end], y[fit_begin: fit_end])
response = model.predict(X_pred[plot_begin:])

ax1.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')
ax1.plot(X_pred_plot[plot_begin:], response, color='b', label='DUC Prediction', linestyle='--', linewidth=2)
ax1.vlines(x=df_DUCs.index[fit_begin - 1], ymin=0, ymax=max(y) - 100, color='purple', alpha=0.7, linestyle='--')
ax1.scatter(X_pred_plot[-1], 0, marker='o', color='b', label='point', clip_on=False, s=80)

############################# Oil and Gas Production Linear Regression ############################

n = n - 2
X_pred_plot = df2_total_oil_prod.index.union(df2_total_oil_prod.index.shift(n)[-n:])
X_pred = X_pred_plot.to_julian_date().values.reshape(-1, 1)

X = df2_total_oil_prod.index.to_julian_date().values.reshape(-1, 1)

y_oil = df2_total_oil_prod['Total Oil (MBBLD)'].values
y_gas = df2_total_gas_prod['Total Gas (BCFD)'].values

ols_oil = linear_model.LinearRegression()
ols_gas = linear_model.LinearRegression()
model_oil = ols_oil.fit(X, y_oil)
model_gas = ols_gas.fit(X, y_gas)
response_oil = model_oil.predict(X_pred)
response_gas = model_gas.predict(X_pred)

ax2.plot(X_pred_plot[plot_begin:], response_oil[plot_begin:], label='Oil Prediction', color='green', linestyle='--')
ax3.plot(X_pred_plot[plot_begin:], response_gas[plot_begin:], label='Gas Prediction', color='red', linestyle='--')

ax2.scatter(X_pred_plot[-1], response_oil[-1], marker='o', color='green', clip_on=False, s=80)
ax3.scatter(X_pred_plot[-1], response_gas[-1], marker='o', color='red', clip_on=False, s=80)

ax2.scatter(df2_total_oil_prod.index, df2_total_oil_prod['Total Oil (MBBLD)'], label='Oil', marker='o', color='green', s=10, alpha=0.3)
ax3.scatter(df2_total_gas_prod.index, df2_total_gas_prod['Total Gas (BCFD)'], label='Gas', marker='o', color='red', s=10, alpha=0.3)

ax1.set_ylim(0, 10000)
ax2.set_ylim(0, 15000)
ax3.set_ylim(0, 150)

ax1.set_ylabel('Drilled &amp; DUC Well Counts', fontsize=axis_label_fontsize)
ax2.set_ylabel('Total Oil Prod. (MBBLD)', fontsize=axis_label_fontsize) 
ax2.set_yticks(np.arange(0, 15001, 3000))
ax3.set_ylabel('Total Gas Prod. (BCFD)', fontsize=axis_label_fontsize) 
ax3.set_yticks(np.arange(0, 151, 30))

ax1.tick_params(axis='both', which='major', labelsize=11)
ax2.tick_params(axis='both', which='major', labelsize=11)

ax1.grid(axis='y', alpha=0.5)
ax1.yaxis.get_major_ticks()[5].gridline.set_visible(False)
ax2.grid(axis='y', alpha=0.5)
ax2.yaxis.get_major_ticks()[5].gridline.set_visible(False)

ax1.spines.top.set_visible(False)
ax1.spines.right.set_visible(False)
ax2.spines.top.set_visible(False)
ax3.spines.top.set_visible(False)

h1, l1 = ax1.get_legend_handles_labels()
ax1.legend(h1[:2], l1[:2], loc='upper left', fontsize=legend_fontsize)
h2, l2 = ax2.get_legend_handles_labels()
h3, l3 = ax3.get_legend_handles_labels()
ax2.legend(h2 + h3, l2 + l3, fontsize=legend_fontsize, ncol=2, loc='upper left')

ax1.yaxis.set_major_formatter(ticker.EngFormatter()) 
ax2.yaxis.set_major_formatter(ticker.EngFormatter())  
ax3.yaxis.set_major_formatter(ticker.EngFormatter())  

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax1.set_title(setbold('Depletion of DUC Wells and Energy Supply')  + ",  Jan 2014 - June 2022", 
             fontsize=title_fontsize, pad=10, x=0.335, y=1.06)
ax1.annotate('', xy=(-0.1, 1.07), xycoords='axes fraction', xytext=(1.07, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax1.text(0.535, 0.4, 'July 2020', fontsize=10, ha='center', va='center', 
        transform=ax1.transAxes, color='purple', alpha=0.7, rotation=270)

ax2.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -0.22), xycoords='axes fraction', fontsize=12)
ax1.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax1.transAxes, color='grey', alpha=0.5)
ax2.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax2.transAxes, color='grey', alpha=0.5)

ax1.text(0.765, 0.43, 'Depleted DUCs', fontsize=11, transform=ax1.transAxes, color='k')
ax2.text(0.75, 0.43, 'Potential Shortage', fontsize=11, transform=ax2.transAxes, color='k')
ax2.text(0.74, 0.33, 'with Energy Supply', fontsize=11, transform=ax2.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Recent trend: more production with less drilling"&gt;&lt;/div&gt;&lt;h3 id="3.2.-Recent-trend:-more-production-with-less-drilling"&gt;3.2. Recent trend: more production with less drilling&lt;a class="anchor-link" href="#3.2.-Recent-trend:-more-production-with-less-drilling"&gt;Â¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Some readers may recall President Biden's request for the US oil and gas industry to ramp up drilling in order to curb the recent surge in gasoline prices. The industry reportedly hesitated to comply due to &lt;a href="https://www.cbsnews.com/news/oil-production-prices-us-companies-wont-increase-2022-dallas-fed-survey/" target="_blank"&gt;pressure from Wall Street for immediate financial returns.&lt;/a&gt; However, this is not the sole reason for the industry's reluctance to return to their previous drilling levels from 2014. Advances in technology (specifically horizontal drilling) have enabled the industry to produce more oil and gas with fewer wells, meaning they no longer need to drill as many wells as in the past to meet production demands.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; highlights three key points that demonstrate a clear trend. The decline in the number of drilling operations can be observed at [1], [2], and [3], while production steadily increases. A comparison to July 2018 [2] shows a 31% reduction in the number of newly drilled wells, but a 26% increase in oil production and a 35% increase in gas production. The contrast becomes even more striking when compared to September 2014 [1], where drilling activity decreased by 50% while production of both oil and gas nearly doubled.&lt;/p&gt;
&lt;div class="row" id="fig-6" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/US Major Basins Well Counts &amp; Production.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 6: Recent trend in production and drilling activities and count of DUC wells. We've been producing more oil and gas with less drilling activities over time.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (6)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

# current year (2022) prediction parameter
num_month_2022 = 6 # number of months in data set for current year
pred_factor = 12 / num_month_2022 

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod = df2_total_gas_prod.unstack().fillna(0)
df2_total_gas_prod['Total Gas (BCFD)'] = df2_total_gas_prod.T.apply(lambda x: sum(x))
df2_total_gas_prod = df2_total_gas_prod / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod = df2_total_oil_prod.unstack().fillna(0)
df2_total_oil_prod['Total Oil (MBBLD)'] = df2_total_oil_prod.T.apply(lambda x: sum(x))
df2_total_oil_prod = df2_total_oil_prod / 1000

############################################# Plot ##############################################

axis_label_fontsize = 13
title_fontsize = 13
legend_fontsize = 11

fig, ax = plt.subplots(figsize=(9, 4.5))

ax3 = ax.twinx()
ax4 = ax.twinx()

ax.plot(df_drilled.index, df_drilled['Total Drilled'], color='k', label='Drilled')
ax.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')
ax3.plot(df2_total_oil_prod.index, df2_total_oil_prod['Total Oil (MBBLD)'], label='Oil', color='green')
ax4.plot(df2_total_gas_prod.index, df2_total_gas_prod['Total Gas (BCFD)'], label='Gas', color='red')

ax.set_ylim(0, 10000)
ax3.set_ylim(0, 15000)
ax4.set_ylim(0, 150)

ax.set_ylabel('Drilled &amp; DUC Well Counts', fontsize=axis_label_fontsize)

ax3.tick_params(axis='y', colors='green')
#ax3.spines['right'].set_position(('outward', 50))
ax3.spines['right'].set_color('green')
ax3.set_ylabel('Total Oil Prod. (MBBLD)', color='green', fontsize=axis_label_fontsize) 
ax3.set_yticks(np.arange(0, 15001, 3000))

ax4.tick_params(axis='y', colors='red')
ax4.spines['right'].set_position(('outward', 50))
ax4.spines['right'].set_color('red')
ax4.set_ylabel('Total Gas Prod. (BCFD)', color='red', fontsize=axis_label_fontsize) 
ax4.set_yticks(np.arange(0, 151, 30))
ax.tick_params(axis='both', which='major', labelsize=11)

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[5].gridline.set_visible(False)

ax.spines.top.set_visible(False)
ax3.spines.top.set_visible(False)
ax4.spines.top.set_visible(False)

h1, l1 = ax.get_legend_handles_labels()
h3, l3 = ax3.get_legend_handles_labels()
h4, l4 = ax4.get_legend_handles_labels()
ax.legend(h1 + h3 + h4, l1 + l3 + l4, fontsize=legend_fontsize, ncol=4, loc='upper left', framealpha=1)

ax.yaxis.set_major_formatter(ticker.EngFormatter()) 
ax3.yaxis.set_major_formatter(ticker.EngFormatter())  
ax4.yaxis.set_major_formatter(ticker.EngFormatter())  

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('US Major Basins Well Counts &amp; Production')  + ",  Jan 2014 - June 2022", 
             fontsize=title_fontsize, pad=10, x=0.37, y=1.06)
ax.annotate('', xy=(-0.115, 1.07), xycoords='axes fraction', xytext=(1.2, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.145, 0.7, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax.transAxes, color='grey', alpha=0.5)

ax.axvline(x=df_drilled.index[8], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[54], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[-1], color='k', linestyle='--', linewidth=1, alpha=0.7)

t1 = ax.text(0.1, 0.25, '[1]', fontsize=10, transform=ax.transAxes, color='k', )
t2 = ax.text(0.49, 0.25, '[2]', fontsize=10, transform=ax.transAxes, color='k')
t3 = ax.text(0.94, 0.25, '[3]', fontsize=10, transform=ax.transAxes, color='k')

t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))
t2.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))
t3.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))

oil1 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][8])) + ' MBBLD'
gas1 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][8])) + ' BCFD'
drill1 = str(int(df_drilled['Total Drilled'][8])) + ' drilled'
ax.text(df_drilled.index[8 + 4], 2500, oil1, fontsize=9, color='green', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[8 + 4], 3000, gas1, fontsize=9, color='red', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[8 + 4], 2000, drill1, fontsize=9, color='k', bbox=dict(facecolor='none', edgecolor='none'))


oil2 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][54])) + ' MBBLD'
gas2 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][54])) + ' BCFD'
drill2 = str(int(df_drilled['Total Drilled'][54])) + ' drilled'
ax.text(df_drilled.index[54 + 4], 2500, oil2, fontsize=9, color='green', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[54 + 4], 3000, gas2, fontsize=9, color='red', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[54 + 4], 2000, drill2, fontsize=9, color='k', bbox=dict(facecolor='none', edgecolor='none'))

ha = 'right'
oil3 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][-1])) + ' MBBLD'
gas3 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][-1])) + ' BCFD'
drill3 = str(int(df_drilled['Total Drilled'][-1])) + ' drilled'
ax.text(df_drilled.index[-1 - 4], 2500, oil3, fontsize=9, color='green', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[-1 - 4], 3000, gas3, fontsize=9, color='red', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[-1 - 4], 2000, drill3, fontsize=9, color='k', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;The improvement in production efficiency despite the reduction in drilling can be attributed to the increasing use of horizontal wells. As compared to vertical wells, horizontal wells produce 2.5 to 7 times more, allowing the industry to meet demand with fewer drilling operations. As illustrated in &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt;, during economic downturns, the industry has favored horizontal wells by significantly reducing the number of vertical wells. It demonstrates a steady decrease in vertical wells, indicating that the majority of modern day drilling operations now consist of 91% horizontal wells and only 9% vertical wells.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-7" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Monthly Historical Drill Type Count 2004.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 7: Historically the US oil and gas industry has turned into horizontal drilling during the times of economic crisis. Modern day drilling is mostly horizontal wells, which explains the higher production rates despite low drilling activities compared to 2014.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (7)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.ticker as ticker
import warnings

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################# Drilled Wells Count per Basin ###################################

# import multiple csv files of basins and compile them into yearly count sum
# source: DrillingInfo

filename = 'https://aegis4048.github.io/downloads/notebooks/sample_data/Drill_Type_2004.xlsx'

# suppress warnings
warnings.filterwarnings('ignore')
warnings.simplefilter('ignore')

dfs = []
for basin in basins:
    df = pd.read_excel(filename, sheet_name=basin)
    df = df[df['Spud Date'].notna()]
    df['Basin'] = basin
    df['Year'] = df['Spud Date'].apply(lambda x: str(x).split('-')[0])
    dfs.append(df)

df_drilltype = pd.concat(dfs)
df_drilltype = df_drilltype.sort_values('Spud Date')
df_drilltype.index = pd.to_datetime(df_drilltype['Spud Date'])

df_drilltype = df_drilltype.groupby(pd.Grouper(freq='M'))['Drill Type'].value_counts(sort=True)
df_drilltype = df_drilltype.unstack().fillna(0).drop(['D', 'U'], axis=1)

df_drilltype_percent = df_drilltype.apply(lambda x: round(x / x.sum() * 100, 2), axis=1)
df_drilltype_percent = round(df_drilltype_percent, 1)

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4))

x = df_drilltype.index
y = np.array([df_drilltype['H'].values, df_drilltype['V'].values])

ax.stackplot(x, *y, labels=['Horizontal', 'Vertical'], colors=['lightgrey', 'grey'])
ax.set_ylabel('Drilled Wells', fontsize=13)
ax.axvline(x=df_drilltype.index[-93], color='k', linestyle='--')
ax.axvline(x=df_drilltype.index[-28], color='k', linestyle='--')
ax.axvline(x=df_drilltype.index[-166], color='k', linestyle='--')

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[6].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

ax.legend(fontsize=11, ncol=3, loc='upper right')
ax.tick_params(axis='both', which='major', labelsize=11)

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Newly Drilled Wells Horizontal vs. Vertical Counts Trend')  + ",  Jan 2004 - June 2022", fontsize=12, pad=10, x=0.41, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='white', alpha=0.5)
ax.text(0.705, 0.63, '2014 Oil Price Crash', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.91, 0.55, 'Covid-19', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.375, 0.75, '2008 Recession', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()


#################################################################################################

fig, ax = plt.subplots(figsize=(8, 4))

ax.plot(df_drilltype_percent.index, df_drilltype_percent['H'], color='grey', label='Horizontal')
ax.plot(df_drilltype_percent.index, df_drilltype_percent['V'], color='k', label='Vertical')
ax.set_ylabel('Percent of Total', fontsize=13)
ax.tick_params(axis='both', which='major', labelsize=11)
ax.set_yticks(np.arange(0, 101, 10))

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[10].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

ax.legend(fontsize=11, loc='center left')

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Newly Drilled Wells Horizontal vs. Vertical Ratio Trend')  + ",  Jan 2004 - June 2022", fontsize=12, pad=10, x=0.41, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='grey', alpha=0.5)
ax.text(0.8, 0.43, '91% Horizontal', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.8, 0.34, '9% Vertical', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.8, 0.53, 'June 2022:', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Continued discussion: Dead DUC wells"&gt;&lt;/div&gt;&lt;h2 id='4.-Continued-discussion:-"Dead"-DUC-wells'&gt;4. Continued discussion: "Dead" DUC wells&lt;a class="anchor-link" href='#4.-Continued-discussion:-"Dead"-DUC-wells'&gt;Â¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The empirical evidence shows that 95% of the wells in the US are completed within 2 years after drilling. Failing to drill within that time may give birth to what we call the "Dead" DUCs - the wells that will never be completed. The speculations as to why those old DUCs are never completed include lost leases and reservoir pressure depletion. However, the study I conducted shows intriguing characteristics that contradict the conventional wisdom that the gap time between drilling and completion has negative impact on EUR and production rates. In fact, longer gap time seems to positively affect production rates for DUC wells under 250~400 days old since drilled as shown in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Check out my next article &lt;a href="https://aegis4048.github.io/how_do_old_duc_wells_become_dead_ducs" target="_blank"&gt;How Do Old DUC Wells Become DEAD DUCs?&lt;/a&gt; for more information.&lt;/p&gt;
&lt;div class="row" id="fig-8" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Total EUR vs Days Till Completion Zoomed In.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 8: Each dot represents one well's EUR in the basin. The wells are binned by 50 lag days. Each vertical band of dots represents wells completed, for example, between 100 ~ 200 days after drilled. The blue line plot represents the average of wells in each 50-day bins. Note that the credibility of this average line plot falls with the increasing lag days due to lack of data on high-lag-day-bins.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: 'center'," +
        "    displayIndent: '0em'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['$','$'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
        "    } " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="oil-and-gas"></category><category term="oil"></category><category term="gas"></category><category term="DUC"></category><category term="drilling"></category><category term="horizontals"></category><category term="verticals"></category><category term="completion"></category><category term="production"></category><category term="recent-trend"></category><category term="energy-shortage"></category><category term="EIA"></category><category term="DrillingInfo"></category><category term="Enverus"></category><category term="DPR"></category></entry></feed>