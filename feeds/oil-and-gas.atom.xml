<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pythonic Excursions - Oil and Gas</title><link href="https://aegis4048.github.io/" rel="alternate"></link><link href="https://aegis4048.github.io/feeds/oil-and-gas.atom.xml" rel="self"></link><id>https://aegis4048.github.io/</id><updated>2023-03-03T00:00:00-08:00</updated><subtitle>Stories about Python and Data Science</subtitle><entry><title>Quantifying The Impact Of Completion Delay Since Drilled On Production</title><link href="https://aegis4048.github.io/quantifying_the_impact_of_completion_delay_since_drilled_on_production" rel="alternate"></link><published>2023-03-03T00:00:00-08:00</published><updated>2023-03-03T00:00:00-08:00</updated><author><name>ERIC KIM</name></author><id>tag:aegis4048.github.io,2023-03-03:/quantifying_the_impact_of_completion_delay_since_drilled_on_production</id><summary type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color …&lt;/style&gt;</summary><content type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color: #B22B31;
}
.ansi-red-intense-bg {
  background-color: #B22B31;
}
.ansi-green-fg {
  color: #00A250;
}
.ansi-green-bg {
  background-color: #00A250;
}
.ansi-green-intense-fg {
  color: #007427;
}
.ansi-green-intense-bg {
  background-color: #007427;
}
.ansi-yellow-fg {
  color: #DDB62B;
}
.ansi-yellow-bg {
  background-color: #DDB62B;
}
.ansi-yellow-intense-fg {
  color: #B27D12;
}
.ansi-yellow-intense-bg {
  background-color: #B27D12;
}
.ansi-blue-fg {
  color: #208FFB;
}
.ansi-blue-bg {
  background-color: #208FFB;
}
.ansi-blue-intense-fg {
  color: #0065CA;
}
.ansi-blue-intense-bg {
  background-color: #0065CA;
}
.ansi-magenta-fg {
  color: #D160C4;
}
.ansi-magenta-bg {
  background-color: #D160C4;
}
.ansi-magenta-intense-fg {
  color: #A03196;
}
.ansi-magenta-intense-bg {
  background-color: #A03196;
}
.ansi-cyan-fg {
  color: #60C6C8;
}
.ansi-cyan-bg {
  background-color: #60C6C8;
}
.ansi-cyan-intense-fg {
  color: #258F8F;
}
.ansi-cyan-intense-bg {
  background-color: #258F8F;
}
.ansi-white-fg {
  color: #C5C1B4;
}
.ansi-white-bg {
  background-color: #C5C1B4;
}
.ansi-white-intense-fg {
  color: #A1A6B2;
}
.ansi-white-intense-bg {
  background-color: #A1A6B2;
}
.ansi-default-inverse-fg {
  color: #FFFFFF;
}
.ansi-default-inverse-bg {
  background-color: #000000;
}
.ansi-bold {
  font-weight: bold;
}
.ansi-underline {
  text-decoration: underline;
}
/* The following styles are deprecated an will be removed in a future version */
.ansibold {
  font-weight: bold;
}
.ansi-inverse {
  outline: 0.5px dotted;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  position: relative;
  overflow: visible;
}
div.cell:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: transparent;
}
div.cell.jupyter-soft-selected {
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected,
div.cell.selected.jupyter-soft-selected {
  border-color: #ababab;
}
div.cell.selected:before,
div.cell.selected.jupyter-soft-selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #42A5F5;
}
@media print {
  div.cell.selected,
  div.cell.selected.jupyter-soft-selected {
    border-color: transparent;
  }
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
}
.edit_mode div.cell.selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #66BB6A;
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell &gt; div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area &gt; div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area &gt; div.highlight &gt; pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the &lt;head&gt; if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  /* Note that this should set vertical padding only, since CodeMirror assumes
       that horizontal padding will be set on CodeMirror pre */
  padding: 0.4em 0;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only,
    use .CodeMirror-lines for vertical */
  padding: 0 0.4em;
  border: 0;
  border-radius: 0;
}
.CodeMirror-cursor {
  border-left: 1.4px solid black;
}
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .CodeMirror-cursor {
    border-left: 2px solid black;
  }
}
@media screen and (min-width: 4320px) {
  .CodeMirror-cursor {
    border-left: 4px solid black;
  }
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev &lt;Maniac@SoftwareManiacs.Org&gt;
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area 
div.output_area 
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
div.output_area .mglyph &gt; img {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 1px 0 1px 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}



.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}






.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul:not(.list-inline),
.rendered_html ol:not(.list-inline) {
  padding-left: 2em;
}








.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}





.rendered_html pre,




.rendered_html tr,
.rendered_html th,


.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
.rendered_html * + table {
  margin-top: 1em;
}

.rendered_html * + p {
  margin-top: 1em;
}

.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,

.rendered_html img.unconfined,


.rendered_html * + .alert {
  margin-top: 1em;
}
[dir="rtl"] 
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell &gt; div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered 
.text_cell.rendered .rendered_html tr,
.text_cell.rendered .rendered_html th,
.text_cell.rendered 
.text_cell.unrendered .text_cell_render {
  display: none;
}
.text_cell .dropzone .input_area {
  border: 2px dashed #bababa;
  margin: -1px;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
&lt;/style&gt;
&lt;style type="text/css"&gt;pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */&lt;/style&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Once a well is drilled, it must be completed to produce oil and gas. However, operators sometimes delay completing a well for various reasons, such as waiting for fracking crews or facing budget constraints. These delayed wells, known as &lt;strong&gt;Drilled but Uncompleted (DUC)&lt;/strong&gt; wells, are considered to be a working oil field capital because the wells can be turned on line for production for cheap. However, the empirical evidences suggests that the DUC wells may no longer function as a working capital if completion is delayed for too long. The probability of completion falls drastically after two years of delay in completion, and DUC wells that still remain un-completed beyond this time frame are likely to be never completed.&lt;/p&gt;
&lt;p&gt;The study conducted in this article is built on top of the previous scientific findings which claim that the nearby parent wells can have a negative impact on the production of child wells, which worsens the longer the parent wells have been producing. This is particularly critical for DUC wells, as the wells awaiting completion are already exposed to these pressure variations from existing wells that continue to produce and deplete. This study aims to quantify the impact of increasing delays in completion on production by observing changes in estimated ultimate recovery (EUR) normalized by lateral length and completion concentration per perforated foot as a function of DUC time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="toc_container"&gt;
&lt;p class="toc_title"&gt;Contents&lt;/p&gt;
&lt;ul class="toc_list"&gt;
&lt;li&gt;&lt;a href="#Sample data description"&gt;&lt;span class="toc_label"&gt;0&lt;/span&gt;Sample data description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Key takeaways"&gt;&lt;span class="toc_label"&gt;1&lt;/span&gt;Key takeaways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Quick overview on DUC wells"&gt;&lt;span class="toc_label"&gt;2&lt;/span&gt;Quick overview on DUC wells&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Reservoir depletion due to existing offset wells"&gt;&lt;span class="toc_label"&gt;3&lt;/span&gt;Reservoir depletion due to existing offset wells&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Quantifying the impact of DUC time on EUR"&gt;&lt;span class="toc_label"&gt;4&lt;/span&gt;Quantifying the impact of DUC time on EUR&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Preliminary data cleaning"&gt;&lt;span class="toc_label"&gt;4.1&lt;/span&gt;Preliminary data cleaning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Raw EUR vs. DUC time"&gt;&lt;span class="toc_label"&gt;4.2&lt;/span&gt;Raw EUR vs. DUC time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Factors that affect EUR: Completion size and lateral length"&gt;&lt;span class="toc_label"&gt;4.3&lt;/span&gt;Factors that affect EUR: Completion size and lateral length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Normalized EUR vs. DUC time"&gt;&lt;span class="toc_label"&gt;4.4&lt;/span&gt;Normalized EUR vs. DUC time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;&lt;a href="#Dead DUC wells"&gt;&lt;span class="toc_label"&gt;5&lt;/span&gt;"Dead" DUC wells&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Conclusion"&gt;&lt;span class="toc_label"&gt;6&lt;/span&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Sample data description"&gt;&lt;/div&gt;&lt;h2 id="0.-Sample-data-description"&gt;0. Sample data description&lt;a class="anchor-link" href="#0.-Sample-data-description"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The main data source used for this article is the &lt;a href="https://www.enverus.com/" target="_blank"&gt;Enverus&lt;/a&gt; Drilling Info application. Within Drilling Info's data base, I selected wells in the seven major basins in the US, defined by the US Energy Information Adminitration's (EIA) &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;Drilling Productivity Report&lt;/a&gt; (DPR): Anadarko, Appalachia, Bakken, Eagle Ford, Haynesville, Niobrara, and Permian.&lt;/p&gt;
&lt;div class="row full_screen_margin_80 mobile_responsive_plot_full_width" id="fig-1" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DPR-basins.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 1: 7 major basins in the US, Source: EIA&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;The DPR provides which county and state they used to define each major basins. For your convenience, I compiled a text file (&lt;a href="https://aegis4048.github.io/downloads/notebooks/sample_data/Basins_Boundaries.txt" target="_blank"&gt;Basins_Boundaries.txt&lt;/a&gt;) that has the list of state and counties that can be easily pasted into Drilling Info's filter tab. Unfortunately Enverus Drilling Info is a commerical software and not everyone will be able to use it.&lt;/p&gt;
&lt;div class="row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-2" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/drilling_info_paste.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 2: Pasting the Eagle Ford basin's state and county data into Drilling Info for query&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="pandas table"&gt;&lt;/div&gt;&lt;p&gt;Pulling all active wells in the specified counties and states gives this &lt;a class="ico xls" href="https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx" target="_blank"&gt;Excel file&lt;/a&gt; &lt;strong&gt;(EUR_vs_Lag.xlsx).&lt;/strong&gt; The file has 7 tabs for each basin. The below code output shows small portion of the Anadarko wells data. Each row represents a record of one well.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [3]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pd&lt;/span&gt;

&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_excel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sheet_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Anadarko'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;
&lt;div class="output_area"&gt;
&lt;div class="prompt output_prompt"&gt;Out[3]:&lt;/div&gt;
&lt;div class="output_html rendered_html output_subarea output_execute_result"&gt;
&lt;div&gt;
&lt;style scoped=""&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border="1" class="dataframe"&gt;
&lt;thead&gt;
&lt;tr style="text-align: right;"&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Spud Date&lt;/th&gt;
&lt;th&gt;Completion Date&lt;/th&gt;
&lt;th&gt;Drill Type&lt;/th&gt;
&lt;th&gt;Lag&lt;/th&gt;
&lt;th&gt;EUR Oil (Full)&lt;/th&gt;
&lt;th&gt;EUR Gas (Full)&lt;/th&gt;
&lt;th&gt;EUR (Full) BOE&lt;/th&gt;
&lt;th&gt;First 12 BOE&lt;/th&gt;
&lt;th&gt;Production Type&lt;/th&gt;
&lt;th&gt;DI Lateral Length&lt;/th&gt;
&lt;th&gt;Total Proppant (First Treatment Job)&lt;/th&gt;
&lt;th&gt;Total Fluid (First Treatment Job)&lt;/th&gt;
&lt;th&gt;Proppant per Perforated Foot (First Treatment Job)&lt;/th&gt;
&lt;th&gt;Fluid per Perforated Foot (First Treatment Job)&lt;/th&gt;
&lt;th&gt;Proppant Concentration (lbs/gal) (First Treatment Job)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;2020-01-09&lt;/td&gt;
&lt;td&gt;2021-04-09&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;456.0&lt;/td&gt;
&lt;td&gt;672317.75&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;td&gt;672317.750000&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;OIL&lt;/td&gt;
&lt;td&gt;10776.0&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;2019-05-03&lt;/td&gt;
&lt;td&gt;2019-07-26&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;84.0&lt;/td&gt;
&lt;td&gt;129760.25&lt;/td&gt;
&lt;td&gt;2348886.00&lt;/td&gt;
&lt;td&gt;521241.250000&lt;/td&gt;
&lt;td&gt;141195.17&lt;/td&gt;
&lt;td&gt;GAS&lt;/td&gt;
&lt;td&gt;5739.0&lt;/td&gt;
&lt;td&gt;6137496.0&lt;/td&gt;
&lt;td&gt;170614.00&lt;/td&gt;
&lt;td&gt;1069.4365&lt;/td&gt;
&lt;td&gt;29.73&lt;/td&gt;
&lt;td&gt;0.86&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;2018-06-20&lt;/td&gt;
&lt;td&gt;2018-07-28&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;89633.48&lt;/td&gt;
&lt;td&gt;472189.47&lt;/td&gt;
&lt;td&gt;168331.725000&lt;/td&gt;
&lt;td&gt;61155.83&lt;/td&gt;
&lt;td&gt;GAS&lt;/td&gt;
&lt;td&gt;4338.0&lt;/td&gt;
&lt;td&gt;4304900.0&lt;/td&gt;
&lt;td&gt;100874.00&lt;/td&gt;
&lt;td&gt;992.3698&lt;/td&gt;
&lt;td&gt;23.25&lt;/td&gt;
&lt;td&gt;1.02&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;2018-05-21&lt;/td&gt;
&lt;td&gt;2018-07-07&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;47.0&lt;/td&gt;
&lt;td&gt;158308.72&lt;/td&gt;
&lt;td&gt;2718710.75&lt;/td&gt;
&lt;td&gt;611427.178333&lt;/td&gt;
&lt;td&gt;222754.17&lt;/td&gt;
&lt;td&gt;GAS&lt;/td&gt;
&lt;td&gt;4859.0&lt;/td&gt;
&lt;td&gt;5627071.0&lt;/td&gt;
&lt;td&gt;194148.98&lt;/td&gt;
&lt;td&gt;1158.0718&lt;/td&gt;
&lt;td&gt;39.96&lt;/td&gt;
&lt;td&gt;0.69&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;2018-04-09&lt;/td&gt;
&lt;td&gt;2018-07-06&lt;/td&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;88.0&lt;/td&gt;
&lt;td&gt;153994.27&lt;/td&gt;
&lt;td&gt;3887145.75&lt;/td&gt;
&lt;td&gt;801851.895000&lt;/td&gt;
&lt;td&gt;268463.00&lt;/td&gt;
&lt;td&gt;GAS&lt;/td&gt;
&lt;td&gt;4845.0&lt;/td&gt;
&lt;td&gt;8990772.0&lt;/td&gt;
&lt;td&gt;292805.38&lt;/td&gt;
&lt;td&gt;1855.6805&lt;/td&gt;
&lt;td&gt;60.43&lt;/td&gt;
&lt;td&gt;0.73&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Key takeaways"&gt;&lt;/div&gt;&lt;h2 id="1.-Key-takeaways"&gt;1. Key takeaways&lt;a class="anchor-link" href="#1.-Key-takeaways"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;div class="highlights" id="key1"&gt;
&lt;div class="highlights-title"&gt;1. Characteristics of DUC wells&lt;/div&gt;
&lt;div class="highlights-content"&gt;DUC wells can be turned on line for cheap since the cost of drilling have been paid. This allows them to function as a secondary form of hydrocarbon storage under the ground, instead of traditional above-ground facilities.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key2"&gt;
&lt;div class="highlights-title"&gt;2. Delaying completion during times of low oil prices in the hope of a future recovery may not be a financially wise decision&lt;/div&gt;
&lt;div class="highlights-content"&gt;This is because nearby wells can induce reservoir depletion, which can significantly reduce the potential yield. Operators should carefully consider the long-term financial implications of delaying completion and weigh them against the potential benefits of waiting for better market conditions.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key3"&gt;
&lt;div class="highlights-title"&gt;3. Scientific wisdom states that the greater difference in completion timing among adjacent wells worsens child well's production&lt;/div&gt;
&lt;div class="highlights-content"&gt;The prolonged production from nearby parent wells can lead to reservoir depletion and pressure sinks, which can affect the productivity of the child well. This issue is particularly important for DUC wells because as existing wells continue to produce and deplete, the wells awaiting completion are already exposed to these pressure variations, which can worsen if completion is further delayed &lt;a href="https://onepetro.org/REE/article-abstract/22/01/190/206725/Concerns-and-Clarifications-for-Drilled" target="_blank"&gt;(Srinivasan et al. 2018)&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key4"&gt;
&lt;div class="highlights-title"&gt;4. Contrary to the scientific wisdom, wells completed shortly after drilling tend to have smaller EUR compared to wells with longer DUC time&lt;/div&gt;
&lt;div class="highlights-content"&gt;This is due to the fact that younger DUC wells tend to have shorter lateral length and treated with smaller completion concentration for each lateral foot. This means that the operators tend to undersize completion design for their younger DUC wells, resulting in sub-optimal EUR.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key5"&gt;
&lt;div class="highlights-title"&gt;5. To discern the genuine influence of DUC time on production, EUR is normalized by lateral length, proppant per perforated foot, and fluid per perforated foot&lt;/div&gt;
&lt;div class="highlights-content"&gt;This decision is made after visually confirming positive correlation between EUR vs. lateral length and completion size in &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key6"&gt;
&lt;div class="highlights-title"&gt;6. Anadarko and Permian basins showed the worst reduction in normalized EUR in the shortest time span between drilling and completion&lt;/div&gt;
&lt;div class="highlights-content"&gt;Normalized EUR dropped by 81% and 74%, respectively, for Anadarko and Permian basins over a span of 150 days of additional delay in completion (&lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;), followed by the Haynesville basin which showed 46% decrease in normalized EUR over a span of additional 100 days of delay in completion.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key7"&gt;
&lt;div class="highlights-title"&gt;7. Appalachia, Eagle Ford and Niobrara basins showed minimal loss in normalized EUR with increasing DUC time&lt;/div&gt;
&lt;div class="highlights-content"&gt;Appalachia experienced only 19% reduction in normalized EUR with 350 days of delay in completion, and Eagle Ford and Niobrara basins showed negligible change in normalized EUR with increasing DUC time. This finding shows that wells in these basins are the least likely to suffer from well-to-well interference problems with increasing DUC time compared to the other basins.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key8"&gt;
&lt;div class="highlights-title"&gt;8. DUC wells have time limit till completion. &lt;/div&gt;
&lt;div class="highlights-content"&gt;The probability of completion falls drastically after a certain time limit due to the degrading economics associated with delays in completion. For example in &lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt;, the completion time limits for Anadarko and Hanyesville are 308 days and 409 days after drilled, respectively. Beyond these limits, the probability of completion in these basins drops below 5%. This study demonstrates a positive correlation between the extent of these time limits and changes in both normalized EUR and absolute EUR as DUC time increases.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Quick overview on DUC wells"&gt;&lt;/div&gt;&lt;h2 id="2.-Quick-overview-on-DUC-wells"&gt;2. Quick overview on DUC wells&lt;a class="anchor-link" href="#2.-Quick-overview-on-DUC-wells"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Once a well is drilled, it must be completed to produce oil and gas. However, operators sometimes delay completing a well for various reasons, such as waiting for fracking crews or facing budget constraints. These delayed wells, known as &lt;strong&gt;Drilled but Uncompleted (DUC)&lt;/strong&gt; wells, accumulate when drilling outpaces completion and decrease when the opposite occurs. &lt;a href="#fig-3"&gt;Figure 3&lt;/a&gt; illustrates the historical trend of DUC inventories in the seven major US basins, as defined by the &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;EIA's DPR&lt;/a&gt; page. &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt; provides more detailed information on each basin, including hydrocarbon production volumes and drilling activities.&lt;/p&gt;
&lt;p&gt;DUC wells have unique features that make them an attractive option for low-cost production. The wells can be turned on line for production for cheap; the costs of drilling have been paid, and completion won't be as costly as new drilling. They can function as a secondary form of hydrocarbon storage underground, unlike traditional above-ground facilities. In times of low oil prices, operators may choose to complete them later, hoping that the oil price would recover in a near future. Throughout the rest of the article, however, I show why this may not be a smart idea for some basins (especially Anadarko and Permian) due to reservoir depletion induced by existing producing offset wells.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-3" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/US Major Basins Completion &amp; Drilling Activities and Commodities.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 3: DUCs accumulate when drilling activity exceeds completion, and vice versa. The line plots depict three distinct periods of significant fluctuations in DUC well inventories, with [1] and [3] representing instances of rapid depletion due to high completion rates, and [2] reflecting a period of accumulation resulting from high drilling activities. WTI Crude oil prices is appended at the bottom to show the effect of commodity prices on DUCs.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (3)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4))

ax2 = ax.twinx()

ax.plot(df_drilled.index, df_drilled['Total Drilled'], color='k', label='Newly Drilled')
ax.plot(df_completed.index, df_completed['Total Completed'], label='Completed')
ax2.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')


ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2016-03-1') &amp; (df_drilled.index &lt;= '2017-1-1'), color='red', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2018-08-01') &amp; (df_drilled.index &lt;= '2019-3-1'), color='green', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2020-07-1') &amp; (df_drilled.index &lt;= '2022-8-1'), color='red', alpha=0.4)

ax.axvline(x=df_drilled.index[26], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[35], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[26], df_drilled.index[35], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[55], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[61], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[55], df_drilled.index[61], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[78], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[102], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[78], df_drilled.index[102], facecolor='lightgrey', alpha=0.3)

ax.set_ylim(0, 2500)
ax2.set_ylim(0, 10000)

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[5].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax2.spines.top.set_visible(False)

h1, l1 = ax.get_legend_handles_labels()
h2, l2 = ax2.get_legend_handles_labels()
ax.legend(h1 + h2, l1 + l2, fontsize=10, ncol=3, loc='upper left', framealpha=1)

ax.set_ylabel('Drilled &amp; Completed Wells', fontsize=11)
ax2.set_ylabel('DUC Wells', fontsize=11)

ax.arrow(df_drilled.index[71], 1500, 60, -270, head_width=40, head_length=60, fc='k', ec='k')
ax.text(0.58, 0.62, 'Covid Crash', fontsize=9, transform=ax.transAxes, color='k')

ax.text(0.295, 0.05, '[1]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.53, 0.05, '[2]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.805, 0.05, '[3]', fontsize=9, transform=ax.transAxes, color='k')

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('US Major Basins Completion &amp; Drilling Activities')  + ",  Jan 2014 - Dec 2022", fontsize=12, pad=10, x=0.4, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.11, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='grey', alpha=0.5)

fig.set_facecolor("white")
fig.tight_layout()

############################################# Plot 2 ##############################################

df = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EIA-commodity.xls', sheet_name='Data 1')
df = df.iloc[338:-1, :-1] # between Jan 2014 to Dec 2022
df.columns = ['date', 'value']
df.reset_index(inplace=True, drop=True)
df['date'] = df['date'].apply(lambda x: x.strftime('%Y-%m'))
df['date'] = pd.to_datetime(df['date'])

fig, ax = plt.subplots(figsize=(7, 1))

ax.plot(df['date'], df['value'], color='green')

ax.set_ylabel('oil ($)', fontsize=10)
ax.set_ylim(0, 120)
ax.set_yticks(np.linspace(0, 120, 4))
ax.tick_params(axis='both', which='major', labelsize=9)

ax.axvspan(df_drilled.index[26], df_drilled.index[35], facecolor='lightgrey', alpha=0.3)
ax.axvspan(df_drilled.index[55], df_drilled.index[61], facecolor='lightgrey', alpha=0.3)
ax.axvspan(df_drilled.index[78], df_drilled.index[103], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[26], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[35], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[55], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[61], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[78], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[103], color='k', linestyle='--', linewidth=1, alpha=0.7)

ax.grid(axis='y', alpha=0.5)
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)

ax.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -.5), xycoords='axes fraction', fontsize=9)
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="row" id="fig-4"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DUC &amp; Newly Drilled Wells and Production by Basins, Jan 2014 - Dec 2022.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 4: Quick glance at the EIA DPR data for each basin. Note that the Permian basin has different y-axis scale for DUC &amp; newly drilled wells count.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (4)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import warnings
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs_year = df.groupby([df.index.year, 'Basin'])['DUC'].mean()
df_DUCs_year = df_DUCs_year.unstack().fillna(0)
df_DUCs_year = round(df_DUCs_year, 0)

df_drilled_year = df.groupby([df.index.year, 'Basin'])['Drilled'].sum()
df_drilled_year = df_drilled_year.unstack().fillna(0)
df_drilled_year['Total Drilled'] = df_drilled_year.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod_year = df2_total_gas_prod_year.unstack().fillna(0)
df2_total_gas_prod_year['Total Gas (BCFD)'] = df2_total_gas_prod_year.T.apply(lambda x: sum(x))
df2_total_gas_prod_year = df2_total_gas_prod_year / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod_year = df2_total_oil_prod_year.unstack().fillna(0)
df2_total_oil_prod_year['Total (MMBBLD)'] = df2_total_oil_prod_year.T.apply(lambda x: sum(x))
df2_total_oil_prod_year = df2_total_oil_prod_year / 1000000

############################################# Plot ##############################################

# changing datetime index to str is necessary to overlay lineplot on top of barplot
df_drilled_year.index = [str(item) for item in df_drilled_year.index]
df2_total_gas_prod_year.index = [str(item) for item in df2_total_gas_prod_year.index]
df2_total_oil_prod_year.index = [str(item) for item in df2_total_oil_prod_year.index]

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

axis_fontsize = 15
axis_tick_fontsize = 11
title_fontsize = 18
figure_title_fontsize = 20
label_fontsize = 13
legend_fontsize = 16
markersize = 9
y_label_fontsize = 15

gas_prod_color = 'red'
oil_prod_color = 'green'
drilled_color = 'k'

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

for i, (ax, basin) in enumerate(zip(axes, basins)):

    df_DUCs_year.plot.bar(alpha=1, y=basin, ax=ax, legend=None, width=0.9, edgecolor='k', linewidth=0.1, label='DUC Count', color=barcolor_dict[basin])

    ax1 = ax.twinx()
    df_drilled_year.plot(y=basin, ax=ax1, linestyle='-', legend=None, marker='o', color=drilled_color, markersize=markersize, label='New Drilled Wells')

    ax2 = ax.twinx()
    df2_total_oil_prod_year.plot(y=basin, ax=ax2, linestyle='-', marker='o', color='green', markersize=markersize, label='Oil Prod Total', legend=None)
    ax2.set_ylim(0, 70)

    ax3 = ax.twinx()
    df2_total_gas_prod_year.plot(y=basin, ax=ax3, linestyle='-', marker='o', color='red', markersize=markersize, label='Gas Prod Total', legend=None)
    ax3.set_ylim(0, 500)

    ax.set_facecolor('#eeeeee')
    ax.set_axisbelow(True)
    ax.grid(axis='y')
    ax.set_xticklabels([str(dt).split('-')[0] for dt in df_DUCs_year.index])
    ax.tick_params(axis='x', labelrotation=45, labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax1.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.set_title(basin, fontsize=title_fontsize)

    if i % 2 == 0 and i != 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
        ax2.set_yticks([])
        ax3.set_yticks([])        
    else:
        ax1.set_ylabel('Drilled Wells Count (k)', fontsize=axis_fontsize)

        ax2.tick_params(axis='y', colors='green')
        ax2.spines['right'].set_position(('outward', 50))
        ax2.spines['right'].set_color('green')
        ax2.set_ylabel('Total Oil Prod. (MMBBLD)', color='green', fontsize= axis_fontsize)

        ax3.tick_params(axis='y', colors='red')
        ax3.spines['right'].set_position(('outward', 100))
        ax3.spines['right'].set_color('red')
        ax3.set_ylabel('Total Gas Prod. (BCFD)', color='red', fontsize= axis_fontsize) 

    if i == 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
    #else:
        #ax1.set_yticks([])
        #ax2.set_yticks([])
        #ax3.set_yticks([])

    if i == 4 or i == 6:
        ax.set_xlabel('Spud Date', fontsize=y_label_fontsize)
    else:
        ax.set_xlabel('')

    if basin == 'Permian':
        pass
        ax.set_ylim(0, 5000)
        ax1.set_ylim(0, 15000)

    else:
        ax.set_ylim(0, 1400)
        ax1.set_ylim(0, 7000)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax1.yaxis.set_major_formatter(ticker.EngFormatter())        

    ax.spines.top.set_visible(False)
    ax1.spines.top.set_visible(False)
    ax2.spines.top.set_visible(False)
    ax3.spines.top.set_visible(False)

    #ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    #ax1.yaxis.get_major_ticks()[-1].gridline.set_visible(False)

    h0, l0 = ax.get_legend_handles_labels()
    h1, l1 = ax1.get_legend_handles_labels()
    h2, l2 = ax2.get_legend_handles_labels()
    h3, l3 = ax3.get_legend_handles_labels()
    ax.legend(h0, l0, loc='upper left', ncol=2, fontsize=13, framealpha=0.5)

    fig.legend(h3 + h2 + h1, l3 + l2 + l1, loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.165), bbox_transform=fig.transFigure, fontsize=legend_fontsize)

    for c in ax.containers:
        ax.bar_label(c, label_type='center', color='white', weight='bold', fontsize=label_fontsize)

    ax.text(0.16, 0.80, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)        

fig.tight_layout()

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('DUC &amp; Newly Drilled Wells Count and Production')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.328, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(0.05, 0.145), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Reservoir depletion due to existing offset wells"&gt;&lt;/div&gt;&lt;h2 id="3.-Reservoir-depletion-due-to-existing-offset-wells"&gt;3. Reservoir depletion due to existing offset wells&lt;a class="anchor-link" href="#3.-Reservoir-depletion-due-to-existing-offset-wells"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Rarely the operators get a chance to drill a well in a virgin reservoir condition, especially in the Permian basin. Most times it's infill drilling among pre-existing wells that have been on production for some time, potentially inducing reservoir depletion problems when chained with unoptimized fracture design and well spacing.&lt;/p&gt;
&lt;p&gt;Well-to-well interference is known to have negative impact on production for both parent (old) and child (new) wells. The prolonged production from a parent well induces reservoir depletion and creates pressure sinks (area of lower pressure). A child well's hydraulic fractures are more prone to grow towards the pressure sink, causing fracture hits. &lt;a href="https://onepetro.org/URTECONF/proceedings-abstract/17URTC/All-17URTC/URTEC-2690466-MS/156487/" target="_blank"&gt;Ajisafe et al. (2016)&lt;/a&gt; studied 300 horizontal wells in the Avalon Shale of the Delaware basin and found that child wells were almost 30% less productive than parent wells. To mitigate the effects of frac hits, they simulated 1,320-ft and 660-ft lateral spacing and found that child wells with 1,320-ft spacing saw only a 5% reduction in cumulative production over five years compared to parent wells, while 660-ft spacing saw a 24% reduction.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://onepetro.org/REE/article-abstract/22/01/190/206725/Concerns-and-Clarifications-for-Drilled" target="_blank"&gt;Srinivasan et al. (2018)&lt;/a&gt; conducted study on the Williston basin, and discovered that &lt;i&gt;"the longer the difference in timing between completions in areas of high reservoir quality, the more pronounced the impacts of pressure depletion will be on new adjacent completions."&lt;/i&gt; It has particular significance for DUC wells because, as existing wells continue to produce and deplete, wells waiting on completion are already experiencing these variations around them, which will worsen as completion is delayed further.&lt;/p&gt;
&lt;p&gt;While the impact of a parent well on a child well is a convoluted function of fracture design, well spacing, DUC time, and many other factors, this article focuses on the effect of DUC time (gap between drilling and completion) on EUR to show why it may not be wise to delay completion for wells in certain basins (especailly Anadarko and Permian).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Quantifying the impact of DUC time on EUR"&gt;&lt;/div&gt;&lt;h2 id="4.-Quantifying-the-impact-of-DUC-time-on-EUR"&gt;4. Quantifying the impact of DUC time on EUR&lt;a class="anchor-link" href="#4.-Quantifying-the-impact-of-DUC-time-on-EUR"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;blockquote class="quote" style="font-family: unset; font-size: unset; font-style: unset; padding-bottom: 12px"&gt;
&lt;div class="terminology" style="margin-top: 2px"&gt;&lt;strong&gt;DUC time:&lt;/strong&gt; Gap in time between drilling and completion of a well (days).&lt;/div&gt;
&lt;div class="terminology"&gt;&lt;strong&gt;PPF:&lt;/strong&gt; Proppant per Perforated Foot (lbs/ft).&lt;/div&gt;
&lt;div class="terminology"&gt;&lt;strong&gt;FPF:&lt;/strong&gt; Fluid per Perforated Foot (gal/ft).&lt;/div&gt;
&lt;div class="terminology"&gt;&lt;strong&gt;Completion size:&lt;/strong&gt; Total volume of proppant and fracturing fluid.&lt;/div&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Data Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The primary data source used in this study is Enverus' Drilling Info application (refer to &lt;a href="#pandas table"&gt;above&lt;/a&gt; for quick peek at the sample data). The data was filtered to include only horizontal wells (column: &lt;em&gt;Drill Type&lt;/em&gt;) and producing wells (column: &lt;em&gt;Production Type&lt;/em&gt;), while excluding injection wells, dry holes, cores, etc. DUC time (column: &lt;em&gt;Lag&lt;/em&gt;) is calculated by the difference between spud date and completion date. Since Drilling Info does not provide finished drilling date, spud date was assumed to be equivalent to drilled date. Modern day drilling typically takes less than 20 days.&lt;/p&gt;
&lt;p&gt;The EUR (column: &lt;em&gt;EUR (Full) BOE&lt;/em&gt;) is expressed in Barrels of Oil Equivalent (BOE). The oil and gas EURs are regularly calculated and updated by Enverus. Although these auto-fitted EURs may not be completely accurate when examined on a well-by-well basis, they provide valuable insights for basin-scale analysis. The gas EUR is converted from MCFD to BOE using a conversion factor of 6 before being combined with the oil EUR.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Methodology&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Literature review suggests that the volume of hydrocarbons lost to parent wells from child wells increases with longer DUC times. However, visualizing the raw EUR vs. DUC time contradicts this proved scientific wisdom, as shown in &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt;, due to the factors that have inconsistent effects on production at different DUC times. The presented study below attempts to separate the sole effects of DUC time on reservoir depletion by normalizing EUR by lateral length and completion size.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Preliminary data cleaning"&gt;&lt;/div&gt;&lt;h3 id="4.1.-Preliminary-data-cleaning"&gt;4.1. Preliminary data cleaning&lt;a class="anchor-link" href="#4.1.-Preliminary-data-cleaning"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;It is of common phenomenon that real life data has unwanted extreme data points or outliers that skew the derived statistics. This study filters those unwanted data based on percentile method; data points bigger or smaller than 97.5% or 2.5% are removed for lateral length, PPF, and FPF. In case of EUR, data points bigger than 95% percentile are filtered out. &lt;a href="#fig-5"&gt;Figure 5&lt;/a&gt; illustrates the result of outlier removal process for Anadarko and Haynesville for EUR and PPF. Though not shown in the below figure, the outlier removal process is applied for all data types of interest (EUR, lateral, PPF, and FPF) for all seven DPR basins.&lt;/p&gt;
&lt;div class="row" id="fig-5" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Extreme Data Removal for EURs and PPF.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 5: Each dot represents one well. The wells are binned by 50 lag days. Each band of dots represents wells completed within the 50-day binned interval. For EUR, upper 5% are removed. For PPF (proppant per perforated foot), upper and lower 2.5% are removed.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (5)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker
from scipy import stats

############################################# Basins ##############################################

basins = ['Anadarko', 'Haynesville', 'Anadarko', 'Haynesville']

################################### DUC Wells Count per Basin #####################################

EURs = ['EUR (Full) BOE', 'EUR Oil (Full)', 'EUR Gas (Full)']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                 # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])]

    df_cur = df_cur.dropna(subset=EURs)
    df_cur[EURs] = df_cur[EURs].div(1000).round(0)
    dfs.append(df_cur)

############################################# Plot ##############################################

fig = plt.figure(figsize=(16, 9))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0:2, 0:2])
ax2 = plt.subplot(gs[0:2, 2:])
ax3 = plt.subplot(gs[2:, 0:2])
ax4 = plt.subplot(gs[2:, 2:])
axes = [ax1,ax2,ax3,ax4]

axis_tick_fontsize = 15
title_fontsize = 19
markersize = 20
y_label_fontsize = 18
legend_annot_fontsize = 18

colors = ['grey', '#c6b4ee', 'grey', '#c6b4ee']
columns = ['EUR (Full) BOE', 'EUR (Full) BOE', 
           'Proppant per Perforated Foot (First Treatment Job)', 'Proppant per Perforated Foot (First Treatment Job)']

for i, (ax, basin, column) in enumerate (zip(axes, basins, columns)):

    df = dfs[i]

    stepsize= 50
    bins = np.arange(0, 1000 + stepsize, stepsize)

    binned = []
    for b in bins[: -1]:
        _ = df[df['Lag'].between(b, b + stepsize)][column]
        binned.append(_)

    binned_outlier = []
    binned_cleaned = []

    ################################# For EURs ######################################

    if column == 'EUR (Full) BOE':

        for item in binned:
            threshold = item.quantile(0.975)
            binned_outlier.append(item[item &gt;= threshold])
            binned_cleaned.append(item[item &lt; threshold])

        if basin == 'Anadarko':
            y_max = 18000
            n_ticks = 7        
        else:
            y_max = 25000
            n_ticks = 6        

        ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)
        ax.set_title(basin, fontsize=title_fontsize)
        ax.text(0.98, 0.65, 'EURs', fontsize=20, ha='right', transform=ax.transAxes, color='k', alpha=0.5)

    ################################# For Proppants ######################################

    if column == 'Proppant per Perforated Foot (First Treatment Job)':
        for item in binned:
            threshold_upper = item.quantile(0.975) 
            threshold_lower = item.quantile(0.025)
            binned_outlier.append(item[(item &lt; threshold_lower) | (item &gt; threshold_upper)])
            binned_cleaned.append(item[(item &gt;= threshold_lower) &amp; (item &lt;= threshold_upper)])

        if basin == 'Anadarko':
            y_max = 7000
            n_ticks = 8       
        else:
            y_max = 10000
            n_ticks = 6             

        ax.set_ylabel('PPF (lbs/ft)', fontsize=y_label_fontsize)
        ax.set_xlabel('DUC Time (Days)', fontsize=y_label_fontsize + 1)
        ax.text(0.98, 0.65, 'Proppants/Ft', fontsize=20, ha='right', transform=ax.transAxes, color='k', alpha=0.5)

    ######################################################################################

    # scatter plot of cleaned data
    for j, item in enumerate(binned_cleaned):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.1, label='Original wells')

    # scatter plot of outliers
    for k, item_outlier in enumerate(binned_outlier):
        x_outlier = np.random.normal(k + 1, 0.06, size=len(item_outlier))
        ax.scatter(x_outlier, item_outlier, color='r', alpha=0.5, s=50, marker='x', label='Outliers')

    # axis range
    ymin = 0 - 0.05 * y_max
    ax.set_ylim(ymin, y_max)

    # tick settings
    ax.yaxis.set_major_locator(plt.MaxNLocator(n_ticks))
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax.xaxis.set_major_locator(plt.MaxNLocator(11))
    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    ax.set_xticklabels([int(item) for item in ax.get_xticks() * stepsize], rotation=30, fontsize=axis_tick_fontsize)

    # spines and grid
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)
    ax.grid(axis='y', alpha=0.5)
    ax.set_axisbelow(True)
    ax.set_facecolor('#eeeeee')

    # legend
    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0], h0[-1]], [l0[0], l0[-1]], fontsize=16, ncol=1, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])
    ax.text(0.19, 0.88, 'aegis4048.github.io', fontsize=16, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.993
fig.suptitle(setbold('Extreme Data Removal for EURs and PPF')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.29, y=1.04)
ax.annotate('', xy=(0.005, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.01, 0.02),
            xycoords='figure fraction', fontsize=legend_annot_fontsize)

fig.set_facecolor("white")

plt.subplots_adjust(bottom=.15)
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Raw EUR vs. DUC time"&gt;&lt;/div&gt;&lt;h3 id="4.2.-Raw-EUR-vs.-DUC-time"&gt;4.2. Raw EUR vs. DUC time&lt;a class="anchor-link" href="#4.2.-Raw-EUR-vs.-DUC-time"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;According to prevailing scientific knowledge, the duration of DUC time is expected to negatively impact production. Nevertheless, the findings displayed in &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; appear to contradict this notion. The plot depicts the raw EUR on the y-axis and the DUC time on the x-axis. The mean EURs for wells completed soon after drilling (within 50 days, first bands of dots in each basin plot) appear to be lower than those completed between 250 and 350 days after drilling. Notably, this difference is most pronounced for the Haynesville wells, as &lt;strong&gt;those completed within 300-350 days exhibit an EUR that is 328% higher than wells completed within 50 days after drilling&lt;/strong&gt;. This observation is illogical and suggests that further data analysis and investigation are required to discern the genuine influence of DUC time on EUR.&lt;/p&gt;
&lt;div class="row" id="fig-6" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/0_EUR_raw.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 6: Each dot represents one well. The wells are binned by 50 DUC days. Each band of dots represents wells completed within the 50-day binned interval. The blue line plot represents the average of wells in each 50-day bin. Note that the credibility of this average line plot falls with the increasing DUC time due to lack of data near the end of the x-axis. Index of peak is chosen by visual inspection; the point which "looks like" an inflection point is chosen, and is prone to subjectivity.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (6)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

no_NA = ['EUR (Full) BOE']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=no_NA)           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                   # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])]

    # BOE to MBOE unit conversion
    df_cur[no_NA] = df_cur[no_NA].div(1000).round(0)
    dfs.append(df_cur)

############################################# Plot ################################################

axis_tick_fontsize = 14
title_fontsize = 19
markersize = 20
y_label_fontsize = 16

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c']

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

def annotate_arrows(data_y, num, tick_spacing, ymax, x_start=1, ox=0.2, fontsize=14, flip_y=False):
    '''
    data_y = y coordinate of the datapoint of interest
    num = index of the datapoint of interest
    tick_spacing = spacing between two major ticks
    ox = offset of x
    '''

    head_padding = ymax * 0.04                 # extra space between the datapoint of interest and arrowhead
    oy = ymax * 0.15                           # offset of y
    sx = x_start + (tick_spacing / 2) * num
    sy = data_y + head_padding

    if flip_y:
        oy = -ymax * 0.15
        sy = data_y - head_padding

    ax.arrow(sx + ox, sy + oy, -ox, -oy, head_width=0.3, head_length=ymax * 0.0333, fc='k', ec='k', lw=2)
    t1 = ax.text(sx + ox, sy + oy, int(data_y), fontsize=fontsize, color='k', ha='center')
    t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

    xytext = (sx + ox, sy + oy)

    return xytext 

for i, (ax, basin) in enumerate (zip(axes, basins)):

    # select current basin data
    df = dfs[i]

     # cut off high lag bins with too few wells
    df = df[df['Lag'] &lt;= 1000]

    # binning by 50 days
    stepsize = 50
    bins = np.arange(0, 1000 + stepsize, stepsize)

    # scatter plot of binned wells
    eur_original = []
    eur_cleaned = []
    eur_outlier = []
    #cleaned_indices = []
    for b in bins[: -1]:

        eur_original_ = df[df['Lag'].between(b, b + stepsize)]['EUR (Full) BOE']

        cutoff = 0.95
        eur_cleaned_ = eur_original_[eur_original_ &lt;= eur_original_.quantile(cutoff)]
        eur_outlier_ = eur_original_[eur_original_ &gt; eur_original_.quantile(cutoff)]

        eur_cleaned.append(eur_cleaned_)
        eur_outlier.append(eur_outlier_)    

    for j, item in enumerate(eur_cleaned):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.1, label='One well data')

    for k, item_outlier in enumerate(eur_outlier):
        x_outlier = np.random.normal(k + 1, 0.06, size=len(item_outlier))
        ax.scatter(x_outlier, item_outlier, color='r', alpha=0.3, s=30, marker='x', label='Outliers')   

    # line plot of average of binned wells
    means = [np.mean(item) for item in eur_cleaned]
    ax.plot([i + 1 for i in range(len(means))], means, linestyle='-', marker='o', markersize=8, alpha=0.7,
            label='AVG. EUR, binned by 50 lag days')       

    # axis range
    #ymax = y_max[basin]
    ymax = 5000
    ymin = 0 - 0.05 * ymax
    ax.set_ylim(ymin, ymax)
    #ax.set_ylim(2500, 12000)

    # tick settings
    ax.minorticks_on()
    ax.xaxis.set_tick_params(which='minor', bottom=False)
    ax.xaxis.set_major_locator(plt.MaxNLocator(12))
    ax.yaxis.set_major_locator(plt.MaxNLocator(7))  

    ax.yaxis.set_major_locator(plt.MaxNLocator(6)) 
    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(2)) 

    ax.set_xticklabels([int(item) for item in ax.get_xticks() * stepsize], fontsize=axis_tick_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize, labelrotation=30)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    ax.yaxis.set_major_formatter(ticker.EngFormatter())

    # spines and grid
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)
    ax.grid(axis='y', alpha=0.5)
    ax.grid(axis='y', which='minor', color='grey', linestyle='--', alpha=0.2)
    ax.set_axisbelow(True)

    # texts
    ax.set_title(basin + ': ' + str(df.shape[0]) + ' wells', fontsize=title_fontsize)
    ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)
    if i == 4 or i == 6:
        ax.set_xlabel('DUC time (Days)', fontsize=y_label_fontsize)
    ax.set_facecolor('#eeeeee')
    ax.text(0.15, 0.88, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)    

    # legends
    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0]], [l0[0]], fontsize=14, ncol=2, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])

    h1, l1 = ax.get_legend_handles_labels()
    fig.legend([h1[-1]], [l1[-1]], loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.195), bbox_transform=fig.transFigure, fontsize=18) 

    fs = 15
    lw = 2
    _1 = 0
    spacing = abs(ax.get_xticks()[1] - ax.get_xticks()[2])
    if basin == 'Anadarko':
        _2 = 4
        yloc = 3000 
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

    if basin == 'Appalachia': 
        _2 = 2
        yloc = 1000 
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Bakken':
        _2 = 4
        yloc = 3000 
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Eagle Ford':
        _2 = 4
        yloc = 3000
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2))        
    if basin == 'Haynesville': 
        _2 = 6
        yloc = 4200 
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs, flip_y=False)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs, flip_y=True)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Niobrara':
        _2 = 4
        yloc = 3000
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2))  
    if basin == 'Permian':
        _2 = 6
        yloc = 3500 
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('EUR vs. Days Till Completion')  + ",  Jan 2014 - June 2022", fontsize=20, x=0.24, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.055, 0.173), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")    
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="row" id="table-1" style="margin-top: -15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_table_1.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Table 1: Summary table of Figure 6.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Factors that affect EUR: Completion size and lateral length"&gt;&lt;/div&gt;&lt;h3 id="4.3.-Factors-that-affect-EUR:-Completion-size-and-lateral-length"&gt;4.3. Factors that affect EUR: Completion size and lateral length&lt;a class="anchor-link" href="#4.3.-Factors-that-affect-EUR:-Completion-size-and-lateral-length"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The trend observed in &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; above, where EURs increase with increasing DUC time, contradicts the established scientific knowledge. However, we have found that this illogical trend is due to the use of smaller completion sizes and shorter lateral lengths for wells with shorter DUC times. Interestingly, the basins showing the greatest difference in EUR between the peak and trough in &lt;a href="#table-1"&gt;Table 1&lt;/a&gt; (Anandarko and Haynesville) are also those with the largest increase in completion size and lateral length as DUC time increases.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p style="display: inline"&gt;&lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt; illustrates the variation in EUR due to completion size and lateral length with increasing DUC time for different basins. The largest increase in EUR between two time periods ([1] and [2]) was observed in the Haynesville basin, with a difference of 2,223 MBOE (a 209% increase)(&lt;a href="#table-2"&gt;Table 2&lt;/a&gt;)&lt;/p&gt;&lt;strong style="color: #a4a4a4"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_1.png"/&gt;&lt;p style="display: inline"&gt;grey bars)&lt;/p&gt;&lt;/strong&gt;. A correlation analysis showed that this increase was positively associated with a 46% increase (2,111 ft) in lateral length (&lt;a href="#table-3"&gt;Table 3&lt;/a&gt;)&lt;strong style="color: #111111"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_2.png"/&gt;black line)&lt;/strong&gt;, 121% boost in PPF (&lt;a href="#table-4"&gt;Table 4&lt;/a&gt;)&lt;strong style="color: #9504d3"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_3.png"/&gt;&lt;p style="display: inline"&gt;purple lines)&lt;/p&gt;&lt;/strong&gt; and a 95% boost in FPF (&lt;a href="#table-5"&gt;Table 5&lt;/a&gt;)&lt;strong style="color: #287cb7"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_4.png"/&gt;&lt;p style="display: inline"&gt;blue lines)&lt;/p&gt;&lt;/strong&gt;&lt;p style="display: inline"&gt; for wells completed between 200-250 days after drilling, compared to wells completed within 50 days after drilling. Similar trends were observed for the Anadarko, Permian, and Bakken basins, although the EUR increase in the Bakken basin occurred at a much slower pace over a 500-day period.&lt;/p&gt;&lt;p&gt;Recall that PPF and FPF represent completion size normalized by lateral length (per foot). An increase in PPF and FPF implies that operators are not only increasing the total volume of proppant and fluid to fracture additional lateral length, but also increasing the completion concentration for each foot of the lateral for older DUC wells. This increase in completion size may be an effort to compensate for potential reservoir depletion issues that older DUC wells may encounter due to nearby parent wells have have already been producing for a while.&lt;/p&gt;
&lt;p&gt;Such attempt to compensate for potential reservoir depletion induced by parent wells can be best observed in the Anadarko and Hanyesville wells. An examination of &lt;a href="#table-2"&gt;Table 2&lt;/a&gt; reveals a significant 217% (Anadarko) and 209% (Haynesville) increase in EUR &lt;strong style="color: #a4a4a4"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_1.png"/&gt;grey bars)&lt;/strong&gt; when completion concentration is boosted between [1] and [2]. Anadarko observed 104% and 60% additional PPF and FPF, and Hanyesville 121% and 95% bigger PPF and FPF, respectively (&lt;a href="#table-2"&gt;Table 4&lt;/a&gt; and &lt;a href="#table-2"&gt;Table 5&lt;/a&gt;). These findings from &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt; prove the positive correlation between bigger EUR and bigger completion size.&lt;/p&gt;
&lt;p&gt;Conversely, however, the figure also suggests that the &lt;strong&gt;operators tend to undersize their completion design for wells completed shortly after drilling (within 250 days), resulting in sub-optimal EUR&lt;/strong&gt;. Put another way, wells completed shortly after drilling often receive smaller completion concentrations and yield smaller EUR, despite the fact that they have superior reservoir condition, compared to older DUC wells. As such, operators could potentially profit more from larger completion investments for wells completed shortly after drilling.&lt;/p&gt;
&lt;p&gt;In contrast, wells in the Appalachia, Eagle Ford, and Niobrara basins showed only a slight increase in completion size and lateral length with increasing DUC time, with the exception of the Niobrara basin which showed a decrease in PPF (&lt;a href="#table-4"&gt;Table 4&lt;/a&gt;)&lt;strong style="color: #9504d3"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_3.png"/&gt;purple line)&lt;/strong&gt; despite the longer lateral length. The magnitude of the difference between [1] and [2] was not as drastic as in the other basins. This finding explains why wells in these basins showed minimal difference in EUR with increasing DUC time in contrast to the Anadarko, Bakken, Haynesville, and Permian basins; because the volume of proppants and fluids used for completion and lateral length stayed relatively constant with increasing DUC time.&lt;/p&gt;
&lt;p&gt;Additionally, it is worth noting that the wells with longer lateral length tended to have longer DUC time. While this may sound obvious, taking a closer look at it reveals that it is not so. Between [1] and [2], the average difference in lateral length of wells in the Haynesville basin was 2,111 ft and the difference in time was 200 days. An experienced drilling and completion engineer would recognize that it does not take an additional 200 days to drill an extra 2,111 ft and hydraulically fracture that additional length. Modern day drilling takes under 15~25 days, and completion 3~5 days. One possible explanation for operators' tendency to delay completion for longer lateral wells is that the costs and time associated with bigger proppant and fluid volumes required to adequately fracture longer lateral sections are higher. Nevertheless, further research is needed to fully understand the economic trade-offs involved in completion timing for longer lateral wells.&lt;/p&gt;
&lt;div class="row" id="fig-7" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/7_factors_that_affect_EUR.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 7: Each data point represents an average data (lateral length, PPF and FPF) of wells completed within 50-day binned interval. Each bar represents raw EUR. Note that the credibility of the average line plots decrease with the increasing DUC time due to lack of data near the end of the x-axis (refer to &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; to visually understand how each average is calculated). [1] and [2] represent local trough and peak used for comparison in Table 2, 3, 4 and 5. Indices of [2]s are chosen by visual inspection; the point which "looks like" an inflection point is chosen, and is prone to subjectivity.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (7)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

no_NA = ['EUR (Full) BOE', 'Fluid per Perforated Foot (First Treatment Job)', 
         'DI Lateral Length', 'Proppant per Perforated Foot (First Treatment Job)']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=no_NA)           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                   # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])]

    dfs.append(df_cur)

############################################# Plot ##############################################

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c']

axis_tick_fontsize = 14
title_fontsize = 19
markersize = 20
y_label_fontsize = 16

gas_prod_color = 'red'
oil_prod_color = 'green'
drilled_color = 'k'

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

for i, (ax, basin) in enumerate(zip(axes, basins)):

    # select current basin data
    df = dfs[i]

    # cut off high lag bins with too few wells
    df = df[df['Lag'] &lt;= 1000]

    # binning by 50 days
    stepsize = 50
    bins = np.arange(0, 1000 + stepsize, stepsize)    

    # extreme data removal - 5%
    binned_cleaned_lateral = []
    binned_cleaned_ppf = []
    binned_cleaned_fpf = []
    binned_cleaned_eur = []
    for b in bins[: -1]:
        binned_lateral = df[df['Lag'].between(b, b + stepsize)]['DI Lateral Length']
        binned_ppf = df[df['Lag'].between(b, b + stepsize)]['Proppant per Perforated Foot (First Treatment Job)']
        binned_fpf = df[df['Lag'].between(b, b + stepsize)]['Fluid per Perforated Foot (First Treatment Job)']
        binned_eur = df[df['Lag'].between(b, b + stepsize)]['EUR (Full) BOE']

        # cutoff between 2.5% and 97.5%
        binned_cleaned_lateral_ = np.clip(binned_lateral, binned_lateral.quantile(0.025), binned_lateral.quantile(0.975))
        binned_cleaned_ppf_ = np.clip(binned_ppf, binned_ppf.quantile(0.025), binned_ppf.quantile(0.975))
        binned_cleaned_fpf_ = np.clip(binned_fpf, binned_fpf.quantile(0.025), binned_fpf.quantile(0.975))
        binned_cleaned_eur_ = np.clip(binned_eur, binned_eur.quantile(0.025), binned_eur.quantile(0.975))

        binned_cleaned_lateral.append(binned_cleaned_lateral_)
        binned_cleaned_ppf.append(binned_cleaned_ppf_)
        binned_cleaned_fpf.append(binned_cleaned_fpf_)
        binned_cleaned_eur.append(binned_cleaned_eur_)    

    means_lateral = [np.mean(item) for item in binned_cleaned_lateral]
    means_ppf = [np.mean(item) for item in binned_cleaned_ppf]
    means_fpf = [np.mean(item) for item in binned_cleaned_fpf]
    means_eur = [np.mean(item) / 1000 for item in binned_cleaned_eur] # BOE to MBOE

    # colors
    color_lat = 'k'
    color_ppf = 'darkviolet'
    color_fpf = '#1f77b4'

    # EUR (MBOE) - bar plot
    ax.bar([i + 1 for i in range(len(means_eur))], [item for item in means_eur], label='Avg. EUR', 
           alpha=0.3, color='k')
    ymax = 5000
    ax.set_ylim(0 - 0.025 * ymax, ymax)

    # Lateral length (ft) - line plot
    ax1 = ax.twinx()
    ax1.plot([i + 1 for i in range(len(means_lateral))], means_lateral, linestyle='--', marker='o', markersize=6, alpha=0.7,
        label='Avg. Lateral length', color=color_lat)    
    ymax = 15000
    ax1.set_ylim(0 - 0.025 * ymax, ymax)

    # PPF (lbs/ft) - line plot
    ax2 = ax.twinx()
    ax2.plot([i + 1 for i in range(len(means_ppf))], means_ppf, linestyle='--', marker='o', markersize=6, alpha=0.7,
        label='Avg. PPF', color=color_ppf)    
    ymax = 5000
    ax2.set_ylim(0 - 0.025 * ymax, ymax)

    # FPF (gal/ft) - line plot
    ax3 = ax.twinx()
    ax3.plot([i + 1 for i in range(len(means_fpf))], means_fpf, linestyle='--', marker='o', markersize=6, alpha=0.7,
        label='Avg. FPF', color=color_fpf)   
    ymax = 100
    ax3.set_ylim(0 - 0.025 * ymax, ymax)

    # 
    ax.yaxis.set_major_locator(plt.MaxNLocator(6))
    ax1.yaxis.set_major_locator(plt.MaxNLocator(6))
    ax2.yaxis.set_major_locator(plt.MaxNLocator(6))
    ax3.yaxis.set_major_locator(plt.MaxNLocator(6))
    ax.minorticks_on()
    ax.xaxis.set_tick_params(which='minor', bottom=False)
    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(3))

    ax.set_title(basin + ': ' + str(df.shape[0]) + ' wells', fontsize=title_fontsize)
    ax.set_facecolor('#eeeeee')
    ax.set_axisbelow(True)
    ax.grid(axis='y')
    ax.tick_params(axis='x', labelrotation=45, labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax1.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax2.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax3.tick_params(axis='y', labelsize=axis_tick_fontsize)

    if i % 2 == 0 and i != 6:
        ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)
        ax1.set_yticks([])
        ax2.set_yticks([])
        ax3.set_yticks([])
    else:
        ax1.tick_params(axis='y', colors=color_lat)
        #ax1.spines['right'].set_color(color_lat)
        ax1.set_ylabel('Lateral Length (ft)', color=color_lat, fontsize=y_label_fontsize)

        ax2.tick_params(axis='y', colors=color_ppf)
        ax2.spines['right'].set_position(('outward', 65))
        ax2.spines['right'].set_color(color_ppf)
        ax2.set_ylabel('PPF (lbs/ft)', color=color_ppf, fontsize=y_label_fontsize)

        ax3.tick_params(axis='y', colors=color_fpf)
        ax3.spines['right'].set_position(('outward', 120))
        ax3.spines['right'].set_color(color_fpf)
        ax3.set_ylabel('FPF (gal/ft)', color=color_fpf, fontsize=y_label_fontsize)        

    if i == 6:
        ax.set_ylabel('EUR (MBOE)', fontsize=y_label_fontsize)

    if i == 4 or i == 6:
        ax.set_xlabel('DUC Time (Days)', fontsize=y_label_fontsize)
    else:
        ax.set_xlabel('')

    ax.grid(axis='y', which='minor', color='grey', linestyle='--', alpha=0.2)

    ax.xaxis.set_major_locator(plt.MaxNLocator(12))
    ax.set_xticklabels([int(item) for item in ax.get_xticks() * stepsize], fontsize=axis_tick_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize, labelrotation=30)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax1.yaxis.set_major_formatter(ticker.EngFormatter())
    ax2.yaxis.set_major_formatter(ticker.EngFormatter())
    ax1.yaxis.set_major_formatter(ticker.EngFormatter())

    ax.spines.top.set_visible(False)
    ax1.spines.top.set_visible(False)
    ax2.spines.top.set_visible(False)

    h0, l0 = ax.get_legend_handles_labels()
    h1, l1 = ax1.get_legend_handles_labels()
    h2, l2 = ax2.get_legend_handles_labels()
    h3, l3 = ax3.get_legend_handles_labels()

    fig.legend(h0 + h1 + h2 + h3, l0 + l1 + l2 + l3, loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.18), bbox_transform=fig.transFigure, fontsize=18)

    ax.text(0.86, 0.85, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)

    _1 = 1
    if basin == 'Anadarko':
        _2 = 5
    elif basin == 'Appalachia':
        _2 = 4
    elif basin == 'Bakken':
        _2 = 10
    elif basin == 'Eagle Ford':
        _2 = 5
    elif basin == 'Haynesville':
        _2 = 5
    elif basin == 'Niobrara':
        _2 = 6
    else:
        _2 = 7

    ax.axvline(x=_1, color='k', linestyle='--', linewidth=1, alpha=0.7)
    t1 = ax.text(_1, 4000, '[1]', fontsize=14, color='k', ha='center', va='center')    
    t1.set_bbox(dict(facecolor='#eeeeee', alpha=1, edgecolor='#eeeeee', pad=1))

    ax.axvline(x=_2, color='k', linestyle='--', linewidth=1, alpha=0.7)
    t2 = ax.text(_2, 4000, '[2]', fontsize=14, color='k', ha='center', va='center')    
    t2.set_bbox(dict(facecolor='#eeeeee', alpha=1, edgecolor='#eeeeee', pad=1))

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('Factors Affecting EUR: Lateral Length, PPF, and FPF')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.345, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(0.055, 0.16), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="row" id="table-2" style="margin-top: -15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_table_5.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Table 2: Summary table for Figure 7 - Estimated Ultimate Recovery&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div class="row" id="table-3"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_table_2.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Table 3: Summary table for Figure 7 - Lateral length&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div class="row" id="table-4"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_table_3.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Table 4: Summary table for Figure 7 - Proppant per Perforated Feet&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div class="row" id="table-5"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_table_4.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Table 5: Summary table for Figure 7 - Fluid per Perforated Feet&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Normalized EUR vs. DUC time"&gt;&lt;/div&gt;&lt;h3 id="4.4.-Normalized-EUR-vs.-DUC-time"&gt;4.4. Normalized EUR vs. DUC time&lt;a class="anchor-link" href="#4.4.-Normalized-EUR-vs.-DUC-time"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt; above revealed positive correlation between completion size and lateral length with EUR; increased lateral length requires a larger completion size to fracture the additional length, leading to a greater EUR. To isolate the effect of DUC time on EUR and eliminate the influence of other confounding variables, EURs (BOE) are normalized (divided) by PPF (lbs/ft), FPF (gal/ft), and lateral length (ft). The resulting statistic has an unit of (BOE &lt;em&gt; ft)/(lbs &lt;/em&gt; gal). Its absolute value is meaningless, as it is a statistic created solely to distinguish the effects of other variables on EUR. Only the relative percentage change in the statistic is relevant.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt; displays the impact of DUC time on normalized EUR for each basin. The local troughs and peaks in each basin represent points of interest used to quantify the relative change in EUR for wells completed shortly after drilling compared to old DUC wells. A detailed analysis and commentary for each basin are presented &lt;a href="#detailed"&gt;below&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Moreover, &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt; has the potential to be a useful tool in evaluating completion investment efficiency. For instance, the Bakken basin, which has the highest mean normalized EUR along the x-axis, can be argued to have superior rate of return for each dollars spent for hydraulic fracturing compared to the other basins. Conversely, the Eagle Ford and Permian basins have lower mean normalized EUR values at different DUC times, which is expected due to their status as some of the oldest oil and gas plays in the US and the significant depletion of their "sweet spots."&lt;/p&gt;
&lt;p&gt;It is important to note that the calculated statistic in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;, the average normalized EUR &lt;strong style="color: #287cb7"&gt;(&lt;img class="inline-image" src="jupyter_images/duc_legend_5.png"/&gt;blue lines)&lt;/strong&gt;, is heavily influenced by extreme data points due to two reasons. Firstly, the statistic is a combination of four variables, each of which may not contain outliers individually but may do so when combined. Therefore, if multiple variables have extreme data points, the calculated statistic will have greater skewness due to a larger standard deviation. Secondly, the derivation of the statistic necessitates the presence of four variables (EUR, PPF, FPF, and lateral length) simultaneously, causing the source data file (&lt;a class="ico xls" href="https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx" target="_blank"&gt;EUR_vs_Lag.xlsx&lt;/a&gt;) to drop rows with any of the four variables missing. Consequently, the Haynesville basin, which had 2,858 wells in &lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt;, had only 1,724 wells in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;.&lt;/p&gt;
&lt;div class="row" id="fig-8" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/6_normalized_EUR_Lateral_FPF_PPF_2.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 8: Each dot represents one well's normalized EUR. The wells are binned by 50 DUC days. Each band of dots represents wells completed within the 50-day binned interval. The blue line plot represetns the average of wells in each 50-day bin. Note that the credibility of this average line plot is affected by the number of data points in each bin. Bakken and Haynesville have suffers from lack of data for their first bin. Indices of the local peaks and troughs are chosen by visual inspection; the points which "look like" local troughs and peaks are picked, and are prone to subjectivity.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (8)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

no_NA = ['EUR (Full) BOE', 'Fluid per Perforated Foot (First Treatment Job)', 
         'DI Lateral Length', 'Proppant per Perforated Foot (First Treatment Job)']
dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=no_NA)           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']                   # Horizontal wells only

    # Drops non-hydrocarbon wells like: Dry hole, injection, core, etc.
    df_cur = df_cur[df_cur['Production Type'].isin(['OIL', 'GAS', 'OIL &amp; GAS'])]

    #df_cur[EURs] = df_cur[EURs].div(1000).round(0)
    dfs.append(df_cur)

############################################# Plot ################################################

axis_tick_fontsize = 14
title_fontsize = 19
markersize = 20
y_label_fontsize = 16

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c']

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

def annotate_arrows(data_y, num, tick_spacing, ymax, x_start=1, ox=0.2, fontsize=14, flip_y=False):
    '''
    data_y = y coordinate of the datapoint of interest
    num = index of the datapoint of interest
    tick_spacing = spacing between two major ticks
    ox = offset of x
    '''

    head_padding = ymax * 0.04                 # extra space between the datapoint of interest and arrowhead
    oy = ymax * 0.15                           # offset of y
    sx = x_start + (tick_spacing / 2) * num
    sy = data_y + head_padding

    if flip_y:
        oy = -ymax * 0.15
        sy = data_y - head_padding

#------------------------------------------------------------------------------------------------------------------

    ax.arrow(sx + ox, sy + oy, -ox, -oy, head_width=0.0, fc='k', ec='k', lw=2)
    t1 = ax.text(sx + ox, sy + oy, round(data_y, 5), fontsize=fontsize, color='k', ha='center')
    t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

#------------------------------------------------------------------------------------------------------------------

    xytext = (sx + ox, sy + oy)

    return xytext 


for i, (ax, basin) in enumerate (zip(axes, basins)):

    # select current basin data
    df = dfs[i]

     # cut off high lag bins with too few wells
    df = df[df['Lag'] &lt;= 1000]

    # binning by 50 days
    stepsize = 50
    bins = np.arange(0, 1000 + stepsize, stepsize)

    # scatter plot of binned wells
    #norm_eur_original = []
    norm_eur_cleaned = []
    norm_eur_outlier = []
    for b in bins[: -1]:

        eur_bin = df[df['Lag'].between(b, b + stepsize)]['EUR (Full) BOE']
        lateral_bin = df[df['Lag'].between(b, b + stepsize)]['DI Lateral Length']
        fpf_bin = df[df['Lag'].between(b, b + stepsize)]['Fluid per Perforated Foot (First Treatment Job)']
        ppf_bin = df[df['Lag'].between(b, b + stepsize)]['Proppant per Perforated Foot (First Treatment Job)']

        cutoff = 0.95
        norm_eur_original_ = eur_bin/lateral_bin/fpf_bin/ppf_bin
        norm_eur_cleaned_ = norm_eur_original_[norm_eur_original_ &lt;= norm_eur_original_.quantile(cutoff)]
        norm_eur_outlier_ = norm_eur_original_[norm_eur_original_ &gt; norm_eur_original_.quantile(cutoff)]

        norm_eur_cleaned.append(norm_eur_cleaned_)
        norm_eur_outlier.append(norm_eur_outlier_)    

    for j, item in enumerate(norm_eur_cleaned):
        x = np.random.normal(j + 1, 0.06, size=len(item))
        ax.scatter(x, item, color=colors[i], alpha=0.5, s=10, edgecolors='k', linewidth=0.0, label='One well data')

    for k, item_outlier in enumerate(norm_eur_outlier):
        x_outlier = np.random.normal(k + 1, 0.06, size=len(item_outlier))
        ax.scatter(x_outlier, item_outlier, color='r', alpha=0.3, s=30, marker='x', label='Outliers')   

    # line plot of average of binned wells
    means = [np.mean(item) for item in norm_eur_cleaned]
    ax.plot([i + 1 for i in range(len(means))], means, linestyle='-', marker='o', markersize=8, alpha=0.7,
            label='AVG. normalized EUR, binned by 50 lag days')       

    # axis range
    ymax = 0.02
    ymin = 0 - 0.05 * ymax
    ax.set_ylim(ymin, ymax)

    # tick settings
    ax.xaxis.set_major_locator(plt.MaxNLocator(12))
    ax.yaxis.set_major_locator(plt.MaxNLocator(6))  
    ax.set_xticklabels([int(item) for item in ax.get_xticks() * stepsize], fontsize=axis_tick_fontsize)
    ax.tick_params(axis='x', labelsize=axis_tick_fontsize, labelrotation=30)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    #ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax.minorticks_on()
    ax.xaxis.set_tick_params(which='minor', bottom=False)
    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator(2))

    # spines and grid
    ax.spines.top.set_visible(False)
    ax.spines.right.set_visible(False)
    ax.grid(axis='y', alpha=0.5)
    ax.grid(axis='y', which='minor', color='grey', linestyle='--', alpha=0.2)
    ax.set_axisbelow(True)

    # texts
    ax.set_title(basin + ': ' + str(np.concatenate(norm_eur_cleaned).shape[0]) + ' wells', fontsize=title_fontsize)
    ax.set_ylabel('EUR/PPF/FPF/Lateral', fontsize=y_label_fontsize)
    if i == 4 or i == 6:
        ax.set_xlabel('DUC time (Days)', fontsize=y_label_fontsize)
    ax.set_facecolor('#eeeeee')
    ax.text(0.15, 0.88, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)    

    # legends
    h0, l0 = ax.get_legend_handles_labels()
    leg = ax.legend([h0[0]], [l0[0]], fontsize=14, ncol=2, loc='upper right')
    for lh in leg.legendHandles:
        lh.set_alpha(1)
        lh.set_sizes([50])

    h1, l1 = ax.get_legend_handles_labels()
    fig.legend([h1[-1]], [l1[-1]], loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.195), bbox_transform=fig.transFigure, fontsize=18) 

    fs = 15
    lw = 2
    _1 = 0
    spacing = abs(ax.get_xticks()[1] - ax.get_xticks()[2])
    if basin == 'Anadarko':
        _2 = 3
        yloc = 0.011
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

    if basin == 'Appalachia': 
        _2 = 6
        yloc = 0.015
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs, flip_y=False)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs, flip_y=False)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Bakken':
        _1 = 1
        _2 = 14
        yloc = 0.012
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Eagle Ford':
        _2 = 5
        yloc = 0.014
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2))        
    if basin == 'Haynesville': 
        _1 = 1
        _2 = 3
        yloc = 0.015
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs, flip_y=False)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs, flip_y=False)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 
    if basin == 'Niobrara':
        _2 = 5
        yloc = 0.015
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '+' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='green', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2))  
    if basin == 'Permian':
        _2 = 3
        yloc = 0.014
        textxy1 = annotate_arrows(means[_1], _1, spacing, ymax, fontsize=fs)
        textxy2 = annotate_arrows(means[_2], _2, spacing, ymax, fontsize=fs)   
        ax.plot([textxy1[0], textxy1[0]], [textxy1[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy2[0], textxy2[0]], [textxy2[1], yloc], lw=lw, color='k', ls='--')
        ax.plot([textxy1[0], textxy2[0]], [yloc, yloc], lw=lw, color='k', ls='--')
        diff_percentage = '' + str(int((means[_2] - means[_1])/means[_1] * 100)) + '%'
        t1 = ax.text((textxy1[0] + textxy2[0])/2, yloc, diff_percentage, fontsize=fs, color='red', ha='center')
        t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='k', pad=5, lw=2)) 

    #break

fig.tight_layout()

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('EUR Normalized by PPF, FPF and Lateral Length')  + ",  Jan 2014 - June 2022", fontsize=20, x=0.34, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, DrillingInfo', xy=(0.055, 0.173), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")    
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="detailed" style="margin-top: -15px"&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Anadarko&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The normalized EUR for Anadarko wells completed beyond 50 days since drilled dropped by 81% over a 150-day span. The two outlier points in the average normalized EUR at 400-day and 450-day bins were identified as a result of extreme data points that could not be filtered out using the percentile method due to a lack of data. The observed decrease in normalized EUR with increasing DUC time follows the pattern observed in typical logarithmic production decline curve with a high b-factor, indicating a fast initial decline in production due to reservoir depletion. This could be an indication of severe well-to-well interference problems in the Anadarko basin.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-9" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_anadarko.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 9: Anadarko basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Appalachia&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The normalized EUR dropped by 19% over a span of 300 DUC days beyond the initial 50-day bin average. It seems to decrease linearly with DUC time at a very slow pace compared to Anadarko or Permian. Assuming linear regression, one could argue that the Appalachia DUC wells lose 2.7% EUR for every 50 days of delay in completion.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-10" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_appalachia.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 10: Appalachia basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Bakken&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The normalized EUR of Bakken wells exhibits an exponential decline trend, with the initial decline rate smaller than Anadarko but greater than Appalachia. Note that the first bin of data (50-day bin) for Bakken wells is characterized by a limited number of data points, including extreme outliers that heavily skew the calculated normalized EUR values. Therefore, the second bin (100-day bin) is considered as the starting point, where Bakken wells experienced a 70% decrease in production over 700 DUC days. It is important to note that this decline would likely be greater if more data points were available in the first bin, thereby yielding a more reliable average normalized EUR value.&lt;/p&gt;
&lt;p&gt;Based on the observation that Anadarko and Permian wells exhibit logarithmic decline in normalized EUR and experience rapid decline during early DUC time, it is expected that the initial average normalized EUR value for Bakken wells would be higher in the first day bin compared to the second day bin. Assuming an initial average normalized EUR value of 0.016 (although this is subjective), it is projected that the Bakken basin would experience a 78% decrease in production over a span of 750 DUC days.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-11" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_bakken.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 11: Bakken basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Eagle Ford&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The Eagle Ford wells showed very minimal or no degradation in EUR with increasing DUC time. One can deduce that the Eagle Ford wells are more resilient to the well-to-well interference problems than the other basins. Note that this shows the trend of the entire basin; limiting the data pool to a small group of wells in a small area of interest may reveal different trend.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-12" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_eagleford.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 12: Eagle Ford basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Haynesville&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The statistical analysis of the Haynesville basin is limited due to the dearth of available data. Specifically, only 1,792 wells in the basin have complete information on EUR, proppant, fluid volume, and lateral length, which was further reduced to 1,724 after removing outliers. Notably, the average normalized EUR for the 50-day and 450-day bins extends beyond the y-axis range, while only the wells within the 100- to 350-day bins exhibit reliable results with sufficient number of records.&lt;/p&gt;
&lt;p&gt;Treating the 100-day bin as the first index of a local peak and the 200-day bin as the index of a local trough, the Haynesville wells demonstrated a 46% decrease in normalized EUR during 100 days of DUC time. However, given the logarithmic decline in average normalized EUR observed in Anadarko and Permian wells, an interpolation can be performed to estimate a plausible value of the first bin, around 0.008, although subjectivity is a possible limitation. This estimation leads to an anticipated 69% production decline in the Haynesville basin during the subsequent 150 DUC days after the initial 50 DUC days, followed by a relatively constant level of production afterwards.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-13" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_haynesville.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 13: Haynesville basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Niobrara&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Notably, the Niobrara basin demonstrated a substantial increasing trend in normalized EUR with increasing DUC time up to the 300-day bin, followed by a relatively constant or slowly declining trend in normalized EUR.&lt;/p&gt;
&lt;p&gt;The observation of increasing normalized EUR with increasing DUC time in Niobrara wells is intriguing and contradicts the prevailing scientific literature, which suggests that child wells tend to underperform relative to parent wells. However, this premise assumes the presence of a parent-child relationship between wells. In the absence of well-to-well interference factors, DUC wells waiting to be completed may be free from such negative impacts on production.&lt;/p&gt;
&lt;p&gt;One potential explanation for this counter-intuitive trend in normalized EUR could be the presence of unique geologic characteristics specific to the Niobrara basin, or the existence of hidden factors that were not accounted for during the normalization process. For example, Niobrara may be relatively free from vertical fracture interference problems associated with stacked laterals compared to other basins, or may have been subjected to substantially different completion or production techniques. It is important to note that &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt; and &lt;a href="#table-4"&gt;Table 4&lt;/a&gt; above revealed that Niobrara was the only basin to exhibit a decrease in PPF with increasing DUC time, which suggests the presence of hidden factors not captured in the data set used for this study. Therefore, further analysis and study is required to understand this unexpected behavior.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-14" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_niobrara.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 14: Niobrara basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Permian&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The normalized EUR for Permian wells completed beyond 50 days since drilled dropped by 74% over a span of 150 days. The normalized EUR does not substantially drop further after the 200-day bin. This trend is very similar to that of the Anadarko basin's.&lt;/p&gt;
&lt;div class="row row full_screen_margin_60 mobile_responsive_plot_full_width" id="fig-15" style="margin-top: 10px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/duc_normalized_permian.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 15: Permian basin from Figure 8&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Dead DUC wells"&gt;&lt;/div&gt;&lt;h2 id='5.-"Dead"-DUC-wells'&gt;5. "Dead" DUC wells&lt;a class="anchor-link" href='#5.-"Dead"-DUC-wells'&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DUC wells are treated as a form of oilfield working capital. They are essentially a long-term, partially funded storage of hydrocarbons "under" the ground instead of "on" the ground. However, if a well remains in DUC stage for too long, it no longer functions as a working oilfield capital. Analyst John Freeman from Raymond James &amp; Associates Inc. said that that 95% of the drilled wells have been completed within 2 years, and that DUCs older than 2 years have low chance of ever being completed and considered out-of-the-system (a.k.a. Dead DUCs). Comparing with the Enverus data of wells in the seven DPR regions supports this claim to be reasonably true.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt; presents a 95% box plot of the DUC time for wells in each basin, providing insight into the time limit till completion for oil and gas wells in the US. The plot indicates that 95% of the wells in the Anadarko basin were completed within 309 days after drilling, while wells in the Appalachia basin were completed within 956 days. The weighted average for all DPR regions reveals that 95% of wells in the US are completed within 567 days after drilling. The implications of these results suggest that any well not completed within this timeframe has a less than 5% chance of being completed, thereby rendering the expensive drilling cost that the operator incurred a waste.&lt;/p&gt;
&lt;p&gt;The completion time limit for DUC wells depends on their ultimate rate of return, which is a complex function of various factors, including EUR, well-to-well interference problems, royalty rate, and costs associated with site-clearing, drilling, lateral length, completion size and concentration per foot, daily operating costs, and lease purchase and renewal. However, comparing the 95% upper limit for DUC time across basins in &lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt; reveals an interesting correlation with the other findings of this study.&lt;/p&gt;
&lt;p&gt;Notably, the three basins with the shortest DUC time limit, namely Anadarko (309 days), Haynesville (409 days), and Permian (470 days), also had the worst depletion rates in normalized EUR. Recall that in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;, Anadarko experienced an 81% drop in normalized EUR in 150 DUC days, while Haynesville and Permian experienced a 46% and 74% drop, respectively. Conversely, the Appalachia, Eagle Ford, and Niobrara basins demonstrated greater resilience to reductions in normalized EUR with increasing DUC time, and showed longer time limit till completion in &lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When considering the economic factors that impact the time limit till completion, it is essential to consider EUR as it has a direct impact on the final economic rate of return of a well. In &lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt;, Appalachia has the longest time limit till completion, which can be attributed to its highest EUR along the x-axis compared to other basins. The high EUR renders operators to be more flexible with the costs associated with maintaining their DUC wells' lease. This understanding explains why Niobrara has a close DUC time limit with that of Permian despite Niobrara's strong resilience to the decrease in normalized EUR with increasing DUC time. In &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt;'s &lt;a href="#table-2"&gt;Table 2&lt;/a&gt;, Niobrara shows 541 MBOE of EUR at its local peak [2], while Permian shows 1,061 MBOE of EUR, which is almost double. In summary, Niobrara and Permian have opposing pros and cons that balance their time limit till completion to be similar.&lt;/p&gt;
&lt;div class="row" id="fig-16" style="margin-top: 20px"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Time Limit Until Completion.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 16: 95% Box plot of gap time between drilling and completion. The plot shows the time limit until completion for each basin. Each dot (very small, 99.5% transparency) represent one well of a basin. Upper whisker and the numeric annotation above it represent 95% upper limit. This means that wells with DUC time longer than the annotated number have less then 95% chance of ever being completed. Box plot for "All Regions" represent weighted average of all basins.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (16)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store the completion &amp; drilling date difference data of 7 basins
# data restricted to wells that has "Completion Date" column populated
# source: DrillingInfo App of Enverus

lags = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EUR_vs_Lag.xlsx', sheet_name=basin)
    df_cur = df_cur.dropna(subset=['Completion Date'])           # Drop wells that are not completed
    df_cur = df_cur[df_cur['Drill Type'] == 'H']
    lags.append(df_cur['Lag'].values)

flattened = []
temp = [list(lag) for lag in lags]
for item in temp:
    flattened += item

lags.append(flattened)
basins.append('All Regions')

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4.5))

colors = ['grey', '#a1794a', '#d484a9', '#cbe8f0', '#c6b4ee', '#914810', '#16534c', 'lightgrey']

cutoff = 95

for i, basin_lag in enumerate(lags):
    i = i + 1
    x = np.random.normal(i, 0.06, size=len(basin_lag))
    ax.scatter(x, basin_lag, color=colors[i - 1], alpha=0.005)
    _cutoff = int(np.percentile(basin_lag, cutoff))
    ax.text(i, _cutoff + 150, str(_cutoff) + ' days', fontsize=10, ha='center', va='center', color='k')

lw = 1
caps = ax.boxplot(lags, sym='', whis=[0, cutoff], showfliers=True,
                     boxprops=dict(linewidth=lw, color='#4e98c3'),
                     whiskerprops=dict(linewidth=lw, color='#4e98c3', linestyle='--'), vert=True,
                     capprops=dict(linewidth=lw, color='k'),
                     medianprops=dict(linewidth=lw, color='#ad203e'));

n = 0.12
for cap in caps['caps']:
    cap.set(xdata=cap.get_xdata() + (-n, +n))

ax.set_xticklabels(basins, rotation=20)
ax.set_ylim(-70, 2000)
ax.set_ylabel('Lag (Days)')

ax.yaxis.set_major_locator(plt.MaxNLocator(6))
ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Time Limit Until Completion: 95\% Boxplot')  + ",  Jan 2014 - June 2022", fontsize=12, pad=10,
             x=0.31, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.3), xycoords='axes fraction', fontsize=10)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='white', alpha=0.5)

ax.axvline(x=7.5, color='k', linestyle='--', linewidth=1, alpha=0.7)

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Conclusion"&gt;&lt;/div&gt;&lt;h2 id="6.-Conclusion"&gt;6. Conclusion&lt;a class="anchor-link" href="#6.-Conclusion"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The well-established scientific wisdom suggests that parent (old) wells perform better than their nearby child (new) wells, due to the parent wells having already drained a significant volume of hydrocarbons and left the child well with lower reservoir pressure and smaller volume of fluids left to produce.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Wells completed shortly after drilling (within 50 days) tend to have substantially smaller EUR compared to wells with longer DUC time (&lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt;). This is because wells with longer DUC time tend to have longer lateral length and are treated with bigger completion. Conversely, it means that operators tend to undersize their completion concentration per lateral foot for wells completed shortly after drilling (&lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt;). Thus, investing in larger completion size for wells completed shortly after drilling may yield greater profit for operators.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To assess the genuine impact of DUC time on production, EUR was normalized by lateral length, proppant per perforated foot (PPF), and fluid per perforated foot (FPF).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It has been found that increasing DUC time has a significant negative impact on the EUR of Anadarko, Bakken, Hanyesville, and Permian wells. Notably, Anadarko and Permian showed 81% and 74% drop in noramlized EUR, respectively, over a span of 150 days of DUC time. However, Appalachia, Eagle Ford and Niobrara wells have been found to be resilient from the EUR loss due to increasing DUC time (&lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;), showing negligible decrease in normalized EUR along the x-axis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In some basins, delaying completion due to unfavorable commodity prices may not be a financially sound strategy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt; provides valuable insight to evaluate completion investment efficiency as it shows EUR normalized by completion size and lateral length.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DUC wells have time limit till completion. For example, Anadarko wells have less than 5% chance of completion for DUC wells older than 308 days since drilled (&lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt;). Chance of completion drastically falls afterwards, which may render the drilling investment made for the well to be a waste.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Anadarko and Haynesville wells have the shortest time limit till completion (&lt;a href="#fig-16"&gt;Figure 16&lt;/a&gt;). This can be attributed to the fact that they are the ones with the worst decrease in normalized EUR with increasing DUC time, as demonstrated in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;. On the other hand, Appalachia wells have the longest time limit till completion because they yield the greatest EUR at differnt DUC times, and their normalized EUR decreases minimally with increasing DUC time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlights red-theme" id="boxcox-warning"&gt;
&lt;div class="highlights-title red-theme"&gt;WARNING!&lt;/div&gt;
&lt;div class="highlights-content red-theme"&gt;
&lt;p&gt;The presented analysis provides a basin-wide overview at a high level, and the conclusions drawn assume homogeneity within each basin. However, this assumption may not hold true for many regions. By restricting the analysis to a county-level, different trends may emerge compared to those observed at the basin level.&lt;/p&gt;
&lt;p&gt;In &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt;, it was observed that delaying completion by 150 days resulted in an 81% decline in normalized EUR for Anadarko wells. In contrast, no drop in EUR was observed for Eagle Ford wells. These conclusions should be interpreted as follows: "If a new well is drilled in a typical area where most other operators drill, and typical well spacing, completion, and production techniques are applied across the basin, an 81% loss of EUR can be expected for Anadarko wells if completion is delayed by 150 days. It would be advisable to complete Anadarko wells as soon as possible to avoid drainage from neighboring competitor wells. However, for Eagle Ford wells, completion can be delayed for a prolonged period if the oil price is not favorable."&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: 'center'," +
        "    displayIndent: '0em'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['$','$'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
        "    } " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="oil-and-gas"></category><category term="oil"></category><category term="gas"></category><category term="DUC"></category><category term="drilling"></category><category term="horizontals"></category><category term="verticals"></category><category term="completion"></category><category term="production"></category><category term="recent-trend"></category><category term="energy-shortage"></category><category term="EIA"></category><category term="DrillingInfo"></category><category term="Enverus"></category><category term="DPR"></category><category term="dead-duc"></category><category term="Anadarko"></category><category term="Appalachia"></category><category term="Bakken"></category><category term="Eagle Ford"></category><category term="Niobrara"></category><category term="Hanyesville"></category><category term="Permian"></category></entry><entry><title>DUC Wells and Their Economic Complications</title><link href="https://aegis4048.github.io/duc_wells_and_their_economic_complications" rel="alternate"></link><published>2023-02-09T00:00:00-08:00</published><updated>2023-02-09T00:00:00-08:00</updated><author><name>ERIC KIM</name></author><id>tag:aegis4048.github.io,2023-02-09:/duc_wells_and_their_economic_complications</id><summary type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color …&lt;/style&gt;</summary><content type="html">&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color: #B22B31;
}
.ansi-red-intense-bg {
  background-color: #B22B31;
}
.ansi-green-fg {
  color: #00A250;
}
.ansi-green-bg {
  background-color: #00A250;
}
.ansi-green-intense-fg {
  color: #007427;
}
.ansi-green-intense-bg {
  background-color: #007427;
}
.ansi-yellow-fg {
  color: #DDB62B;
}
.ansi-yellow-bg {
  background-color: #DDB62B;
}
.ansi-yellow-intense-fg {
  color: #B27D12;
}
.ansi-yellow-intense-bg {
  background-color: #B27D12;
}
.ansi-blue-fg {
  color: #208FFB;
}
.ansi-blue-bg {
  background-color: #208FFB;
}
.ansi-blue-intense-fg {
  color: #0065CA;
}
.ansi-blue-intense-bg {
  background-color: #0065CA;
}
.ansi-magenta-fg {
  color: #D160C4;
}
.ansi-magenta-bg {
  background-color: #D160C4;
}
.ansi-magenta-intense-fg {
  color: #A03196;
}
.ansi-magenta-intense-bg {
  background-color: #A03196;
}
.ansi-cyan-fg {
  color: #60C6C8;
}
.ansi-cyan-bg {
  background-color: #60C6C8;
}
.ansi-cyan-intense-fg {
  color: #258F8F;
}
.ansi-cyan-intense-bg {
  background-color: #258F8F;
}
.ansi-white-fg {
  color: #C5C1B4;
}
.ansi-white-bg {
  background-color: #C5C1B4;
}
.ansi-white-intense-fg {
  color: #A1A6B2;
}
.ansi-white-intense-bg {
  background-color: #A1A6B2;
}
.ansi-default-inverse-fg {
  color: #FFFFFF;
}
.ansi-default-inverse-bg {
  background-color: #000000;
}
.ansi-bold {
  font-weight: bold;
}
.ansi-underline {
  text-decoration: underline;
}
/* The following styles are deprecated an will be removed in a future version */
.ansibold {
  font-weight: bold;
}
.ansi-inverse {
  outline: 0.5px dotted;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  position: relative;
  overflow: visible;
}
div.cell:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: transparent;
}
div.cell.jupyter-soft-selected {
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected,
div.cell.selected.jupyter-soft-selected {
  border-color: #ababab;
}
div.cell.selected:before,
div.cell.selected.jupyter-soft-selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #42A5F5;
}
@media print {
  div.cell.selected,
  div.cell.selected.jupyter-soft-selected {
    border-color: transparent;
  }
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
}
.edit_mode div.cell.selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #66BB6A;
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell &gt; div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area &gt; div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area &gt; div.highlight &gt; pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the &lt;head&gt; if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  /* Note that this should set vertical padding only, since CodeMirror assumes
       that horizontal padding will be set on CodeMirror pre */
  padding: 0.4em 0;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only,
    use .CodeMirror-lines for vertical */
  padding: 0 0.4em;
  border: 0;
  border-radius: 0;
}
.CodeMirror-cursor {
  border-left: 1.4px solid black;
}
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .CodeMirror-cursor {
    border-left: 2px solid black;
  }
}
@media screen and (min-width: 4320px) {
  .CodeMirror-cursor {
    border-left: 4px solid black;
  }
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev &lt;Maniac@SoftwareManiacs.Org&gt;
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area 
div.output_area 
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
div.output_area .mglyph &gt; img {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 1px 0 1px 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}



.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}






.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul:not(.list-inline),
.rendered_html ol:not(.list-inline) {
  padding-left: 2em;
}








.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}





.rendered_html pre,




.rendered_html tr,
.rendered_html th,


.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
.rendered_html * + table {
  margin-top: 1em;
}

.rendered_html * + p {
  margin-top: 1em;
}

.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,

.rendered_html img.unconfined,


.rendered_html * + .alert {
  margin-top: 1em;
}
[dir="rtl"] 
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell &gt; div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered 
.text_cell.rendered .rendered_html tr,
.text_cell.rendered .rendered_html th,
.text_cell.rendered 
.text_cell.unrendered .text_cell_render {
  display: none;
}
.text_cell .dropzone .input_area {
  border: 2px dashed #bababa;
  margin: -1px;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
&lt;/style&gt;
&lt;style type="text/css"&gt;pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */&lt;/style&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Once a well is drilled, it must be completed to produce. However, operators may choose not to immediately complete a well for various reasons:&lt;/p&gt;
&lt;ol class="rounded-list" style="margin-bottom: 30px !important; margin-top: 30px! important;"&gt;
&lt;li&gt;&lt;p&gt;Availability of fracking crews&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Drilling contracts that are too expensive to revoke&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Constraints on capital spending&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Commodity prices&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many others&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Whatever the reasons may be, this in-transit time between drilling and completion stages creates an inventory of DUC wells. The term, &lt;strong&gt;DUC wells&lt;/strong&gt;, have a literal definition - &lt;strong&gt;Drilled but Uncompleted wells&lt;/strong&gt;. They essentially serve as a secodary form of hydrocarbon storage underground, instead of surface storage facilities. The wells can be turned on line for production for cheap; the costs of drilling have been paid, and completion won't be as costly as new drilling. This unique characteristic of DUC wells allows the operators to make strategic decisions during the time of financial crisis (ex: 2020 COVID crash); they complete the existing DUC wells and take profits instead of drilling new wells. However, this profit taking process inevitably leads to the reduction in size of DUC well inventories, which gave rise to the concerns regarding potential energy supply shortage due to the depletion of DUC wells around early 2022.&lt;/p&gt;
&lt;p&gt;In this article I attempt to help the readers to understand what it means to have DUC well inventories, why they exist, and the economic impact they have on the US energy industry.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="toc_container"&gt;
&lt;p class="toc_title"&gt;Contents&lt;/p&gt;
&lt;ul class="toc_list"&gt;
&lt;li&gt;&lt;a href="#Sample data description"&gt;&lt;span class="toc_label"&gt;0&lt;/span&gt;Sample data description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Key takeaways"&gt;&lt;span class="toc_label"&gt;1&lt;/span&gt;Key takeaways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#How are DUC wells created?"&gt;&lt;span class="toc_label"&gt;2&lt;/span&gt;How are DUC wells created?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#DUC wells and Economic Complications"&gt;&lt;span class="toc_label"&gt;3&lt;/span&gt;DUC wells and Economic Complications&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Potential depletion of DUC wells and enegy supply shortage"&gt;&lt;span class="toc_label"&gt;3.1&lt;/span&gt;Potential depletion of DUC wells and enegy supply shortage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Recent trend: more production with less drilling"&gt;&lt;span class="toc_label"&gt;3.2&lt;/span&gt;Recent trend: more production with less drilling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;&lt;a href="#Continued discussion: Dead DUC wells"&gt;&lt;span class="toc_label"&gt;4&lt;/span&gt;Continued discussion: "Dead DUC Wells"&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Sample data description"&gt;&lt;/div&gt;&lt;h2 id="0.-Sample-data-description"&gt;0. Sample data description&lt;a class="anchor-link" href="#0.-Sample-data-description"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The main data source I use for this article is the &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;Drilling Productivity Report&lt;/a&gt; (DPR) from the US Energy Information Administration (EIA), and some supplemental data from the &lt;a href="https://www.enverus.com/" target="_blank"&gt;Enverus&lt;/a&gt; Drilling Info application since 2014. While the DPR data is readily available to the public as its provided by the US government, Enverus' Drilling Info data is not because its a commerical software.&lt;/p&gt;
&lt;p&gt;The DPR data covers the 7 major oil and gas basins in the US: Anadarko, Appalachia, Bakken, Eagle Ford, Haynesville, Niobrara, and Permian.&lt;/p&gt;
&lt;div class="row full_screen_margin_80 mobile_responsive_plot_full_width" id="fig-1" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DPR-basins.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 1: 7 major basins in the US, Source: EIA&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;I downloaded the &lt;a class="ico xls" href="https://www.eia.gov/petroleum/drilling/xls/dpr-data.xlsx" target="_blank"&gt;Report data (aggregated by region)&lt;/a&gt; &lt;strong&gt;(dpr-data.xlsx)&lt;/strong&gt; and the &lt;a class="ico xls" href="https://www.eia.gov/petroleum/drilling/xls/duc-data.xlsx"&gt;DUC data (aggregated by region)&lt;/a&gt; &lt;strong&gt;(duc-data.xlsx)&lt;/strong&gt;, which can be found in the &lt;i&gt;"Contents"&lt;/i&gt; tab in the right side of this &lt;a href="https://www.eia.gov/petroleum/drilling/" target="_blank"&gt;page&lt;/a&gt;. Visualizing the DPR data for each basin generates the below figure:&lt;/p&gt;
&lt;div class="row" id="fig-2" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/DUC &amp; Newly Drilled Wells and Production by Basins, Jan 2014 - Dec 2022.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 2: Quick glance at the EIA DPR data for each basin. Note that the Permian basin has different y-axis scale for DUC &amp; newly drilled wells count.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (2)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import warnings
import matplotlib.gridspec as gridspec
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs_year = df.groupby([df.index.year, 'Basin'])['DUC'].mean()
df_DUCs_year = df_DUCs_year.unstack().fillna(0)
df_DUCs_year = round(df_DUCs_year, 0)

df_drilled_year = df.groupby([df.index.year, 'Basin'])['Drilled'].sum()
df_drilled_year = df_drilled_year.unstack().fillna(0)
df_drilled_year['Total Drilled'] = df_drilled_year.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod_year = df2_total_gas_prod_year.unstack().fillna(0)
df2_total_gas_prod_year['Total Gas (BCFD)'] = df2_total_gas_prod_year.T.apply(lambda x: sum(x))
df2_total_gas_prod_year = df2_total_gas_prod_year / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod_year = df2.groupby([df2.index.year, 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod_year = df2_total_oil_prod_year.unstack().fillna(0)
df2_total_oil_prod_year['Total (MMBBLD)'] = df2_total_oil_prod_year.T.apply(lambda x: sum(x))
df2_total_oil_prod_year = df2_total_oil_prod_year / 1000000

############################################# Plot ##############################################

# changing datetime index to str is necessary to overlay lineplot on top of barplot
df_drilled_year.index = [str(item) for item in df_drilled_year.index]
df2_total_gas_prod_year.index = [str(item) for item in df2_total_gas_prod_year.index]
df2_total_oil_prod_year.index = [str(item) for item in df2_total_oil_prod_year.index]

cmap_name = 'cubehelix'
colors = sns.color_palette(cmap_name, n_colors=len(basins))
np.random.seed(34)
np.random.shuffle(colors)
colors = colors.as_hex()
colors[0] = 'grey'
colors[-2] = '#914810'
cmap = LinearSegmentedColormap.from_list("my_colormap", colors)
barcolor_dict = {label: color for label, color in zip(basins, colors)}

axis_fontsize = 15
axis_tick_fontsize = 11
title_fontsize = 18
figure_title_fontsize = 20
label_fontsize = 13
legend_fontsize = 16
markersize = 9
y_label_fontsize = 15

gas_prod_color = 'red'
oil_prod_color = 'green'
drilled_color = 'k'

fig = plt.figure(figsize=(16, 17))
gs = gridspec.GridSpec(4, 4)
ax1 = plt.subplot(gs[0, 0:2])
ax2 = plt.subplot(gs[0,2:])
ax3 = plt.subplot(gs[1,0:2])
ax4 = plt.subplot(gs[1,2:])
ax5 = plt.subplot(gs[2,0:2])
ax6 = plt.subplot(gs[2,2:])
ax7 = plt.subplot(gs[3,2:4])
axes = [ax1,ax2,ax3,ax4,ax5,ax6,ax7]

for i, (ax, basin) in enumerate(zip(axes, basins)):

    df_DUCs_year.plot.bar(alpha=1, y=basin, ax=ax, legend=None, width=0.9, edgecolor='k', linewidth=0.1, label='DUC Count', color=barcolor_dict[basin])

    ax1 = ax.twinx()
    df_drilled_year.plot(y=basin, ax=ax1, linestyle='-', legend=None, marker='o', color=drilled_color, markersize=markersize, label='New Drilled Wells')

    ax2 = ax.twinx()
    df2_total_oil_prod_year.plot(y=basin, ax=ax2, linestyle='-', marker='o', color='green', markersize=markersize, label='Oil Prod Total', legend=None)
    ax2.set_ylim(0, 70)

    ax3 = ax.twinx()
    df2_total_gas_prod_year.plot(y=basin, ax=ax3, linestyle='-', marker='o', color='red', markersize=markersize, label='Gas Prod Total', legend=None)
    ax3.set_ylim(0, 500)

    ax.set_facecolor('#eeeeee')
    ax.set_axisbelow(True)
    ax.grid(axis='y')
    ax.set_xticklabels([str(dt).split('-')[0] for dt in df_DUCs_year.index])
    ax.tick_params(axis='x', labelrotation=45, labelsize=axis_tick_fontsize)
    ax.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax1.tick_params(axis='y', labelsize=axis_tick_fontsize)
    ax.set_title(basin, fontsize=title_fontsize)

    if i % 2 == 0 and i != 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
        ax2.set_yticks([])
        ax3.set_yticks([])        
    else:
        ax1.set_ylabel('Drilled Wells Count (k)', fontsize=axis_fontsize)

        ax2.tick_params(axis='y', colors='green')
        ax2.spines['right'].set_position(('outward', 50))
        ax2.spines['right'].set_color('green')
        ax2.set_ylabel('Total Oil Prod. (MMBBLD)', color='green', fontsize= axis_fontsize)

        ax3.tick_params(axis='y', colors='red')
        ax3.spines['right'].set_position(('outward', 100))
        ax3.spines['right'].set_color('red')
        ax3.set_ylabel('Total Gas Prod. (BCFD)', color='red', fontsize= axis_fontsize) 

    if i == 6:
        ax.set_ylabel('DUC Wells Count (k)', fontsize=axis_fontsize)
    #else:
        #ax1.set_yticks([])
        #ax2.set_yticks([])
        #ax3.set_yticks([])

    if i == 4 or i == 6:
        ax.set_xlabel('Spud Date', fontsize=y_label_fontsize)
    else:
        ax.set_xlabel('')

    if basin == 'Permian':
        pass
        ax.set_ylim(0, 5000)
        ax1.set_ylim(0, 15000)

    else:
        ax.set_ylim(0, 1400)
        ax1.set_ylim(0, 7000)

    ax.yaxis.set_major_formatter(ticker.EngFormatter())
    ax1.yaxis.set_major_formatter(ticker.EngFormatter())        

    ax.spines.top.set_visible(False)
    ax1.spines.top.set_visible(False)
    ax2.spines.top.set_visible(False)
    ax3.spines.top.set_visible(False)

    #ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)
    #ax1.yaxis.get_major_ticks()[-1].gridline.set_visible(False)

    h0, l0 = ax.get_legend_handles_labels()
    h1, l1 = ax1.get_legend_handles_labels()
    h2, l2 = ax2.get_legend_handles_labels()
    h3, l3 = ax3.get_legend_handles_labels()
    ax.legend(h0, l0, loc='upper left', ncol=2, fontsize=13, framealpha=0.5)

    fig.legend(h3 + h2 + h1, l3 + l2 + l1, loc='lower left', ncol=2,
               bbox_to_anchor=(0.046, 0.165), bbox_transform=fig.transFigure, fontsize=legend_fontsize)

    for c in ax.containers:
        ax.bar_label(c, label_type='center', color='white', weight='bold', fontsize=label_fontsize)

    ax.text(0.16, 0.80, 'aegis4048.github.io', fontsize=12, ha='center', va='center',
            transform=ax.transAxes, color='grey', alpha=0.5)        

fig.tight_layout()

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

y_pos = 0.998
fig.suptitle(setbold('DUC &amp; Newly Drilled Wells Count and Production')  + ",  Jan 2014 - June 2022", fontsize=19, x=0.328, y=1.025)
ax.annotate('', xy=(0.006, y_pos), xycoords='figure fraction', xytext=(1, y_pos), arrowprops=dict(arrowstyle="-", color='k', lw=1.3))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(0.05, 0.145), xycoords='figure fraction', fontsize=16)

fig.set_facecolor("white")
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;For the Enverus data, I synchronized the wells from the EIA database with the Drilling Info database by matching their states and counties. The &lt;i&gt;"RegionCounties"&lt;/i&gt; tab in the &lt;strong&gt;dpr-data.xlsx&lt;/strong&gt; shows how EIA decides which states and counties belong to which basins. If you have Driling Info subscription and would like to follow the steps I've taken, you can download this &lt;a href="https://aegis4048.github.io/downloads/notebooks/sample_data/Basins_Boundaries.txt" target="_blank"&gt;text file&lt;/a&gt; I created, and paste its state and county data into Drilling Info's &lt;i&gt;"Paste Filter Selections"&lt;/i&gt; as shown below. You will need to do this 7 times for each basins.&lt;/p&gt;
&lt;div class="row full_screen_margin_70 mobile_responsive_plot_full_width" id="fig-3" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/drilling_info_paste.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 3: Pasting the Eagle Ford basin's state and county data into Drilling Info for query&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Key takeaways"&gt;&lt;/div&gt;&lt;h2 id="1.-Key-takeaways"&gt;1. Key takeaways&lt;a class="anchor-link" href="#1.-Key-takeaways"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;div class="highlights" id="key1"&gt;
&lt;div class="highlights-title"&gt;1. DUCs are accumulated when drilling activity exceeds completion, and vice versa&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key2"&gt;
&lt;div class="highlights-title"&gt;2. DUCs are created due to the following reasons:&lt;/div&gt;
&lt;div class="highlights-content"&gt;(1) Cost efficiency with batch-fracking or batch-drilling (2) Drilling contracts that are too expensive to revoke (3) Constraitns on capital spending and (4) Lack of infrastructure.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key3"&gt;
&lt;div class="highlights-title"&gt;3. DUC wells function as a working oilfield capital&lt;/div&gt;
&lt;div class="highlights-content"&gt;DUCs can quickly be turned on line for production for cheap because the cost of drilling has already been paid. Completing DUC wells is essentially a profit-taking process, so long as there are DUCs left to complete.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key4"&gt;
&lt;div class="highlights-title"&gt;4. Depletion of DUC wells may cause energy shortage problems&lt;/div&gt;
&lt;div class="highlights-content"&gt;The recent COVID crash left operators with scarce capitals to spend. They chose to complete the existing DUC wells for profit instead of drilling new wells, which resulted in fast depletion of DUCs in the US. Prolonged profit-taking process from DUCs without new drilling may result in energy shortage problems when the operators run out of DUC wells to complete.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key5"&gt;
&lt;div class="highlights-title"&gt;5. Modern day industry is producing more hydrocarbons with less drilling activities&lt;/div&gt;
&lt;div class="highlights-content"&gt;This is due to the fact horizontal wells produce 2.5 to 7 times more than verticals, and that modern day drilling is composed of 91% horizontals and 9% verticals.&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlights" id="key6"&gt;
&lt;div class="highlights-title"&gt;6. Gap time between drilling and completion should not be a contributing factor to the birth of "Dead" DUCs&lt;/div&gt;
&lt;div class="highlights-content"&gt;The impact of gap time is not significant enough to render operators to shy away from completing their old DUCs. This is discussed in more detail in my next article.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="How are DUC wells created?"&gt;&lt;/div&gt;&lt;h2 id="2.-How-are-DUC-wells-created?"&gt;2. How are DUC wells created?&lt;a class="anchor-link" href="#2.-How-are-DUC-wells-created?"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The formation of DUC wells in the oil and gas industry is caused by a variety of factors. The most straightforward reason is that they occur when operators drill more wells than they complete, and vice versa, whether by choice or not. If they drill more wells than they complete, DUC wells accumulate. If they complete more wells than they drill, DUC wells deplete. This trend can be observed in &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;, which showcases three distinct periods where the US DUC well counts in the seven DPR regions experienced rapid increases and decreases as a result of imbalanced drilling and completion activities.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-4" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/US Major Basins Completion &amp; Drilling Activities and Commodities.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 4: DUCs accumulate when drilling activity exceeds completion, and vice versa. The line plots depict three distinct periods of significant fluctuations in DUC well inventories, with [1] and [3] representing instances of rapid depletion due to high completion rates, and [2] reflecting a period of accumulation resulting from high drilling activities. WTI Crude oil prices is appended at the bottom to show the effect of commodity prices on DUCs.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (4)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4))

ax2 = ax.twinx()

ax.plot(df_drilled.index, df_drilled['Total Drilled'], color='k', label='Newly Drilled')
ax.plot(df_completed.index, df_completed['Total Completed'], label='Completed')
ax2.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')


ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2016-03-1') &amp; (df_drilled.index &lt;= '2017-1-1'), color='red', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2018-08-01') &amp; (df_drilled.index &lt;= '2019-3-1'), color='green', alpha=0.4)
ax.fill_between(df_drilled.index, df_drilled['Total Drilled'], df_completed['Total Completed'],
                where=(df_drilled.index &gt;= '2020-07-1') &amp; (df_drilled.index &lt;= '2022-8-1'), color='red', alpha=0.4)

ax.axvline(x=df_drilled.index[26], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[35], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[26], df_drilled.index[35], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[55], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[61], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[55], df_drilled.index[61], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[78], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[102], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvspan(df_drilled.index[78], df_drilled.index[102], facecolor='lightgrey', alpha=0.3)

ax.set_ylim(0, 2500)
ax2.set_ylim(0, 10000)

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[5].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax2.spines.top.set_visible(False)

h1, l1 = ax.get_legend_handles_labels()
h2, l2 = ax2.get_legend_handles_labels()
ax.legend(h1 + h2, l1 + l2, fontsize=10, ncol=3, loc='upper left', framealpha=1)

ax.set_ylabel('Drilled &amp; Completed Wells', fontsize=11)
ax2.set_ylabel('DUC Wells', fontsize=11)

ax.arrow(df_drilled.index[71], 1500, 60, -270, head_width=40, head_length=60, fc='k', ec='k')
ax.text(0.58, 0.62, 'Covid Crash', fontsize=9, transform=ax.transAxes, color='k')

ax.text(0.295, 0.05, '[1]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.53, 0.05, '[2]', fontsize=9, transform=ax.transAxes, color='k')
ax.text(0.805, 0.05, '[3]', fontsize=9, transform=ax.transAxes, color='k')

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('US Major Basins Completion &amp; Drilling Activities')  + ",  Jan 2014 - Dec 2022", fontsize=12, pad=10, x=0.4, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.11, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='grey', alpha=0.5)

fig.set_facecolor("white")
fig.tight_layout()

############################################# Plot 2 ##############################################

df = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/EIA-commodity.xls', sheet_name='Data 1')
df = df.iloc[338:-1, :-1] # between Jan 2014 to Dec 2022
df.columns = ['date', 'value']
df.reset_index(inplace=True, drop=True)
df['date'] = df['date'].apply(lambda x: x.strftime('%Y-%m'))
df['date'] = pd.to_datetime(df['date'])

fig, ax = plt.subplots(figsize=(7, 1))

ax.plot(df['date'], df['value'], color='green')

ax.set_ylabel('oil ($)', fontsize=10)
ax.set_ylim(0, 120)
ax.set_yticks(np.linspace(0, 120, 4))
ax.tick_params(axis='both', which='major', labelsize=9)

ax.axvspan(df_drilled.index[26], df_drilled.index[35], facecolor='lightgrey', alpha=0.3)
ax.axvspan(df_drilled.index[55], df_drilled.index[61], facecolor='lightgrey', alpha=0.3)
ax.axvspan(df_drilled.index[78], df_drilled.index[103], facecolor='lightgrey', alpha=0.3)

ax.axvline(x=df_drilled.index[26], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[35], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[55], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[61], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[78], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[103], color='k', linestyle='--', linewidth=1, alpha=0.7)

ax.grid(axis='y', alpha=0.5)
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.yaxis.get_major_ticks()[-1].gridline.set_visible(False)

ax.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -.5), xycoords='axes fraction', fontsize=9)
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Here I list more detailed reasons as to why operators may choose to not complete their well.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cost efficiency with batch-fracking or batch-drilling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As an efficient operator, it is ideal to avoid engaging a fracturing fleet until all logistical requirements have been thoroughly understood and procured and a substantial number of wells have been collected for prolonged, uninterrupted operations. This can be achieved either by maintaining a consistent inventory of wells waiting to be completed or by alternating the company's focus in the region between drilling a series of wells and then completing them all. If there are 10 wells in one location and it takes 10 days to drill each well, the first drilled well will stay idle for at least 90 days before it can be completed. This lag can result in the formation of additional DUC wells in the event of an unforeseen circumstance that renders fracturing unfeasible or undesirable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Drilling contracts that are too expensive to revoke&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Often times the drilling contracts between an operator and a service company entails drilling a batch of wells and expensive contract revokation fee. If the oil price suddenly drops while drilling the contracted batch of wells, the operator may choose not to complete the drilled wells while letting the rig crews keep drilling new wells due to the existing contract. This was the most apparent in the recent COVID crash, which took place around March of 2020. Taking a close look at &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt; around March of 2020 (slightly to the left of [3]), one can observe that there higher drilling than completion activities, which temporarily boosted the number of DUCs until July of 2020 (start of [3]). This happened because there were rig contracts that were still in effect few months after the COVID crash. However, this phenomena did not last long once those contracts expired or have been fulfilled, thus rapidly depleting the number of DUCs until late 2022.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints on capital spending&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The operator may choose not to finish their wells due to restrictions on the company's capital expenditures or adverse market circumstances, opting instead to wait for better economics. However, as shown in &lt;a href="https://aegis4048.github.io/how_do_old_duc_wells_become_dead_ducs#2.-Complications-with-old-DUC-wells" target="blank"&gt;Section 2: Complications with old DUC wells&lt;/a&gt; of my next article, this approach may not always be advisable, as DUC wells older than two years have a low probability, less than 5%, of being completed due to issues such as lost leases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lack of infrastructure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An operator may leave a well uncompleted if there is no nearby pipeline to transport the produced gas after a pad site is cleared and a well is drilled. However, unexpected issues during pipeline construction may result in the well remaining as a DUC well for an extended period until resolved.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="DUC wells and Economic Complications"&gt;&lt;/div&gt;&lt;h2 id="3.-DUC-wells-and-economic-complications"&gt;3. DUC wells and economic complications&lt;a class="anchor-link" href="#3.-DUC-wells-and-economic-complications"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DUC wells are a form of hydrocarbon storage under the ground instead of on the surface storage facilities. The operators invest on drilling first and take profits later when its desirable. This unique characteristics of DUCs create economic complications for the oil and gas industry due to the following reasons:&lt;/p&gt;
&lt;div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Timing:&lt;/strong&gt; DUC wells are partially completed sources of supply that can be brought to market more quickly and at a lower cost than a newly drilled well. However, completing DUC wells at the right time to balance the market demand for energy can be challenging.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p p="" style="display: inline"&gt;&lt;strong&gt;Market fluctuations:&lt;/strong&gt; DUC wells are often used to keep up with demand during times of high energy demand. However, during periods of declining oil prices, completing DUC wells may not be economically viable, leading to a buildup of uncompleted wells. This has been the most apparent between late 2018 to early 2019; WTI crude dropped from &lt;/p&gt;&lt;p style="display: inline"&gt;$&lt;/p&gt;86 to &lt;p style="display: inline"&gt;$&lt;/p&gt;&lt;p style="display: inline"&gt;54. This accumulation of DUCs due to oil price drop can be observed in &lt;a href="#fig-4"&gt;Figure 4&lt;/a&gt;'s highlighted area [2].&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rig contracts:&lt;/strong&gt; In times of declining oil prices, operators may continue to drill wells due to rig contracts, but not complete these wells and bring them into production. This can result in a buildup of DUC wells that may not be economically viable to complete in the future (due to reasons like lost leases).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Profit-taking:&lt;/strong&gt; Completing DUC wells is essentially a profit-taking process done on wells with substantial investment already made. However, if the timing of completion is not aligned with market demand or if capital is not available, the profit-taking process may not yield the expected results.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Capital management:&lt;/strong&gt; The inventory levels of DUC wells are closely linked to the availability of industry capital. When capital is abundant, producers tend to increase drilling relative to completions, leading to a rise in DUC inventory. On the other hand, when capital is scarce, producers prioritize well completion over new drilling, which can lead to a depletion of DUC wells.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Potential depletion of DUC wells and enegy supply shortage"&gt;&lt;/div&gt;&lt;h3 id="3.1.-Potential-depletion-of-DUC-wells-and-enegy-supply-shortage"&gt;3.1. Potential depletion of DUC wells and enegy supply shortage&lt;a class="anchor-link" href="#3.1.-Potential-depletion-of-DUC-wells-and-enegy-supply-shortage"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The COVID-19 pandemic resulted in a reduction of available capital for the oil and gas industry. To conserve cash, many operators prioritized well completion over new drilling, enabling them to maintain production with less capital. However, this strategy of profit-taking cannot be sustained in the long-term and resulted in a rapid decrease of DUC wells in the US, raising concerns about the potential depletion of DUCs and energy supply shortages.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-5"&gt;Figure 5&lt;/a&gt; demonstrates the swift depletion rate of DUCs since July 2020. If this rate continued, the US oil and gas industry would have exhausted its DUC wells by the end of 2023, potentially leading to an energy shortage. Fortunately, drilling activity caught up with completion activities by mid-2022, resulting in a stable level of DUC wells now.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-5" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Depletion of DUC wells and energy supply.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 5: Rapid depletion of US DUC wells since July 2020. Prolonged depletion of DUC wells may result in potential shortage with energy supply if the operators don't drill more wells.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (5)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker
from sklearn import linear_model
import datetime

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA-old.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data-old.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

# current year (2022) prediction parameter
num_month_2022 = 6 # number of months in data set for current year
pred_factor = 12 / num_month_2022 

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod = df2_total_gas_prod.unstack().fillna(0)
df2_total_gas_prod['Total Gas (BCFD)'] = df2_total_gas_prod.T.apply(lambda x: sum(x))
df2_total_gas_prod = df2_total_gas_prod / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod = df2_total_oil_prod.unstack().fillna(0)
df2_total_oil_prod['Total Oil (MBBLD)'] = df2_total_oil_prod.T.apply(lambda x: sum(x))
df2_total_oil_prod = df2_total_oil_prod / 1000

############################################# Plot ##############################################

axis_label_fontsize = 12
title_fontsize = 13
legend_fontsize = 11

fig, axes = plt.subplots(2, 1, figsize=(9, 6.5))

ax1 = axes[0]
ax2 = axes[1]
ax3 = ax2.twinx()

n = 16

# extends the right-end of the x-axis
ext = 38
x_extender = df_DUCs.index.union(df_DUCs.index.shift(n + ext)[-(n + ext):])
x_extender_y = [1 for item in x_extender]

ax1.plot(x_extender, x_extender_y, alpha=0)
ax2.plot(x_extender, x_extender_y, alpha=0)

ax1.axvspan(x_extender[-ext-1], x_extender[-1], facecolor='lightgrey', alpha=0.5)
ax2.axvspan(x_extender[-ext-1], x_extender[-1], facecolor='lightgrey', alpha=0.5)

################################### DUC Wells Linear Regression ###################################

X_pred_plot = df_DUCs.index.union(df_DUCs.index.shift(n)[-n:])
X_pred = X_pred_plot.to_julian_date().values.reshape(-1, 1)

X = df_DUCs.index.to_julian_date().values.reshape(-1, 1)
y = df_DUCs['Total DUCs'].values

fit_begin = 79
fit_end = -3
plot_begin = 90

ols = linear_model.LinearRegression()
model = ols.fit(X[fit_begin: fit_end], y[fit_begin: fit_end])
response = model.predict(X_pred[plot_begin:])

ax1.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')
ax1.plot(X_pred_plot[plot_begin:], response, color='b', label='DUC Prediction', linestyle='--', linewidth=2)
ax1.vlines(x=df_DUCs.index[fit_begin - 1], ymin=0, ymax=max(y) - 100, color='purple', alpha=0.7, linestyle='--')
ax1.scatter(X_pred_plot[-1], 0, marker='o', color='b', label='point', clip_on=False, s=80)

############################# Oil and Gas Production Linear Regression ############################

n = n - 2
X_pred_plot = df2_total_oil_prod.index.union(df2_total_oil_prod.index.shift(n)[-n:])
X_pred = X_pred_plot.to_julian_date().values.reshape(-1, 1)

X = df2_total_oil_prod.index.to_julian_date().values.reshape(-1, 1)

y_oil = df2_total_oil_prod['Total Oil (MBBLD)'].values
y_gas = df2_total_gas_prod['Total Gas (BCFD)'].values

ols_oil = linear_model.LinearRegression()
ols_gas = linear_model.LinearRegression()
model_oil = ols_oil.fit(X, y_oil)
model_gas = ols_gas.fit(X, y_gas)
response_oil = model_oil.predict(X_pred)
response_gas = model_gas.predict(X_pred)

ax2.plot(X_pred_plot[plot_begin:], response_oil[plot_begin:], label='Oil Prediction', color='green', linestyle='--')
ax3.plot(X_pred_plot[plot_begin:], response_gas[plot_begin:], label='Gas Prediction', color='red', linestyle='--')

ax2.scatter(X_pred_plot[-1], response_oil[-1], marker='o', color='green', clip_on=False, s=80)
ax3.scatter(X_pred_plot[-1], response_gas[-1], marker='o', color='red', clip_on=False, s=80)

ax2.scatter(df2_total_oil_prod.index, df2_total_oil_prod['Total Oil (MBBLD)'], label='Oil', marker='o', color='green', s=10, alpha=0.3)
ax3.scatter(df2_total_gas_prod.index, df2_total_gas_prod['Total Gas (BCFD)'], label='Gas', marker='o', color='red', s=10, alpha=0.3)

ax1.set_ylim(0, 10000)
ax2.set_ylim(0, 15000)
ax3.set_ylim(0, 150)

ax1.set_ylabel('Drilled &amp; DUC Well Counts', fontsize=axis_label_fontsize)
ax2.set_ylabel('Total Oil Prod. (MBBLD)', fontsize=axis_label_fontsize) 
ax2.set_yticks(np.arange(0, 15001, 3000))
ax3.set_ylabel('Total Gas Prod. (BCFD)', fontsize=axis_label_fontsize) 
ax3.set_yticks(np.arange(0, 151, 30))

ax1.tick_params(axis='both', which='major', labelsize=11)
ax2.tick_params(axis='both', which='major', labelsize=11)

ax1.grid(axis='y', alpha=0.5)
ax1.yaxis.get_major_ticks()[5].gridline.set_visible(False)
ax2.grid(axis='y', alpha=0.5)
ax2.yaxis.get_major_ticks()[5].gridline.set_visible(False)

ax1.spines.top.set_visible(False)
ax1.spines.right.set_visible(False)
ax2.spines.top.set_visible(False)
ax3.spines.top.set_visible(False)

h1, l1 = ax1.get_legend_handles_labels()
ax1.legend(h1[:2], l1[:2], loc='upper left', fontsize=legend_fontsize)
h2, l2 = ax2.get_legend_handles_labels()
h3, l3 = ax3.get_legend_handles_labels()
ax2.legend(h2 + h3, l2 + l3, fontsize=legend_fontsize, ncol=2, loc='upper left')

ax1.yaxis.set_major_formatter(ticker.EngFormatter()) 
ax2.yaxis.set_major_formatter(ticker.EngFormatter())  
ax3.yaxis.set_major_formatter(ticker.EngFormatter())  

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax1.set_title(setbold('Depletion of DUC Wells and Energy Supply')  + ",  Jan 2014 - June 2022", 
             fontsize=title_fontsize, pad=10, x=0.335, y=1.06)
ax1.annotate('', xy=(-0.1, 1.07), xycoords='axes fraction', xytext=(1.07, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax1.text(0.535, 0.4, 'July 2020', fontsize=10, ha='center', va='center', 
        transform=ax1.transAxes, color='purple', alpha=0.7, rotation=270)

ax2.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -0.22), xycoords='axes fraction', fontsize=12)
ax1.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax1.transAxes, color='grey', alpha=0.5)
ax2.text(0.145, 0.1, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax2.transAxes, color='grey', alpha=0.5)

ax1.text(0.765, 0.43, 'Depleted DUCs', fontsize=11, transform=ax1.transAxes, color='k')
ax2.text(0.75, 0.43, 'Potential Shortage', fontsize=11, transform=ax2.transAxes, color='k')
ax2.text(0.74, 0.33, 'with Energy Supply', fontsize=11, transform=ax2.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Recent trend: more production with less drilling"&gt;&lt;/div&gt;&lt;h3 id="3.2.-Recent-trend:-more-production-with-less-drilling"&gt;3.2. Recent trend: more production with less drilling&lt;a class="anchor-link" href="#3.2.-Recent-trend:-more-production-with-less-drilling"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Some readers may recall President Biden's request for the US oil and gas industry to ramp up drilling in order to curb the recent surge in gasoline prices. The industry reportedly hesitated to comply due to &lt;a href="https://www.cbsnews.com/news/oil-production-prices-us-companies-wont-increase-2022-dallas-fed-survey/" target="_blank"&gt;pressure from Wall Street for immediate financial returns.&lt;/a&gt; However, this is not the sole reason for the industry's reluctance to return to their previous drilling levels from 2014. Advances in technology (specifically horizontal drilling) have enabled the industry to produce more oil and gas with fewer wells, meaning they no longer need to drill as many wells as in the past to meet production demands.&lt;/p&gt;
&lt;p&gt;&lt;a href="#fig-6"&gt;Figure 6&lt;/a&gt; highlights three key points that demonstrate a clear trend. The decline in the number of drilling operations can be observed at [1], [2], and [3], while production steadily increases. A comparison to July 2018 [2] shows a 31% reduction in the number of newly drilled wells, but a 26% increase in oil production and a 35% increase in gas production. The contrast becomes even more striking when compared to September 2014 [1], where drilling activity decreased by 50% while production of both oil and gas nearly doubled.&lt;/p&gt;
&lt;div class="row" id="fig-6" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/US Major Basins Well Counts &amp; Production.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 6: Recent trend in production and drilling activities and count of DUC wells. We've been producing more oil and gas with less drilling activities over time.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (6)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################### DUC Wells Count per Basin #####################################

# compile a DataFrame to store count of DUC wells per basin
# source: EIA - https://www.eia.gov/petroleum/drilling/

dfs = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/Duc-EIA.xlsx', sheet_name=basin)
    df_cur['Basin'] = basin
    dfs.append(df_cur)

df = pd.concat(dfs)
df = df.sort_values('Date')
df.index = pd.to_datetime(df['Date'])

df_DUCs = df.groupby([pd.Grouper(freq='M'), 'Basin'])['DUC'].mean()
df_DUCs = df_DUCs.unstack().fillna(0)
df_DUCs = round(df_DUCs, 0)
df_DUCs['Total DUCs'] = df_DUCs.T.apply(lambda x: sum(x))

df_drilled = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Drilled'].sum()
df_drilled = df_drilled.unstack().fillna(0)
df_drilled['Total Drilled'] = df_drilled.T.apply(lambda x: sum(x))

df_completed = df.groupby([pd.Grouper(freq='M'), 'Basin'])['Completed'].sum()
df_completed = df_completed.unstack().fillna(0)
df_completed['Total Completed'] = df_completed.T.apply(lambda x: sum(x))

#################### Import All Data - Rig Count, Oil &amp; Gas Prod per Basins #######################

dfs2 = []
for basin in basins:
    df_cur = pd.read_excel('https://aegis4048.github.io/downloads/notebooks/sample_data/dpr-data.xlsx', sheet_name=basin + ' Region', skiprows=1)
    df_cur['Basin'] = basin
    dfs2.append(df_cur)

year_cutoff = '2013' # counting from year_cutoff + 1
date_header = 'Month'

df2 = pd.concat(dfs2)
df2 = df2.sort_values(date_header)
df2.index = pd.to_datetime(df2[date_header])
df2.drop(df2.columns[[2, 3, 5, 6]], axis=1, inplace=True)
df2.columns = ['Date', 'Rig Count', 'Total Oil Prod (BBLD)', 'Total Gas Prod (MCFD)', 'Basin']
df2 = df2[df2.index &gt; year_cutoff + '-12-31']

# current year (2022) prediction parameter
num_month_2022 = 6 # number of months in data set for current year
pred_factor = 12 / num_month_2022 

################################ Cross Table for Gas Production ###################################

# Total Gas Production
df2_total_gas_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Gas Prod (MCFD)'].sum()
df2_total_gas_prod = df2_total_gas_prod.unstack().fillna(0)
df2_total_gas_prod['Total Gas (BCFD)'] = df2_total_gas_prod.T.apply(lambda x: sum(x))
df2_total_gas_prod = df2_total_gas_prod / 1000000

################################ Cross Table for Oil Production ###################################

df2_total_oil_prod = df2.groupby([pd.Grouper(freq='M'), 'Basin'])['Total Oil Prod (BBLD)'].sum()
df2_total_oil_prod = df2_total_oil_prod.unstack().fillna(0)
df2_total_oil_prod['Total Oil (MBBLD)'] = df2_total_oil_prod.T.apply(lambda x: sum(x))
df2_total_oil_prod = df2_total_oil_prod / 1000

############################################# Plot ##############################################

axis_label_fontsize = 13
title_fontsize = 13
legend_fontsize = 11

fig, ax = plt.subplots(figsize=(9, 4.5))

ax3 = ax.twinx()
ax4 = ax.twinx()

ax.plot(df_drilled.index, df_drilled['Total Drilled'], color='k', label='Drilled')
ax.plot(df_DUCs.index, df_DUCs['Total DUCs'], color='purple', label='DUC')
ax3.plot(df2_total_oil_prod.index, df2_total_oil_prod['Total Oil (MBBLD)'], label='Oil', color='green')
ax4.plot(df2_total_gas_prod.index, df2_total_gas_prod['Total Gas (BCFD)'], label='Gas', color='red')

ax.set_ylim(0, 10000)
ax3.set_ylim(0, 15000)
ax4.set_ylim(0, 150)

ax.set_ylabel('Drilled &amp; DUC Well Counts', fontsize=axis_label_fontsize)

ax3.tick_params(axis='y', colors='green')
#ax3.spines['right'].set_position(('outward', 50))
ax3.spines['right'].set_color('green')
ax3.set_ylabel('Total Oil Prod. (MBBLD)', color='green', fontsize=axis_label_fontsize) 
ax3.set_yticks(np.arange(0, 15001, 3000))

ax4.tick_params(axis='y', colors='red')
ax4.spines['right'].set_position(('outward', 50))
ax4.spines['right'].set_color('red')
ax4.set_ylabel('Total Gas Prod. (BCFD)', color='red', fontsize=axis_label_fontsize) 
ax4.set_yticks(np.arange(0, 151, 30))
ax.tick_params(axis='both', which='major', labelsize=11)

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[5].gridline.set_visible(False)

ax.spines.top.set_visible(False)
ax3.spines.top.set_visible(False)
ax4.spines.top.set_visible(False)

h1, l1 = ax.get_legend_handles_labels()
h3, l3 = ax3.get_legend_handles_labels()
h4, l4 = ax4.get_legend_handles_labels()
ax.legend(h1 + h3 + h4, l1 + l3 + l4, fontsize=legend_fontsize, ncol=4, loc='upper left', framealpha=1)

ax.yaxis.set_major_formatter(ticker.EngFormatter()) 
ax3.yaxis.set_major_formatter(ticker.EngFormatter())  
ax4.yaxis.set_major_formatter(ticker.EngFormatter())  

def setbold(txt): 
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('US Major Basins Well Counts &amp; Production')  + ",  Jan 2014 - June 2022", 
             fontsize=title_fontsize, pad=10, x=0.37, y=1.06)
ax.annotate('', xy=(-0.115, 1.07), xycoords='axes fraction', xytext=(1.2, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Source: Pythonic Excursions, EIA', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.145, 0.7, 'aegis4048.github.io', fontsize=10, ha='center', va='center', 
        transform=ax.transAxes, color='grey', alpha=0.5)

ax.axvline(x=df_drilled.index[8], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[54], color='k', linestyle='--', linewidth=1, alpha=0.7)
ax.axvline(x=df_drilled.index[-1], color='k', linestyle='--', linewidth=1, alpha=0.7)

t1 = ax.text(0.1, 0.25, '[1]', fontsize=10, transform=ax.transAxes, color='k', )
t2 = ax.text(0.49, 0.25, '[2]', fontsize=10, transform=ax.transAxes, color='k')
t3 = ax.text(0.94, 0.25, '[3]', fontsize=10, transform=ax.transAxes, color='k')

t1.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))
t2.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))
t3.set_bbox(dict(facecolor='white', alpha=1, edgecolor='white', pad=1))

oil1 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][8])) + ' MBBLD'
gas1 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][8])) + ' BCFD'
drill1 = str(int(df_drilled['Total Drilled'][8])) + ' drilled'
ax.text(df_drilled.index[8 + 4], 2500, oil1, fontsize=9, color='green', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[8 + 4], 3000, gas1, fontsize=9, color='red', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[8 + 4], 2000, drill1, fontsize=9, color='k', bbox=dict(facecolor='none', edgecolor='none'))


oil2 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][54])) + ' MBBLD'
gas2 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][54])) + ' BCFD'
drill2 = str(int(df_drilled['Total Drilled'][54])) + ' drilled'
ax.text(df_drilled.index[54 + 4], 2500, oil2, fontsize=9, color='green', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[54 + 4], 3000, gas2, fontsize=9, color='red', bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[54 + 4], 2000, drill2, fontsize=9, color='k', bbox=dict(facecolor='none', edgecolor='none'))

ha = 'right'
oil3 = str(int(df2_total_oil_prod['Total Oil (MBBLD)'][-1])) + ' MBBLD'
gas3 = str(int(df2_total_gas_prod['Total Gas (BCFD)'][-1])) + ' BCFD'
drill3 = str(int(df_drilled['Total Drilled'][-1])) + ' drilled'
ax.text(df_drilled.index[-1 - 4], 2500, oil3, fontsize=9, color='green', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[-1 - 4], 3000, gas3, fontsize=9, color='red', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))
ax.text(df_drilled.index[-1 - 4], 2000, drill3, fontsize=9, color='k', ha=ha, bbox=dict(facecolor='none', edgecolor='none'))

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;The improvement in production efficiency despite the reduction in drilling can be attributed to the increasing use of horizontal wells. As compared to vertical wells, horizontal wells produce 2.5 to 7 times more, allowing the industry to meet demand with fewer drilling operations. As illustrated in &lt;a href="#fig-7"&gt;Figure 7&lt;/a&gt;, during economic downturns, the industry has favored horizontal wells by significantly reducing the number of vertical wells. It demonstrates a steady decrease in vertical wells, indicating that the majority of modern day drilling operations now consist of 91% horizontal wells and only 9% vertical wells.&lt;/p&gt;
&lt;div class="row full_screen_margin_90 mobile_responsive_plot_full_width" id="fig-7" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Monthly Historical Drill Type Count 2004.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 7: Historically the US oil and gas industry has turned into horizontal drilling during the times of economic crisis. Modern day drilling is mostly horizontal wells, which explains the higher production rates despite low drilling activities compared to 2014.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div class="solution_panel closed"&gt;
&lt;div class="solution_title"&gt;
&lt;p class="solution_title_string"&gt;Source Code For Figure (7)&lt;/p&gt;
&lt;ul class="nav navbar-right panel_toolbox"&gt;
&lt;li&gt;&lt;a class="collapse-link"&gt;&lt;i class="fa fa-chevron-down"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="clearfix"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="solution_content"&gt;
&lt;pre&gt;
            &lt;code class="language-python"&gt;
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import matplotlib.ticker as ticker
import warnings

############################################# Basins ##############################################

basins = sorted(['Anadarko', 'Appalachia', 'Eagle Ford', 'Haynesville', 'Niobrara', 'Permian', 'Bakken'])

################################# Drilled Wells Count per Basin ###################################

# import multiple csv files of basins and compile them into yearly count sum
# source: DrillingInfo

filename = 'https://aegis4048.github.io/downloads/notebooks/sample_data/Drill_Type_2004.xlsx'

# suppress warnings
warnings.filterwarnings('ignore')
warnings.simplefilter('ignore')

dfs = []
for basin in basins:
    df = pd.read_excel(filename, sheet_name=basin)
    df = df[df['Spud Date'].notna()]
    df['Basin'] = basin
    df['Year'] = df['Spud Date'].apply(lambda x: str(x).split('-')[0])
    dfs.append(df)

df_drilltype = pd.concat(dfs)
df_drilltype = df_drilltype.sort_values('Spud Date')
df_drilltype.index = pd.to_datetime(df_drilltype['Spud Date'])

df_drilltype = df_drilltype.groupby(pd.Grouper(freq='M'))['Drill Type'].value_counts(sort=True)
df_drilltype = df_drilltype.unstack().fillna(0).drop(['D', 'U'], axis=1)

df_drilltype_percent = df_drilltype.apply(lambda x: round(x / x.sum() * 100, 2), axis=1)
df_drilltype_percent = round(df_drilltype_percent, 1)

############################################# Plot ##############################################

fig, ax = plt.subplots(figsize=(8, 4))

x = df_drilltype.index
y = np.array([df_drilltype['H'].values, df_drilltype['V'].values])

ax.stackplot(x, *y, labels=['Horizontal', 'Vertical'], colors=['lightgrey', 'grey'])
ax.set_ylabel('Drilled Wells', fontsize=13)
ax.axvline(x=df_drilltype.index[-93], color='k', linestyle='--')
ax.axvline(x=df_drilltype.index[-28], color='k', linestyle='--')
ax.axvline(x=df_drilltype.index[-166], color='k', linestyle='--')

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[6].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

ax.legend(fontsize=11, ncol=3, loc='upper right')
ax.tick_params(axis='both', which='major', labelsize=11)

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Newly Drilled Wells Horizontal vs. Vertical Counts Trend')  + ",  Jan 2004 - June 2022", fontsize=12, pad=10, x=0.41, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='white', alpha=0.5)
ax.text(0.705, 0.63, '2014 Oil Price Crash', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.91, 0.55, 'Covid-19', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.375, 0.75, '2008 Recession', fontsize=11, ha='center', va='center',
        transform=ax.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()


#################################################################################################

fig, ax = plt.subplots(figsize=(8, 4))

ax.plot(df_drilltype_percent.index, df_drilltype_percent['H'], color='grey', label='Horizontal')
ax.plot(df_drilltype_percent.index, df_drilltype_percent['V'], color='k', label='Vertical')
ax.set_ylabel('Percent of Total', fontsize=13)
ax.tick_params(axis='both', which='major', labelsize=11)
ax.set_yticks(np.arange(0, 101, 10))

ax.grid(axis='y', alpha=0.5)
ax.yaxis.get_major_ticks()[10].gridline.set_visible(False)
ax.spines.top.set_visible(False)
ax.spines.right.set_visible(False)

ax.legend(fontsize=11, loc='center left')

def setbold(txt):
    return ' '.join([r"$\bf{" + item + "}$" for item in txt.split(' ')])

ax.set_title(setbold('Newly Drilled Wells Horizontal vs. Vertical Ratio Trend')  + ",  Jan 2004 - June 2022", fontsize=12, pad=10, x=0.41, y=1.06)
ax.annotate('', xy=(-0.11, 1.07), xycoords='axes fraction', xytext=(1.02, 1.07), arrowprops=dict(arrowstyle="-", color='k'))
ax.annotate('Data Source: Pythonic Excursions, DrillingInfo', xy=(-0.11, -0.18), xycoords='axes fraction', fontsize=12)
ax.text(0.16, 0.23, 'aegis4048.github.io', fontsize=10, ha='center', va='center',
        transform=ax.transAxes, color='grey', alpha=0.5)
ax.text(0.8, 0.43, '91% Horizontal', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.8, 0.34, '9% Vertical', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')
ax.text(0.8, 0.53, 'June 2022:', fontsize=12, ha='left', va='center',
        transform=ax.transAxes, color='k')

fig.set_facecolor("white")
fig.tight_layout()
            &lt;/code&gt;
        &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;div id="Continued discussion: Dead DUC wells"&gt;&lt;/div&gt;&lt;h2 id='4.-Continued-discussion:-"Dead"-DUC-wells'&gt;4. Continued discussion: "Dead" DUC wells&lt;a class="anchor-link" href='#4.-Continued-discussion:-"Dead"-DUC-wells'&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DUC wells are considered to be a working oil field capital because the wells can be turned on line for production for cheap. However, the empirical evidences suggests that the DUC wells may no longer function as a working capital if completion is delayed for too long. The empirical evidence presented in &lt;a href="#fig-8"&gt;Figure 8&lt;/a&gt; reveals that 95% of the wells in Anadarko are completed within 309 days afterd drilled, and Appalachia wells within 956 days. Failing to complete within this time frame may give birth to "dead" DUCs - wells that will never be completed. The expensive drilling cost the operator paid would be wasted.&lt;/p&gt;
&lt;p&gt;Two main causes for the birth of dead DUCs include costs associated with extending oil and gas lease and degrading economics with increasing DUC time due to reservoir depletion. In another study conducted in my next article, I demonstrate and quantify the impact of delay in completion since drilled on production by normalizing EURs with lateral length and completion size.&lt;/p&gt;
&lt;p&gt;Check out my next article &lt;a href="https://aegis4048.github.io/quantifying_the_impact_of_completion_delay_since_drilled_on_production" target="_blank"&gt;Quantifying The Impact Of Completion Delay Since Drilled On Production&lt;/a&gt; for more information.&lt;/p&gt;
&lt;div class="row" id="fig-8" style="margin-top: 15px;"&gt;
&lt;div class="col"&gt;&lt;img src="jupyter_images/Time Limit Until Completion.png"/&gt;&lt;/div&gt;
&lt;div class="col-12"&gt;&lt;p class="image-description"&gt;Figure 8: 95% Box plot of gap time between drilling and completion. The plot shows the time limit until completion for each basin. Each dot (very small, 99.5% transparency) represent one well of a basin. Upper whisker and the numeric annotation above it represent 95% upper limit. This means that wells with DUC time longer than the annotated number have less then 95% chance of ever being completed. Box plot for "All Regions" represent weighted average of all basins.&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: 'center'," +
        "    displayIndent: '0em'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['$','$'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
        "    } " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="oil-and-gas"></category><category term="oil"></category><category term="gas"></category><category term="DUC"></category><category term="drilling"></category><category term="horizontals"></category><category term="verticals"></category><category term="completion"></category><category term="production"></category><category term="recent-trend"></category><category term="energy-shortage"></category><category term="EIA"></category><category term="DrillingInfo"></category><category term="Enverus"></category><category term="DPR"></category></entry></feed>